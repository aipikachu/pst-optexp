% \iffalse meta-comment
%
% Copyright (C) 2007-2012 by Christoph Bersch <usenet@bersch.net>
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{pst-optexp.dtx}
%</driver>
%<stylefile>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<stylefile>\ProvidesPackage{pst-optexp}
%<*stylefile>
    [2012/05/22 v3.0beta Optical experimental setups with PSTricks]
%</stylefile>
%
%<*driver>
\documentclass[a4paper, DIV=9, oneside, toc=index]{scrreprt}
\usepackage{doc}
\setcounter{IndexColumns}{2}
\usepackage[latin1]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage{lmodern} 
\usepackage{amsmath, marvosym} 
\usepackage{bera}
\providecommand*\mainlang{}
\usepackage[ngerman, english,\mainlang]{babel} 
\usepackage{prettyref}
\usepackage[dvipsnames,x11names,svgnames]{xcolor} 
\usepackage{array,booktabs,tabularx} 
\usepackage{ragged2e, calc}
\newlength{\POEcaptionmargin}
\usepackage[labelfont={small, color=DOrange}, singlelinecheck=false, justification=raggedright]{caption} 
\DeclareCaptionFormat{poe}{\setlength{\POEcaptionmargin}{\widthof{#1}+5pt}\hspace*{-\POEcaptionmargin}#1\par}
\captionsetup[lstlisting]{format=poe}
\usepackage{nicefrac}
\usepackage{pst-func} 
\usepackage{pst-optexp} 
\psset[optexp]{pswarning=false}
\usepackage{pst-circ}
\usepackage[makeindex]{splitidx} 
\usepackage{hypdoc} 
\hypersetup{%
  colorlinks=true, 
  urlcolor=black,
  linkcolor=pdflinkcolor, 
  breaklinks,
  linktocpage=true} 
\usepackage{breakurl}
\definecolor{DOrange}{rgb}{1,.4,.2}%
\definecolor{DDOrange}{rgb}{0.7, 0.23, 0.07}%
\colorlet{pdflinkcolor}{DOrange}
\colorlet{DGreen}{green!90!black}
\usepackage{pst-tree}
\usepackage{showexpl}
\makeatletter\renewcommand*\SX@Info{}\makeatother
\usepackage{etoolbox}
\undef{\cs}
\undef{\cmd}
\usepackage{ltxdockit}
\newcommand{\poeTR}[1]{\TR{\ttfamily\color{DOrange}#1}}
\definecolor{colKeys}{rgb}{0,0,0}
\definecolor{colIdentifier}{rgb}{0,0,0}
\colorlet{colComments}{green!60!black}
\definecolor{colString}{rgb}{0,0.5,0} 
\newlength{\codeoverhang}
\setlength{\codeoverhang}{0.5\marginparwidth+\marginparsep}
\lstset{%
  language=[LaTeX]TeX, identifierstyle=\color{colIdentifier}, %
  keywordstyle=\color{colKeys}, %
  keywordstyle = [21]\color{DOrange}, %
  keywordstyle = [22]\color{DOrange}, %
  stringstyle=\color{colString}, %
  commentstyle=\color{colComments}, %
  float=hbp,%
  basicstyle=\ttfamily\small, %
  columns=flexible, %
  tabsize=4, %
  extendedchars=true, %
  showspaces=false, %
  showstringspaces=false, %
  breaklines=true, %
  breakautoindent=true, %
  breakatwhitespace=true, %
  captionpos=t, %
  xleftmargin=1em, %
  prebreak = {\raisebox{-1ex}[\ht\strutbox]{\kern0.5ex \Large\Righttorque}},
  rulecolor=\color{black!20}, %
  texcsstyle = [20]\color{DDOrange},%!60!black},%{red!60!black}, %
  moretexcs = [20]{lens, optbox, oenode, oenodeIn, oenodeExt, oenodeOut,
    oenodeRefA, oenodeRefB, oenodeTrefA, oenodeTrefB, oenodeLabel,
    oenodeRotref, oenodeBeam, oenodeBeamUp, oenodeBeamLow,
    oenodeCenter, optplate, optretplate, pinhole, crystal,optdetector,
    optdiode, doveprism, polarization, mirror, beamsplitter, optgrating,
    optprism, rightangleprism, pentaprism, optdipole, optripole,
    optfiber, optamp, optmzm, optfilter, polcontrol, optisolator,
    optswitch, fiberdelayline, optfiberpolarizer, fibercollimator,
    optcoupler, wdmcoupler, wdmsplitter, optcirculator, drawbeam, 
    drawwidebeam, drawfiber, frontlayer, backlayer, newOptexpDipole,
    newOptexpTripole, newOptexpFiberDipole}, %
  morekeywords = [22] {optexp},
  explpreset={%
    pos=l, width=-99pt, hsep=5mm, overhang=\codeoverhang,
    varwidth, vsep=\bigskipamount, rframe={}},
}
\lstdefinestyle{example}{explpreset={%
    escapechar=*, pos=l, width=-99pt, hsep=5mm, overhang=\codeoverhang,
    varwidth, vsep=\bigskipamount, rframe={}}}
\makeatletter
\providecommand\ON{%
  \gdef\lst@alloverstyle##1{\textcolor{black!50}{\strut##1}%
}}
\providecommand\OFF{\xdef\lst@alloverstyle##1{##1}}
\makeatother
\colorlet{sectioncolor}{DOrange}
\addtokomafont{sectioning}{\color{sectioncolor}}
\addtokomafont{subsection}{\Large}
\addtokomafont{subsubsection}{\Large}
\usepackage[automark,nouppercase]{scrpage2}
\pagestyle{scrheadings}
\clearscrheadings
\clearscrplain
\ohead{\pagemark}
\ihead{\headmark}
\ofoot[\pagemark]{}
\automark[subsection]{section}
\setheadsepline{.4pt}[\color{DOrange}]
\setheadwidth[0pt]{text}
\setfootwidth[0pt]{text}
%
\makeatletter
\patchcmd{\l@chapter}{1.5em}{2em}{}{}
\renewcommand*\l@section{\bprot@dottedtocline{1}{1.5em}{3.0em}}
\renewcommand*\l@subsection{\bprot@dottedtocline{2}{3.8em}{4.0em}}
\newrobustcmd*{\fnurl}[1][]{\hyper@normalise\ltd@fnurl{#1}}
\def\ltd@fnurl#1#2{\footnote{#1\hyper@linkurl{\Hurl{#2}}{#2}}}
\makeatother
%
\usepackage{csquotes}
\MakeAutoQuote{«}{»}
% spot is used in ltxdockit.sty
\colorlet{spot}{sectioncolor}
\newpsstyle{Refline}{linecolor=gray!60}
\colorlet{Refline}{gray!60}
\makeatletter
% is identical to the changelog definition in ltxdockit.sty, but 
% does also set \parsep to 0pt.
\renewenvironment*{changelog}
  {\list{}{%
     \setlength{\leftmargin}{0pt}%
     \setlength{\itemsep}{0pt}%
     \renewcommand*{\makelabel}[1]{##1\hss}%
     \raggedright\changelogfont}%
   \def\release##1##2{%
     \@release{##1}{##2}%
     \list{}{%
       \setlength{\leftmargin}{1.5em}%
       \setlength{\itemindent}{-1.5em}%
       \setlength{\itemsep}{0pt}%
       \setlength{\parsep}{0pt}%
     }%
     \samepage
     \begingroup
     \def\item{\endgroup\item\@itempenalty\z@}}%
   \def\endrelease{\endlist}%
   \def\@release##1##2{%
     \begingroup
     \changeloglabelfont
     \item\relax
     \ltd@pdfbookmark{##1}{##1 (##2)}%
     ##1\quad##2\par\nobreak
     \endgroup}
   \def\see##1{%
     \leaders\hbox{$\m@th\mkern4.5mu\hbox{.}\mkern4.5mu$}%
     \hfill\makebox[3em][l]{\ref{##1}}}}
  {\endlist}
\makeatother
% Fonts definitions used in ltxdockit.sty
\renewcommand*{\verbatimfont}{\ttfamily}
\renewcommand*{\displayverbfont}{\ttfamily}
\renewcommand*{\marglistfont}{\spotcolor\sffamily\small}
\renewcommand*{\margnotefont}{\sffamily\small}
\renewcommand*{\optionlistfont}{\spotcolor\sffamily\displayverbfont}
\renewcommand*{\ltxsyntaxfont}{\ttfamily}
\renewcommand*{\ltxsyntaxlabelfont}{\spotcolor\displayverbfont}
\renewcommand*{\changelogfont}{\normalfont}
\renewcommand*{\changeloglabelfont}{\spotcolor\sffamily\bfseries}

\makeatletter
% an idea from GL to provide links inside the listings to the pst-optexp commands: 
% <https://groups.google.com/groups/search?as_umsgid=4d89ee49%240%2418590%24426a74cc%40news.free.fr>
\providerobustcmd*\ifrefundefined [1]{%
  \begingroup%
    \csname @safe@activestrue\endcsname%
    \expandafter\endgroup\csname @\ifcsname r@#1\endcsname second\else first\fi oftwo\endcsname
}% \ifrefundefined
\def\lsthk@OutputBox@H@@k{%
    \begingroup%
      \let\lst@UM\@empty%
      \edef\@tempc{cmd:\detokenize\expandafter{\the\lst@token }}%\edef
      \ifrefundefined{\@tempc}%
    \endgroup%
    \sethyperlistings%
}% \lsthk@OutputBox@H@@k
\def\sethyperlistings {\global\let \hyperlistingsreference =\@tempc
     \endgroup \aftergroup \dohyperlistings }% after \hbox
\def\dohyperlistings {\def\lst@alloverstyle ##1{\hyperlistings ##1}}
\def\hyperlistings{%
    \setbox\@tempboxa\hbox%
    \bgroup%
      \rlap{\hypersetup {linkcolor=.}\relax\fboxrule\z@%
      \hyperref[\hyperlistingsreference]{\boxframe{\wd\@tempboxa}{\ht\@tempboxa}{\dp\@tempboxa}}}%
      \unhbox\@tempboxa%
    \egroup%
}% \hyperlistings
\let\lsthk@OutputBox\lsthk@OutputBox@H@@k

\newenvironment*{stylelist}
  {\list{}{%
     \setlength{\labelwidth}{\marglistwidth}%
     \setlength{\labelsep}{0.5\marglistsep}%
     \setlength{\leftmargin}{0pt}%
     \renewcommand*{\makelabel}[1]{\hss\optionlistfont##1}}%
     \let\styleitem\POE@styleitem}%
  {\endlist}

\def\ltd@optionlist{%
  \let\optitem\POE@optitem
  \let\valitem\POE@valitem
  \let\choitem\POE@choitem
  \let\boolitem\POE@boolitem
  \let\intitem\POE@intitem
  \let\numitem\POE@numitem
  \let\psnumitem\POE@psnumitem
  \let\poeitem\ltd@item}

\def\POE@styleitem{%
  \@ifnextchar[%]
    {\POE@styleitem@i}
    {\POE@styleitem@i[]}
}
\def\POE@styleitem@i[#1]#2{%
  \item[{#2}]%
  \label{prm:#2}%
  \begingroup\raggedright
  \prm{psstyle}%
  \settowidth\@tempdimb{\prm{psstyle}}%
  \ifblank{#1}
    {}
    {\hfill default:~\ltd@textverb{#1}}
  \par\endgroup}

\def\POE@optitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@optitem@i}
    {\booltrue{@tempswa}\POE@optitem@i}}
\newcommand*{\POE@optitem@i}[3][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{#3}{}}
    {\ltd@option{#2}{#2}{#3}{\ltd@textverb{#1}}}}%

\def\POE@valitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@valitem@i}
    {\booltrue{@tempswa}\POE@valitem@i}}
\newcommand*{\POE@valitem@i}[3][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{#3}}{}}
    {\ltd@option{#2}{#2}{\prm{#3}}{\ltd@textverb{#1}}}}%

\def\POE@choitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@choitem@i}
    {\booltrue{@tempswa}\POE@choitem@i}}
\newcommand*{\POE@choitem@i}[3][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\ltd@verblist{#3}}{}}
    {\ltd@option{#2}{#2}{\ltd@verblist{#3}}{\ltd@textverb{#1}}}}%

\def\POE@boolitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@boolitem@i}
    {\booltrue{@tempswa}\POE@boolitem@i}}
\newcommand*{\POE@boolitem@i}[2][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\ltd@verblist{true,false}}{}}
    {\ltd@option{#2}{#2}{\ltd@verblist{true,false}}{\ltd@textverb{#1}}}}%

\def\POE@intitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@intitem@i}
    {\booltrue{@tempswa}\POE@intitem@i}}
\newcommand*{\POE@intitem@i}[2][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{int}}{}}
    {\ltd@option{#2}{#2}{\prm{int}}{\ltd@textverb{#1}}}}%

\def\POE@numitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@numitem@i}
    {\booltrue{@tempswa}\POE@numitem@i}}
\newcommand*{\POE@numitem@i}[2][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{num}}{}}
    {\ltd@option{#2}{#2}{\prm{num}}{\ltd@textverb{#1}}}}%

\def\POE@psnumitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@psnumitem@i}
    {\booltrue{@tempswa}\POE@psnumitem@i}}
\newcommand*{\POE@psnumitem@i}[2][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{psnum}}{}}
    {\ltd@option{#2}{#2}{\prm{psnum}}{\ltd@textverb{#1}}}}%

\def\ltd@cmditem@ii#1#2{%
  \ltd@itemsave
  \ifhmode
    \itemsep-\topsep
  \else
    \ltd@itembreak
  \fi
  \item[#1]%
  \ltd@itemrest
  \ifblank{#2}{}{\label{cmd:#2}}%
  \begingroup
  \ltd@syntaxsetup
  \ltxsyntaxfont
  \let\@tempa\@empty
  \ltd@parseargs}


\let\plainllap\llap
\newrobustcmd\macro@llap[1]{{\global\let\llap\plainllap
 \setbox0=\hbox\bgroup \macro@font\small\saved@macroname\egroup
 \ifdim\wd0>30mm
    \hbox to\z@ \bgroup\hss \hbox to30mm{\unhcopy0\hss}\egroup
    \edef\@tempa{\hskip\dimexpr\the\wd0-30mm}\global\everypar\expandafter{\the\expandafter\everypar
                                                                           \@tempa \global\everypar{}}%
 \else \llap{\unhbox0}\fi}}
 \AtBeginEnvironment{macro}{\let\llap\macro@llap}
\makeatother

\newcommand*{\PSstring}[1]{{\normalfont\small\ttfamily(#1)}}
\newcommand*{\PSarray}[1]{{\normalfont\small\ttfamily[#1]}}
\newcommand*{\PSname}[1]{{\normalfont\small\ttfamily/#1}}
\newcommand*{\PSproc}[1]{{\normalfont\small\ttfamily\textbraceleft #1\textbraceright}}
\newcommand*{\PSvar}[1]{{\normalfont\small\ttfamily #1}}
\newcommand*{\PSop}[1]{{\normalfont\small\ttfamily\color{DOrange}\hskip 3pt #1\hskip 3pt}}

\newcommand*{\nodename}[1]{\emph{#1}}
\newcommand*{\param}[1]{\normalfont\texttt{#1}}
\newcommand*{\paramvalue}[1]{\texttt{#1}}
\newcommand*{\styleshape}[1]{\texttt{#1}}
\newcommand{\docindex}[1]{\sindex[doc]{#1|hyperpage}}
\makeatletter
\def\Lcs{\@ifstar{\Lcs@nobm}{\Lcs@bm}}
\def\Lcs@nobm#1{\nxLcs{#1}\xLcs{#1}}
\def\Lcs@bm#1{\hyperref[cmd:#1]{\Lcs@nobm{#1}}}
\def\xLcs#1{\docindex{#1=\nxLcs{#1}}\docindex{\POEindexMacro!#1=\nxLcs{#1}}}
\def\nxLcs#1{\texttt{\textbackslash#1}}

\def\LPack#1{\texttt{#1}\docindex{#1=\texttt{#1}}\docindex{\POEindexPackage!#1=\texttt{#1}}}
\def\nxLPack#1{\texttt{#1}}

\def\Lenv{\@ifstar{\Lenv@nobm}{\Lenv@bm}}
\def\Lenv@nobm#1{\nxLenv{#1}\xLenv{#1}}
\def\Lenv@bm#1{\hyperref[env:#1]{\Lenv@nobm{#1}}}
\def\xLenv#1{\docindex{#1=\texttt{#1}}\docindex{\POEindexEnv!#1=\texttt{#1}}}
\def\nxLenv#1{\texttt{#1}}
\let\orig@ltd@envitem\ltd@envitem
\def\ltd@envitem#1{\orig@ltd@envitem{#1}\label{env:#1}\xLenv{#1}}

\def\Lkeyword{\@ifstar{\Lkeyword@nobm}{\Lkeyword@bm}}
\def\Lkeyword@nobm#1{\texttt{#1}\xLkeyword{#1}}
\def\Lkeyword@bm#1{\hyperref[prm:#1]{\Lkeyword@nobm{#1}}}
\def\xLkeyword#1{\docindex{#1=\texttt{#1}}\docindex{\POEindexKeyword!#1=\texttt{#1}}}
\def\nxLkeyword#1{\texttt{#1}}

\def\xLoption#1{\docindex{#1=\texttt{#1}}\docindex{\POEindexOption!#1=\texttt{#1}}}
\def\Loption#1{\texttt{#1}\xLoption{#1}}
\def\nxLoption#1{\texttt{#1}}

\def\Lstyle{\@ifstar{\Lstyle@nobm}{\Lstyle@bm}}
\def\Lstyle@nobm#1{\texttt{#1}\xLstyle{#1}}
\def\Lstyle@bm#1{\hyperref[prm:#1]{\Lstyle@nobm{#1}}}
\def\xLstyle#1{\docindex{#1=\texttt{#1}}\docindex{\POEindexStyle!#1=\texttt{#1}}}
\def\nxLstyle#1{\texttt{#1}}

\def\Ldipole#1{\nxLcs{#1}\xLdipole{#1}}
\def\xLdipole#1{\docindex{#1=\nxLcs{#1}}\docindex{\POEindexDipoles!#1=\nxLcs{#1}}}

\def\Ltripole#1{\nxLcs{#1}\xLtripole{#1}}
\def\xLtripole#1{\docindex{#1=\nxLcs{#1}}\docindex{\POEindexTripoles!#1=\nxLcs{#1}}}

\def\Lfdipole#1{\nxLcs{#1}\xLfdipole{#1}}
\def\xLfdipole#1{\docindex{#1=\nxLcs{#1}}\docindex{\POEindexFiberDipoles!#1=\nxLcs{#1}}}

\def\Lfmultipole#1{\nxLcs{#1}\xLfmultipole{#1}}
\def\xLfmultipole#1{\docindex{#1=\nxLcs{#1}}\docindex{\POEindexFiberMultipoles!#1=\nxLcs{#1}}}
\makeatother

\newcommand{\dipoledesc}[1]{%
  \xLdipole{#1}%
  \cmditem{#1}[options](in)(out){label}%
}
\newcommand{\tripoledesc}[1]{%
  \xLtripole{#1}%
  \cmditem{#1}[options](in)(center)(out){label}%
}

\newcommand{\fiberdipoledesc}[1]{%
  \xLfdipole{#1}%
  \cmditem{#1}[options](in)(out){label}%
}

\newenvironment*{pssyntax}
  {\list{}{\small
     \setlength{\labelsep}{0pt}%
     \setlength{\leftmargin}{10pt}%
     \item[]}}
  {\endlist}

\newcommand{\psarglistfont}{\small}
\newenvironment*{psarglist}
  {\list{}{%
     \setlength{\labelwidth}{10pt}%
     \setlength{\labelsep}{0pt}%
     \setlength{\leftmargin}{0pt}%
     \setlength{\itemsep}{\parsep}%
     \setlength{\parsep}{0pt}%
     \renewcommand*{\makelabel}[1]{\hss\psarglistfont##1}}}
  {\endlist}

\makeatletter
\renewenvironment{theglossary}{\GlossaryParms \let\item\@idxitem \ignorespaces}{}
\makeatother
\def\psargitem#1{\item[#1]\hfill\par\nobreak}

\addtopsstyle{Fiber}{linecolor=DOrange,linewidth=1.5\pslinewidth}
\addtopsstyle{Beam}{linewidth=1.5\pslinewidth}
\EnableCrossrefs
\CodelineIndex
%%\OnlyDescription
\begin{document}
  \DocInput{pst-optexp.dtx}
  \begin{otherlanguage}{english}
    \printindex[idx]
  \end{otherlanguage}
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \GetFileInfo{pst-optexp.dtx}
%
% \DoNotIndex{\@,\g@addto@macro,\newif,\gdef,\xdef,\newcounter,\or,\ifcase,\\}
% \DoNotIndex{\newcommand,\newenvironment,\def,\edef,\let,\if,\ifx,\else,\fi,\@ifnextchar}
% \DoNotIndex{\space,\relax,\nr,\val,\ignorespaces,\ifdim,\ifcat,\@nil,\@none,\@empty}
% \DoNotIndex{\PackageError,\PackageWarning,\advance,\csname,\endcsname,\bgroup,\egroup}
% \DoNotIndex{\expandafter,\@@comp,\@postcode}
% \DoNotIndex{\psset}
% \DoNotIndex{\@wd,\@sz,\@ht,\@yshift,\@step,\@xl,\@sep,\@r,\@dp,\@altan,\@extpostcode}
% \DoNotIndex{\@f@cnt,\@f@r,\@f@sep,\@hshift,\@bs@wd,\@c@caxisL,\@cnt,\@pstfalse,\@psttrue}
% \DoNotIndex{\@th,\@rL,\@rR,\i,\long,\optexp@nodeA,\optexp@nodeB}
% \DoNotIndex{\POE@temp,\POE@tempa,\POE@tempb,\POE@tempc,\POE@tempd}
% \DoNotIndex{\POE@getref@b,\POE@getref@c,\POE@getref@l,\POE@getref@r,\POE@getref@t}
% \DoNotIndex{\the,\toks@}
% 
% \newif\ifGERMAN  \GERMANfalse
% \newif\ifENGLISH \ENGLISHfalse
% \iflanguage{ngerman}{\GERMANtrue}{%
%   \iflanguage{german}{\GERMANtrue}{\GERMANfalse}}
% \iflanguage{english}{\ENGLISHtrue}{\ENGLISHfalse}
%
% \ifGERMAN
%   \newrefformat{chap}{Kap.~\ref{#1}}
%   \newrefformat{sec}{Kap.~\ref{#1}}
%   \newrefformat{l}{Zeile~\ref{#1}}
%   \newrefformat{ex}{Bsp.~\ref{#1}}
%   \newindex[Quelltextindex]{idx}
%   \newindex[Dokumentationsindex]{doc}
%   \newcommand{\POEindexPackage}{Paket}
%   \newcommand{\POEindexMacro}{Makro}
%   \newcommand{\POEindexKeyword}{Schlüsselwort}
%   \newcommand{\POEindexEnv}{Umgebung}
%   \newcommand{\POEindexOption}{Option}
%   \newcommand{\POEindexStyle}{Stil}
%   \newcommand{\POEindexDipoles}{Zweipol}
%   \newcommand{\POEindexTripoles}{Dreipol}
%   \newcommand{\POEindexFiberDipoles}{Faserzweipol}
%   \newcommand{\POEindexFiberMultipoles}{Fasermultipol}
%   \renewcommand*\lstlistingname{Bsp.}
% \fi
% \ifENGLISH
%   \newrefformat{chap}{Sec.~\ref{#1}}
%   \newrefformat{sec}{Sec.~\ref{#1}} 
%   \newrefformat{l}{Line~\ref{#1}}
%   \newrefformat{ex}{Ex.~\ref{#1}}
%   \newindex[Code index]{idx}
%   \newindex[Documentation index]{doc}
%   \newcommand{\POEindexPackage}{Package}
%   \newcommand{\POEindexMacro}{Macro}
%   \newcommand{\POEindexKeyword}{Keyword}
%   \newcommand{\POEindexEnv}{Environment}
%   \newcommand{\POEindexOption}{Option} 
%   \newcommand{\POEindexStyle}{Style}
%   \newcommand{\POEindexDipoles}{Dipoles}
%   \newcommand{\POEindexTripoles}{Tripoles}
%   \newcommand{\POEindexFiberDipoles}{Fiber dipoles}
%   \newcommand{\POEindexFiberMultipoles}{Fiber multipoles}
%   \renewcommand*\lstlistingname{Ex.}
% \fi
%
% \newcommand*{\sizeexplanation}[2][1.6]{% 
%   \ifGERMAN 
%     Die Höhe #2, die Breite ist \opt{#1} mal die Höhe. Mit
%     dem \opt{xunit} oder \opt{yunit} Parameter kann dieses Verhältnis
%     geändert werden.
%   \fi
%   \ifENGLISH
%     The height of the #2, the width is \opt{#1} times the
%     height. Use the \opt{xunit} or \opt{yunit} parameter to change this
%     relation.
%   \fi
% }
% \newcommand{\refstringexplanation}{%
%   \ifGERMAN
%   Analog zum Referenzpunkt von \nxLcs{rput}, kann jede Kombination von
%   \opt{c} (mittig), \opt{t} (oben), \opt{b} (unten), \opt{l} (links) und
%   \opt{r} (rechts) sein.
%   \fi
%   \ifENGLISH
%   Like the reference point of \nxLcs{rput}, can be any comination of
%   \opt{c} (center), \opt{t} (top), \opt{b} (bottom), \opt{l} (left), and
%   \opt{r} (right).
%   \fi}
%
% \newcommand*{\linewidthexplanation}[2]{% 
% \ifGERMAN
% Die Linienbreite #1. Diese könnte ebenfalls über den
% \opt{linewidth} Parameter gesetzt werden. Mit diesem Parameter kann
% aber die Linienbreite aller #2 global eingestellt werden.
% \fi
% \ifENGLISH
% The linewidth of the #1. This could be defined also with the
% generic \opt{linewidth} option. But this parameter allows setting
% globally the linewidth of all #2.
% \fi
% }
%
% \newcommand*{\deprecatedmsg}[2][3.0]{%
% \ifGERMAN Dieser Parameter ist seit Version #1 veraltet, verwenden Sie stattdessen #2. \fi
% \ifENGLISH This parameter is deprecated since version #1, use #2 instead.\fi
% }
%
% \newcommand*{\addtostylemsg}[1]{%
% \ifGERMAN Der vorhandene \Lstyle{#1}-Stil wird lokal um die Parameter in
%   \prm{list} erweitert, \prm{list} muss mit geschweiften Klammern gekapselt
%   werden.
% \fi
% \ifENGLISH 
%   The \Lstyle{#1} style is extended by locally adding the
%   parameters contained in \prm{list}. The \prm{list} must be surrounded
%   by curly braces.
% \fi
% }
% \newcommand*{\newstylemsg}[1]{%
% \ifGERMAN Analog zu \Lkeyword{addto#1}, nur wird der
%   \Lstyle{#1}-Stil mit denen neuen Parametern überschrieben.
% \fi
% \ifENGLISH Analogous to \Lkeyword{addto#1}, but an existing
%   \Lstyle{#1} style is overwritten with the new parameter set.
% \fi
% }
%
% \makeatletter
% \renewcommand\maketitle{^^A
% \thispagestyle{empty}^^A
% \begin{titlepage}
% \begin{pspicture}(1.6in,0.685in)(10,21.7)
%   \psframe[fillstyle=solid,linecolor=lightgray,fillcolor=lightgray,linestyle=solid](0,-5.75)(21.5,10)
%   \psframe[fillstyle=solid,linecolor=Orange!85!Red,fillcolor=Orange!85!Red,linestyle=solid](0,10)(21.5,10.5)
%   \psframe[fillstyle=solid,linecolor=Orange!85!Red,fillcolor=Orange!85!Red,linestyle=solid](0,21.1)(21.5,21.2)
%   \rput[lb](3,22){\Huge\sffamily\color{Orange!65!Red}\psscalebox{2}{\textbf{PSTricks}}}
%   \rput[lb](3,14.1){\parbox{15cm}{\sffamily\RaggedRight\bfseries\huge\@title}}
%   \rput[lb](3,7.6){\parbox{13cm}{\sffamily\@date}}
%   \rput[lb](3,-2.6){\parbox[b]{17cm}{\sffamily\RaggedRight 
%     ~\hfill\makebox[7cm][l]{\ifGERMAN Paketautor:\fi\ifENGLISH Package author:\fi}\\
%     ~\hfill\makebox[7cm][l]{^^A
%       \bfseries\tabular[t]{@{}l@{}}\@author\endtabular}}}
%  \rput[C](11,4){\bgImage}
%  \end{pspicture}^^A
% \end{titlepage}}
% \makeatother
% 
% \ifGERMAN
%   \title{\texttt{pst-optexp}\\ Optische Versuchsaufbauten\\[0.5ex] \small \fileversion}
%   \hypersetup{pdftitle={Optische Versuchsaufbauten}}
% \fi
% \ifENGLISH
%   \title{\texttt{pst-optexp}\\ Drawing optical experimental setups\\[0.5ex] \small \fileversion}
%   \hypersetup{pdftitle={Optical experimental setups}}
% \fi
% \author{Christoph Bersch}
% \date{\filedate}
% \def\bgImage{\psset{unit=1.3}
% \begin{pspicture}(-0.2,0.1)(8.2,5.3)
%   \pnode(0,3){M1}
%   \pnode(8,3){M2}
%   \pnode(8,0.5){In}
%   \pnode(6.5,0.5){Min}
%   \pnode(6.5,3){Pin}
%   \pnode(4.5,3){Min2}
%   \pnode(1.3, 0.5){Mout}
%   \pnode(1.3,3){Pout}
%   \pnode(3.5,3){Mout2}
%   \pnode(0,0.5){Out}
%   \definecolor[ps]{bl}{rgb}{tx@addDict begin Red Green Blue end}
%   \addtopsstyle{Beam}{linecolor=bl, linejoin=1}
%   \psset{mirrortype=extended, mirrordepth=0.15}
%   \newpsstyle{ExtendedMirror}{linestyle=none, hatchwidth=0.5\pslinewidth, hatchsep=1.2\pslinewidth,
%                 fillstyle=hlines}
%   \begin{optexp}
%   \mirror[mirrorwidth=4, mirrorradius=11.](M2)(M1)(M2)
%   \mirror[mirrorwidth=4, mirrorradius=10.4](M1)(M2)(M1)
%   \mirror(In)(Min)(Pin)
%   \optprism[n=1.85, addtoOptComp={linewidth=1.5\pslinewidth}](Min)(Pin)(Min2)
%   \mirror[compshift=-0.4](Pin)(Min2)(Pin)
%   \mirror[compshift=0.4](Pout)(Mout2)(Pout)
%   \optprism[n=1.85, linewidth=1.5\pslinewidth](Mout2)(Pout)(Mout)
%   \mirror(Pout)(Mout)(Out)
%   \multido{\i=0+1}{40}{^^A
%     \pstVerb{^^A
%       \i\space 650 400 sub 39 div mul 400 add 
%       tx@addDict begin wavelengthToRGB end }^^A
%     \drawbeam[n={-0.002 \i\space mul n add}, beaminsidelast]{(In)}{3-5}{2}{1}{6-7}
%   }^^A
%   \newpsstyle{Beam}{linecolor=red}
%   \backlayer{\psline[style=Beam,ArrowInside=->, linewidth=2\pslinewidth, arrowinset=0](In)(\oenodeIn{3})(\oenodeOut{4})}
%   \drawbeam[linewidth=2\pslinewidth, arrows=->, arrowinset=0, beamangle=-90, beamalign=abs]{(\oenodeBeam{})}{8}{(Out)}  
% \end{optexp}
% \rput(4,4.5){^^A
%   \psframe[fillstyle=solid,fillcolor=gray!70](-0.1, -0.6)(0.1, 0.7)
%   \multido{\r=-0.5+0.1}{12}{^^A
%     \psline[linewidth=0.5\pslinewidth](-0.1,\r)(0.1,\r)
%   }^^A
% }
% \end{pspicture}}
%
% \maketitle
% 
% \clearpage
% \tableofcontents
% \clearpage
% 
% \ifGERMAN
%   \chapter{Einführung}
% \fi
% \ifENGLISH
%   \chapter{Introduction}
% \fi
%
% \ifGERMAN
%   \section{Über das Paket}
%   \LPack{pst-optexp} ist ein PSTricks-Paket zum Skizzieren optischer
%   Versuchsaufbauten. Dafür werden viele unterschiedliche Freistrahl- und
%   Faseroptische Komponenten bereitgestellt.
% \fi 
% \ifENGLISH
%   \section{About the package}
%   The package \LPack{pst-optexp} is a collection of optical components
%   that facilitate easy sketching of optical experimental
%   setups. Mechanisms for proper alignment of different components are
%   provided internally. This way the user does not have to care for proper
%   orientation of the elements. Macros for convenient definition of new 
%   user-defined components are also provided.
% \fi
%
% \ifGERMAN
%   \section{Anforderungen}
%   \LPack{pst-optexp} Version 3.0 benötigt \LaTeX{} und aktuelle Versionen der
%   Pakete \LPack{pst-node}, \LPack{pstricks-add}, \LPack{multido},
%   \LPack{pst-eucl} und \LPack{environ}.
%
%   Alle PSTricks-Pakete machen regen Gebrauch von Postscript, so dass der
%   typische Arbeitsfluss \opt{latex}, \opt{dvips} und ggf. \opt{ps2pdf}
%   umfasst. Es gibt viele alternative Methoden um die Dokumente zu
%   kompilieren.\fnurl{http://tug.org/PSTricks/main.cgi?file=pdf/pdfoutput}
% \fi
% \ifENGLISH
%   \section{Requirements}
%   \LPack{pst-optexp} version 3.0 requires \LaTeX{} and recent versions of
%   \LPack{pst-node}, \LPack{multido}, \LPack{pstricks-add},
%   \LPack{pst-eucl}, and \LPack{environ}. 
%
%   All PSTricks package heavily rely on the Postscript language so that the
%   typical workflow involves \opt{latex}, \opt{dvips}, and \opt{ps2pdf}. Of
%   course there are several alternative ways to compile your
%   documents.\fnurl{http://tug.org/PSTricks/main.cgi?file=pdf/pdfoutput} 
% \fi
%
% \ifGERMAN
%   \section{Verbreitung und Installation}
%   Dieses Paket ist auf
%   CTAN\fnurl{http://mirror.ctan.org/graphics/pstricks/contrib/pst-optexp}
%   erhältlich und in \TeX Live and MiK\TeX{} enthalten.
% 
%   Das \LPack{pst-optexp} Paket umfasst die zwei Hauptdateien
%   \texttt{pst-optexp.ins} und \texttt{pst-optexp.dtx}. Durch Aufrufen
%   von \texttt{latex pst-optexp.ins} werden die beiden folgenden
%   Dateien erzeugt:
%   \begin{itemize}
%   \item \texttt{pst-optexp.pro}: die Postscript Prologdatei
%   \item \texttt{pst-optexp.sty}: die \LaTeX{} Stildatei
%   \end{itemize}
%   Speichern Sie diese Dateien in einem Verzeichnis der Teil Ihres
%   lokalen \TeX-Baums ist.
% 
%   Vergessen Sie nicht \texttt{texhash} aufzurufen um den Baum zu
%   aktualisieren. MiK\TeX{}-Benutzer müssen die Dateinamen-Datenbank
%   (FNDB) aktualisieren.
% 
%   Detailliertere Information finden Sie in der Dokumentation Ihrer
%   \LaTeX-Distribution über die Installation in den lokalen
%   \TeX{}-Baum.
% \fi
% \ifENGLISH
%   \section{Distribution and installation}
%   This package is available on
%   CTAN\fnurl{http://mirror.ctan.org/graphics/pstricks/contrib/pst-optexp} and
%   is included in \TeX Live and MiK\TeX.
% 
%   The \LPack{pst-optexp} package consists of the two main files
%   \texttt{pst-optexp.ins} and \texttt{pst-optexp.dtx} and the derived files
%   \begin{itemize}
%   \item \texttt{pst-optexp.pro}: the Postscript prolog file
%   \item \texttt{pst-optexp.sty}: the \LaTeX{} style file
%   \end{itemize}
%   Save the files in a directory which is part of your local \TeX{} tree.
% 
%   Do not forget to run \texttt{texhash} to update this tree. For MiK\TeX{}
%   users, do not forget to update the file name database (FNDB).
% 
%   For more detailed information see the documentation of your personal
%   \LaTeX{} distribution on installing packages to your local \TeX{}
%   system.
% \fi
%
% \ifGERMAN\section{Lizenz}\fi
% \ifENGLISH\section{License}\fi
% \ifGERMAN
% Es wird die Erlaubnis gewährt, dieses Dokument zu kopieren, zu verteilen
% und\slash oder zu modifizieren, unter den Bestimmungen der \LaTeX{} Project
% Public License, Version
% 1.3.\fnurl{http://mirror.ctan.org/macros/latex/base/lppl.txt}. Dieses
% Paket wird vom Autor betreut (author-maintained).
% \fi
% \ifENGLISH
% Permission is granted
% to copy, distribute and\slash or modify this software under the terms of the
% \LaTeX{} Project Public License, version
% 1.3.\fnurl{http://mirror.ctan.org/macros/latex/base/lppl.txt} This
% package is author-maintained.
% \fi
%
% \ifGERMAN
%   \section{Abwärtskompatibilität}
% \fi
% \ifENGLISH
%   \section{Backward compatibility}
% \fi 
% \ifGERMAN Version 3.0 hat erhebliche fortgeschrittenere
%   Funktionalität hinzugefügt, die es zu schwierig machte zur
%   Vorgängerversion 2.1 vollständig abwärtskompatibel zu
%   bleiben. Insbesondere war die Funktionsweise des \Lcs{drawbeam}
%   Makros grundlegend falsch konzipiert, so dass ein Wechsel zur neuen
%   Funktionalität so schnell wie möglich erfolgen musste.
%
% \begin{optionlist}
%   \optitem[new]{namingscheme}{old, new} In Version 2.x musste
%   spezielle Komponentenknoten über ihren expliziten Namen angesprochen
%   werden. Wenn Sie nur das alte Namensschema benötigen, da Sie direkt
%   auf die Knoten zugegriffen haben, so genügt es
%   \nxLkeyword{namingscheme=old} zu verwenden, die Paketoption
%   \nxLoption{compat} wird dann nicht benötigt. Seit Version 3.0 werden
%   Makros für den Zugriff auf die Komponentenknoten bereitgestellt, so
%   dass das eigentlichen Namensschema unerheblich ist.
% \end{optionlist}
% \fi
% \ifENGLISH
% Version 3.0 introduced a lot of advanced features which made it too
% difficult to maintain full backward compatibility with version
% 2.x. Especially the \Lcs{drawbeam} macro was broken by design, so that
% it was best to drop the old flaw as early as possible.
%
% \begin{optionlist}
%   \optitem[new]{namingscheme}{old, new} In version 2.x special
%   component nodes had to be accessed by their explicit name. If you
%   only need the old naming scheme, because you accessed internal nodes
%   directly, then you can only set \nxLkeyword{namingscheme=old} and do
%   not need to use the \nxLoption{compat} option. Since version 3.0
%   explicit macros are provided to access all special component nodes,
%   so that the actual naming scheme does not matter.
% \end{optionlist}
% \fi
%
% \section{Notation}\label{sec:notation}
% \ifGERMAN
% \fi
% \ifENGLISH
% Often the parameter types are self-explanatory, but in some cases a clear
% distinction is needed, e.g. between \prm{num} and
% \prm{psnum}. Table~\ref{tab:paramref} explains some commonly used names.
%
% Parts in the parameter types which are indicated by square brackets are optional.
% \fi
%
% \vspace*{\floatsep}
% \noindent\begin{minipage}{\textwidth}\centering
% \begin{tabularx}{0.9\linewidth}{>{\itshape}lX} \toprule
%   Name & \ifENGLISH description\fi\ifGERMAN Beschreibung\fi\\ \midrule
%   num & \ifENGLISH float number\fi\ifGERMAN Gleitkommazahl\fi \\ 
%   psnum & \ifENGLISH Postscript code which evaluates to a number\fi
%           \ifGERMAN Postscript-Kode der zu einer Zahl auswertet\fi\\
%   int & \ifENGLISH integer number\fi\ifGERMAN Ganzzahl\fi\\ 
%   dimen & \ifENGLISH dimension\fi\ifGERMAN Länge\fi\\
%   psstyle & \ifENGLISH custom graphics parameter configuration defined with \Lcs*{newpsstyle}\fi
%             \ifGERMAN Benutzerdefinierte Parameterkonfiguration definiert mit \Lcs*{newpsstyle}\fi\\
%   refstring & \refstringexplanation\\ \bottomrule
% \end{tabularx}
% \ifGERMAN
% \captionof{table}{Parametertypen die in den Parameterdefinitionen verwendet werden.}
% \fi
% \ifENGLISH
% \captionof{table}{Parameter types used in the parameter reference.}
% \fi
% \label{tab:paramref}
% \end{minipage}
% 
% \ifGERMAN
%   \section{Danksagung}
% \fi
% \ifENGLISH
%   \section{Acknowledgements}
% \fi
% \ifGERMAN\fi
% \ifENGLISH
% I thank all the people of the PSTricks mailinglist for the continuous
% help, especially Herbert Vo\ss. Thanks also to Christine Römer, which
% convinced my with her article in the german DTK to provide a german
% translation of the documentation. The documentation style is a mixture
% of the \opt{pst-doc} class (Herbert Vo\ss) and the \opt{ltxdockit}
% package for the \opt{biblatex} documentation (Philipp Lehman).
% \fi
%
% \ifGERMAN
% \chapter{Grundlegende Ideen}
% \fi
% \ifENGLISH
%   \chapter{Basic ideas}
% \fi\label{chap:basics}
%
% \ifGERMAN Dieses Kapitel zeigt die grundlegenden Ideen und Konzepte, die in diesem Paket
% stecken. Angefangen von elementaren Beispielen, bis hin zu größeren Aufbauten
% wird die angedachte Vorgehensweise für das Erstellen von umfassenden
% Experimentskizzen erläutert. Eine vollständige Referenz aller Macros und
% Optionen finden Sie in \prettyref{chap:generalparam}--\ref{chap:custom}.
%
% Ein Versuchsaufbau besteht aus Komponenten, die anhand ihrer Referenzknoten
% positioniert, verschoben und gedreht werden können und optional eine
% Beschriftung erhalten. Anschließen werden die Komponenten mit Lichtstrahlen
% oder Fasern verbunden.\fi
%
% \ifGERMAN\section{Die Komponenten}\fi
% \ifENGLISH\section{The components}\fi
%
% \ifGERMAN Eine Komponente wird anhand der Knoten, die bei ihrere Definition
% angegeben werden, -- den Referenzknoten --, platziert. Im folgenden Beispiel
% wird die Linse mittig auf die Verbindungslinie zwischen den Knoten
% \prm{A} und \prm{B} gesetzt: 
% \fi
%\iffalse
%<*ignore>
%\fi
\begin{LTXexample}
\begin{pspicture}[showgrid=true](0,-0.3)(3,2)
  \pnode(0,1){A}\pnode(3,1){B}
  \lens(A)(B)
\end{pspicture}
\end{LTXexample}
%\iffalse
%</ignore>
%\fi 
% \ifGERMAN
% Diese Positionierung kann anhand von unterschiedlichen Parametern, wie
% z.B. \Lkeyword{abspos} beinflusst werden (siehe dazu \prettyref{sec:rotshift}
% und \prettyref{sec:positioning}). \fi
%\iffalse
%<*ignore>
%\fi
\begin{LTXexample}[morekeywords={[21]{abspos}}]
\begin{pspicture}[showgrid=true](0,-0.3)(3,2)
  \pnode(0,1){A}\pnode(3,1){B}
  \lens[abspos=0.5](A)(B)
\end{pspicture}
\end{LTXexample}
%\iffalse
%</ignore>
%\fi 
% \ifGERMAN Die Komponenten lassen sich allgemein in zwei Kategorien
% unterteilen: Die Freistrahl-Komponenten und die faseroptischen
% Komponenten. Diese unterscheiden sich nur bezüglich ihrer
% Verbindungsmöglichkeiten (Faserverbindungen (\prettyref{sec:intro-fiber-conn})
% oder Lichtstrahlen (\prettyref{sec:intro-freeray-conn})).
% \fi
%
% \ifGERMAN\section{Beschriftungen}\fi
% \ifENGLISH\section{Labels}\fi
%
% \ifGERMAN Jede Komponente kann eine Beschriftung erhalten, die relativ zur
% Komponente platziert werden kann. 
% \fi
%\iffalse
%<*ignore>
%\fi
\begin{LTXexample}[morekeywords={[21]{labeloffset}}]
\begin{pspicture}[showgrid=true](3,2)
  \pnode(2,1){A}\pnode(3,1){B}
  \lens(A)(B){lens}
  \optbox[position=start, labeloffset=0](A)(B){box}
\end{pspicture}
\end{LTXexample}
%\iffalse
%</ignore>
%\fi 
%
% \ifGERMAN\section{Freistrahl-Verbindungen}\fi
% \ifENGLISH\section{Free-ray connections}\fi
% \label{sec:intro-freeray-conn}
%
% \ifGERMAN
% Freistrahlkomponenten können mit Lichtstrahlen verbunden werden. 
% \fi
%
% \ifGERMAN\section{Faserverbindungen}\fi
% \ifENGLISH\section{Fiber connections}\fi
% \label{sec:intro-fiber-conn}
%
% \ifGERMAN\section{Schritt-für-Schritt-Beispiele}\fi
% \ifENGLISH\section{Step-by-step examples}\fi
%
% \iffalse
%<*ignore>
% \fi
\begingroup
\catcode`\*=13
\def*{}%
\begin{LTXexample}[style=example]
\begin{pspicture}[showgrid](4,2)
  \pnode(1,1){In}\pnode(3,1){Out}
  \psdot(In)\psdot(Out)*\OFF*
  \optbox[position=start, optboxwidth=1.2, labeloffset=0](In)(Out){Laser}
  \optretplate[position=0.3](In)(Out){$\lambda/2$}
  \optplate[position=0.7](In)(Out){pol}
  \optdetector[dettype=diode](In)(Out){PD}
  \drawbeam{1}{2}{3}{4}
\end{pspicture}
\end{LTXexample}
\endgroup
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN\subsection{Galilei-Fernrohr}\fi
% \ifENGLISH\subsection{Galilean telescope}\fi
% \label{ex:galileo}
%
% \ifGERMAN 
% Im Folgenden wird ein sehr einfacher Aufbau mit einer konkaven und
% einer konvexen Linse schrittweise erläutert.
%
% Zuerst werden die Referenzknoten \prm{In} und \prm{Out} definiert, die für die Ausrichtung der
% Komponenten verwendet werden. Zur besseren Übersicht werden beide Knoten
% gekennzeichnet, desweiteren dient ein Koordinatengitter der Orientierung.
%
% Die erste Linse soll konkav gekrümmte Grenzflächen haben. Mit
% \Lkeyword{lensradius} werden die Krümmungen der rechten und linken
% Fläche auf denselben Wert gesetzt, ein negativer Wert ergibt eine
% konkave Krümmung. Die Linse wird mit \Lkeyword{abspos} eine Einheit
% vom \prm{In}-Knoten entfernt positioniert.
% \fi
% \iffalse
%<*ignore>
% \fi
\begingroup
\catcode`\*=13
\def*{}%
\begin{LTXexample}[style=example]
*\ON*\begin{pspicture}[showgrid](5,2)
  \pnode(0,1){In}\pnode(3.5,1){Out}
  \psdot(In)\psdot(Out)*\OFF*
  \lens[lensradius=-0.7,
          abspos=1](In)(Out){concave}*\ON*
\end{pspicture}*\OFF*
\end{LTXexample}
\endgroup
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% Die zweite Linse bekommt eine konvexe Krümmung (\Lkeyword{lensradius}
% ist positiv) und wird \opt{2.6} Einheiten von \prm{In}
% positioniert. Die Linsenhöhe wird mit \Lkeyword{lensheight}
% eingestellt.
% \fi
% \ifENGLISH
%
% \fi
% \iffalse
%<*ignore>
% \fi
\begingroup
\catcode`\*=13
\def*{}%
\begin{LTXexample}[style=example]
*\ON*\begin{pspicture}[showgrid](5,2)
  \pnode(0,1){In}\pnode(3.5,1){Out}
  \psdot(In)\psdot(Out)
  \lens[lensradius=-0.7, 
          abspos=1](In)(Out){concave}*\OFF*
  \lens[lensradius=2.3, lensheight=1.3, 
          abspos=2.6](In)(Out){convex}*\ON*
\end{pspicture}*\OFF*
\end{LTXexample}
\endgroup
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% Die Lichtstrahlen sollen auf einer CCD-Kamera enden, die mit einer
% \Lcs{optbox} gezeichnet wird. Mit \Lkeyword{position}\opt{=start} wird die Box an den Anfang der Referenzlinie von \prm{In} nach \prm{Out} gesetzt, die
% Beschriftung wird mit \Lkeyword{labeloffset} in die Mitte der
% Komponente gelegt.
% \fi
% \ifENGLISH
%
% \fi
% \iffalse
%<*ignore>
% \fi
\begingroup
\catcode`\*=13
\def*{}%
\begin{LTXexample}[style=example]
*\ON*\begin{pspicture}[showgrid](5,2)
  \pnode(0,1){In}\pnode(3.5,1){Out}
  \psdot(In)\psdot(Out)
  \lens[lensradius=-0.7,
          abspos=1](In)(Out){concave}
  \lens[lensradius=2.3, lensheight=1.3, 
          abspos=2.6](In)(Out){convex}*\OFF*
  \optbox[position=end, labeloffset=0](In)(Out){CCD}*\ON*
\end{pspicture}*\OFF*
\end{LTXexample}
\endgroup
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% Zum Schlu\ss{} wird ein aufgeweiteter Strahl mit einer Strahlbreite
% von \opt{0.2} und ohne anfängliche Divergenz durch die Komponenten
% geschickt. Der Strahlengang wird mittels Raytracing berechnet. Die
% Linsenparameter in diesem Beispiel wurden so gewählt das bei
% kollimiertem Eingangsstrahl auch der Ausgangsstrahl kollimiert ist.
% \fi
% \ifENGLISH
%
% \fi
% \iffalse
%<*ignore>
% \fi
\begingroup
\catcode`\*=13
\def*{}%
\begin{LTXexample}[style=example]
*\ON*\begin{pspicture}(5,2)
  \pnode(0,1){In}\pnode(3.5,1){Out}
  \lens[lensradius=-0.7, 
          abspos=1](In)(Out){concave}
  \lens[lensradius=2.3, lensheight=1.3, 
          abspos=2.6](In)(Out){convex}
  \optbox[position=end, labeloffset=0](In)(Out){CCD}*\OFF*
  \drawwidebeam[beamwidth=0.2]{(In)}{1}{2}{3}*\ON*
\end{pspicture}*\OFF*
\end{LTXexample}
\endgroup
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% Das Aussehen des Lichtstrahls wird über den \Lstyle{Beam}-Stil
% eingestellt, und kann z.B. mit einer halbtransparenten Füllung
% versehen werden.
% \fi
% \ifENGLISH
%
% \fi
% \iffalse
%<*ignore>
% \fi
\begingroup
\catcode`\*=13
\def*{}%
\begin{LTXexample}[style=example]
*\ON*\begin{pspicture}(5,2)
  \pnode(0,1){In}\pnode(3.5,1){Out}
  \lens[lensradius=-0.7, 
          abspos=1](In)(Out){concave}
  \lens[lensradius=2.3, lensheight=1.3, 
          abspos=2.6](In)(Out){convex}
  \optbox[position=end, labeloffset=0](In)(Out){CCD}*\OFF*
  \addtopsstyle{Beam}{fillstyle=solid, 
    fillcolor=green, opacity=0.2}
  *\ON*\drawwidebeam[beamwidth=0.2]{(In)}{1}{2}{3}
\end{pspicture}*\OFF*
\end{LTXexample}
\endgroup
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN\subsection{Faseraufbau}\fi
% \ifENGLISH\subsection{Fiber setup}\fi
% \label{ex:fiber-setup}
%
% \ifGERMAN
% Dieses Beispiel zeigt, wie ein faseroptischer Aufbau mit automatisch
% gezeichneten Faserverbindungen konstruiert werden kann.
%
% Auch hier werden die Referenzknoten zur besseren Orientierung
% eingezeichnet. Im Gegensatz zum vorhergehenden Beispiel benötigen wir
% mehr Referenzknoten, da die Faserkomponenten direkt mit diesen
% verbunden werden.
%
% Der Laser wird wieder an den Anfang gesetzt. Der Abstand
% der Beschriftung wird mit dem Parameter \Lkeyword{label} eingestellt,
% mit dem alle Beschriftungsparameter gesammelt eingestellt werden
% können. Da eine \Lcs{optbox} sowohl als Freistrahl- als auch als
% Faserkomponente verwendet werden kann, wird in der Standardeinstellung
% keine Faser gezeichnet, was mit \Lkeyword{fiber} geändert werden
% kann. Die Breite dieser und aller folgenden \Lcs{optbox} wird auf
% \opt{0.7} geändert.
% \fi
% \ifENGLISH
% 
% \fi
% \iffalse
%<*ignore>
% \fi
% \begingroup
% \catcode`\*=13
% \def*{}%
\begin{LTXexample}[style=example]
*\ON*\begin{pspicture}[showgrid=true](4.7,2)
  \pnode(0.7,1){A}\pnode(1,1){B}\psdot(A)\psdot(B)
  \pnode(2.8,1){C}\pnode(4,1.5){D}\psdot(C)\psdot(D)
  \pnode(4,0.5){E}\psdot(E)*\OFF*
  \psset{optboxwidth=0.7, labelstyle=\scriptsize}
  \optbox[position=start, label=0, fiber](A)(B){LD}*\ON*
\end{pspicture}*\OFF*
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% Als nächstes wird ein Mach-Zehnder-Modulator ohne Beschriftung
% gezeichnet, der automatisch mit Fasern verbunden wird.
% \fi
% \ifENGLISH
% 
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[style=example]
*\ON*\begin{pspicture}[showgrid=true](4.7,2)
  \pnode(0.7,1){A}\pnode(1,1){B}\psdot(A)\psdot(B)
  \pnode(2.8,1){C}\pnode(4,1.5){D}\psdot(C)\psdot(D)
  \pnode(4,0.5){E}\psdot(E)
  \psset{optboxwidth=0.7, labelstyle=\scriptsize}
  \optbox[position=start, label=0, fiber](A)(B){LD}*\OFF*
  \optmzm(B)(C)*\ON*
\end{pspicture}*\OFF*
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% Danach wird ein optischer Koppler mit einem Eingang und zwei Ausgängen
% gezeichnet. Der Koppler wird zwischen dem Eingangsknoten und dem
% Mittelpunkt der beiden Ausgangsknoten ausgerichtet. 
% \fi
% \ifENGLISH
%
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[style=example]
*\ON*\begin{pspicture}[showgrid=true](4.7,2)
  \pnode(0.7,1){A}\pnode(1,1){B}\psdot(A)\psdot(B)
  \pnode(2.8,1){C}\pnode(4,1.5){D}\psdot(C)\psdot(D)
  \pnode(4,0.5){E}\psdot(E)
  \psset{optboxwidth=0.7, labelstyle=\scriptsize}
  \optbox[position=start, label=0, fiber](A)(B){LD}
  \optmzm(B)(C)*\OFF*
  \wdmsplitter(C)(D)(E){50\%}%*\ON*
\end{pspicture}%*\OFF*
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \ifGERMAN 
% An die Enden des Kopplers wird ein optischer Spektrumanalysator (OSA)
% und eine Leistungsmessgerät (PD) gesetzt. Der \Lcs{optdetector} wird
% immer ans Ende der Referenzlinie gesetzt wie mit \Lkeyword{position}\opt{=end}. Diese beiden Komponenten werden ohne weitere Einstellungen
% ohne Faserverbindungen gezeichnet. Das passt, da ihr Endpunkt mit den
% Ausgängen des Kopplers zusammenfallen.
%
% Die Schreibweise \opt{(A|E)} nimmt die $x$-Koordinate von \prm{A} und
% die $y$-Koordinate von \prm{E}.
% \fi
% \ifENGLISH
%
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[style=example, caption={caption}]
*\ON*\begin{pspicture}[showgrid](4.7,2)
  \pnode(0.7,1){A}\pnode(1,1){B}\psdot(A)\psdot(B)
  \pnode(2.8,1){C}\pnode(4,1.5){D}\psdot(C)\psdot(D)
  \pnode(4,0.5){E}\psdot(E)
  \psset{optboxwidth=0.7, labelstyle=\scriptsize}
  \optbox[position=start, label=0, fiber](A)(B){LD}
  \optmzm(B)(C)
  \wdmsplitter[abspos=0.3, label=0.4](C)(D)(E){50\%}*\OFF*
  \optbox[position=end, label=0](A|D)(D){OSA}
  \optdetector(A|E)(E){PD}*\ON*
\end{pspicture}*\OFF*
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN\subsection{Faseraufbau (Alternative)}\fi
% \ifENGLISH\subsection{Fiber setup (alternative)}\fi
% \label{ex:fiber-setup-alt}
%
% \ifGERMAN
% Dieses Beispiel ist vom Ergebnis her identisch mit dem
% vorangegangenen, wird aber anders angegangen.
%
% Hier verwenden wir nicht die automatischen Faserverbindungen, sondern
% zeichnen, wie bei Freistrahlaufbauten, zuerst die Komponenten, die zum
% Schlu\ss{} mit Fasern verbunden werden. Daher benötigen wir weniger
% Referenzknoten, die Faserverbindungen werden mit \Lkeyword{fiber}
% global unterdrückt.
%
% Die Fasern werden als letztes mit \Lcs{drawfiber} verbunden. Das
% Ergebnis ist identisch mit Bsp.~\ref{ex:fiber-setup}. Welche
% Herangehensweise verwendet wird ist meistens Geschmackssache, bei
% Ringstrukturen wie z.B. Faserlasern kann das nachträgliche Verbinden
% mit \Lcs{drawfiber} von Vorteil sein.
% \fi 
% \ifENGLISH
%
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[caption={caption}]
\begin{pspicture}[showgrid](4.9,2)
  \pnode(0.7,1){A}\pnode(4,1){B}\psdot(A)\psdot(B)
  \psset{optboxwidth=0.7, labelstyle=\scriptsize,
    fiber=none}
  \optbox[position=start, labeloffset=0](A)(B){LD}
  \optmzm[abspos=1.1](A)(B)
  \wdmsplitter[abspos=2.25, label=0.4](A)(B)(B){50\%}
  \optbox[position=end,label=0, compshift=0.5](A)(B){OSA}
  \optdetector[compshift=-0.5](A)(B){PD}
  \drawfiber{1}{2}{3}{4}\drawfiber{3}{5}
\end{pspicture}
\end{LTXexample}
% \endgroup
% \iffalse
%</ignore>
% \fi 
% 
% \newpage
% \subsection{Michelson-Interferometer}
% \label{ex:michelson}
%
% \ifGERMAN
% In diesem Beispiel werden neben Linsen auch reflektierende Elemente
% (Spiegel) sowie Elemente eingesetzt, die sowohl transmittieren als
% auch reflektieren (Strahlteiler).
% \fi
%
% \begingroup
% \catcode`\*=13
% \def*{}%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[style=example, hsep=8mm, numbers=left, numberstyle=\footnotesize, caption={caption}]
\begin{pspicture}(3.2,5)
  \pnode(0,3){In}\pnode(1,3){BS}\pnode(3,3){M1}*\label{l:ex2-nodes1}*
  \pnode(1,5){M2}\pnode(1,1){PD}*\label{l:ex2-nodes2}*
  \psset{mirrortype=extended, mirrordepth=0.2}*\label{l:ex2-set}*
  \begin{optexp}*\label{l:ex2-begin}*
    \beamsplitter[bsstyle=plate, compname=BS](In)(BS)(PD)*\label{l:ex2-bs}*
    \mirror[compname=M1](BS)(M1)(BS)*\label{l:ex2-m1}*
    \mirror[compname=M2, variable](BS)(M2)(BS)*\label{l:ex2-m2}*
    \lens[compname=L](BS)(PD)*\label{l:ex2-l}*
    \optdetector[compname=Det, dettype=diode](BS)(PD)*\label{l:ex2-det}*
    \addtopsstyle{Beam}{beamwidth=0.2, fillstyle=solid, fillcolor=green!20!white}*\label{l:ex2-style}*
    \drawwidebeam{(In)}{BS}{M1}{BS}{M2}{BS}{L}{Det}*\label{l:ex2-beam}*
  \end{optexp}
\end{pspicture}
\end{LTXexample}
% \endgroup
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% Wir beginnen wieder, indem wir die Referenzknoten definieren
% (\prettyref{l:ex2-nodes1}--\ref{l:ex2-nodes2}). Nun werden ein paar
% grundlegende Einstellungen gesetzt (\prettyref{l:ex2-set}): das
% Aussehen der Spiegel, des Strahlteilers und des Detektors.
%
% Dann werden der Reihe nach alle Komponenten platziert
% (\prettyref{l:ex2-bs}--\ref{l:ex2-det}), die reflektierenden benötigen
% drei Referenzknoten, den Eingangsknoten, den Knoten an dem die
% reflektierende Grenzfläche ist und den Ausgangsknoten. Anschließend
% wird noch das Aussehen des Lichtstrahls festgelegt
% (\prettyref{l:ex2-style}) und der Strahl gezeichnet
% (\prettyref{l:ex2-beam}).
%
% Diese Mal haben wir den Komponenten Namen gegeben
% (\Lkeyword{compname}) die beim Raytracing anstatt der automatisch
% vergebenen Nummern verwendet werden können. Dies erleichtert die
% Nachverfolgung des Strahlengangs.
% 
% Alle Komponenten und Strahlen wurden zusätzlich in eine
% \Lenv{optexp}-Umgebung gekapselt. Innerhalb dieser werden alle
% Lichtstrahlen hinter die Komponenten gelegt, sodass diese nicht
% verdeckt werden.
% \fi
% \ifENGLISH\fi
%
% \newpage
% \ifGERMAN\subsection{Gitterreflexion}\fi
% \ifENGLISH\subsection{Grating diffraction}\fi
% \label{ex:grating-diff}
%
% \iffalse
%<*ignore>
% \fi
% \begingroup
% \catcode`\*=13
% \def*{}%
\begin{LTXexample}[style=example, numbers=left, numberstyle=\footnotesize, caption={caption}]
\begin{pspicture}(0.5,0)(2.2,4)
  \pnode(0,1){In}\pnode(1,1){BS}\pnode(2,1){G}\pnode(1,4){Out}
  \beamsplitter[compname=Bs](G)(BS)(Out)
  \optgrating[compname=G](BS)(G)(BS)
  \lens[lens=2 2 1.5, compshift=0.1, n=2.25, compname=L](BS)(Out)
  \pinhole[phwidth=0.05, innerheight=0.05, position=0.8, compshift=0.18, compname=Ph](BS)(Out)
  \optplane[compname=Out, angle=90](Out)
  \addtopsstyle{Beam}{linestyle=none, beamwidth=0.2, fillstyle=solid}
  \drawwidebeam[fillcolor=red!25!white]{(In)}{Bs}{G}{Bs}{L}{Ph}{Out}
  \drawwidebeam[fillcolor=red!50!white, beamangle=-5]{G}{Bs}{L}{Ph}{Out}
\end{pspicture}
\end{LTXexample}
% \endgroup
% \iffalse
%</ignore>
% \fi
%
%
% \ifGERMAN\chapter{Allgemeine Komponentenparameter}\fi
% \ifENGLISH\chapter{General component parameters}\fi
% \label{chap:generalparam}
% 
% \ifGERMAN Dieses Kapitel enthält alle Informationen zu allgemeinen Parametern
% und Konzepten. Das beinhaltet das Setzen von Beschriftungen, Positionierung,
% Drehen und Verschieben von Komponenten und Anpassen der Aussehens.
% \fi
% \ifENGLISH This chapter introduces generic parameters and concepts such as
% labels, positioning, rotating and shifting of components and changing the
% appearance of components.
% \fi
%
% \ifGERMAN\section{Beschriftungen}\fi
% \ifENGLISH\section{Labels}\fi
% \label{sec:labels}
%
% \ifGERMAN Alle Komponenten können mit einer Beschriftung versehen
% werden, deren Position und Ausrichtung genau angepasst werden
% kann. Die Beschriftung ist für jede Komponente optional.
% \fi
% \ifENGLISH All components may have a label which position and alignment can
% be adjusted at will. The label is optional for every component.
% \fi 
%
% \begin{optionlist}
% \numitem[0.8]{labeloffset}
% \ifGERMAN Der Abstand des Referenzknotens für die Beschriftung zum
% Zentrum der Komponente.\fi
% \ifENGLISH The offset of the label reference node from the component
% center.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-2,6-6}, morekeywords={[21]{labeloffset}}]
\begin{pspicture}(3,1.8)
  \optbox[beam, labeloffset=1](0,1.5)(3,0.8){label}
  \psdot[linecolor=blue](\oenodeCenter{})
  \psdot[linecolor=red](\oenodeLabel{})
  \ncline[arrows=<->, arrowinset=0, arrowscale=1.5]{\oenodeCenter{}}{\oenodeLabel{}}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \valitem[\nxLcs{small}]{labelstyle}{macros}
% \ifGERMAN Der Schriftstil der Beschriftungen.\fi
% \ifENGLISH The textstyle that is used to typeset the label.\fi
% 
% \valitem[c]{labelalign}{refstring}
% \ifGERMAN Definiert die Ausrichtung der Beschriftung bezüglich des vorgesehenen Referenzknotens.\fi
% \ifENGLISH Defines the alignment of the label relative to the reference node.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-3,6-6}, morekeywords={[21]{labeloffset, labelalign}}]
\begin{pspicture}(3,1.8)
  \psset{beam, labeloffset=1}
  \optbox[labelalign=bl](0,1.5)(3,0.8){label}
  \psdot[linecolor=blue](\oenodeCenter{})
  \psdot[linecolor=red](\oenodeLabel{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \numitem[0]{labelangle}
% \ifGERMAN
% Der Rotationswinkel des Referenzknotens um das Zentrum. Der Nullpunkt
% hängt sowohl von dem jeweiligen Komponententypen und dem
% Referenzsystem ab (siehe \nxLkeyword{labelref}).
% \fi
% \ifENGLISH
% The rotation angle of the reference node around the component
% center. The origin depends both on the component type and the
% reference system (see \nxLkeyword{labelref}).
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-2,4-6,27-27}, morekeywords={[21]{labelangle}}]
\begin{pspicture}(-0.3,0)(2,3.7)
  \psset{labeloffset=1, optboxwidth=1, arrowscale=1.5, arrowinset=0}
  \begin{optexp}
  \optbox[position=end, labelangle=90](1,1)(1,2){Box}
  \beamsplitter[labelangle=-90](1,2)(1,1)(2,1){BS}
  \drawbeam[arrows=->]{1}{2}{(2,1)}
  \frontlayer{%
    \psdot[linecolor=blue](\oenodeCenter{1})
    \psdot[linecolor=blue](\oenodeCenter{2})
    \psdot[linecolor=red](\oenodeLabel{1})
    \psdot[linecolor=red](\oenodeLabel{2})
  }
  \backlayer{%
    \bgroup
    \psset{style=Refline}
    \psline(\oenodeCenter{2})([offset=-1]\oenodeCenter{2})
    \psline(\oenodeCenter{2})([Xnodesep=-1]\oenodeCenter{2})
    \psarc[arrows=<-](\oenodeCenter{2}){0.7}{180}{270}
    \uput{0.9}[-135](\oenodeCenter{2}){\small $-90$\textdegree}
    \psline(\oenodeCenter{1})([Xnodesep=1]\oenodeCenter{1})
    \psline(\oenodeCenter{1})([offset=1]\oenodeCenter{1})
    \psarc[arrows=->](\oenodeCenter{1}){0.7}{0}{90}
    \uput{0.9}[45](\oenodeCenter{1}){\small $90$\textdegree}
    \egroup
  }
  \end{optexp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[relgrav]{labelref}{relative, relgrav, global}
% \ifGERMAN
% Wählt das Bezugssystem für \nxLkeyword{labelangle} und die Orientierung der
% Beschriftung. Das genaue Verhalten kann am besten mit den drei folgenden
% Beispielen erläutert werden.
% \fi
% \ifENGLISH
% Set the reference coordinate system for the \nxLkeyword{labelangle} and the
% orientation of the label text. The detailed behaviour is best illustrated
% looking at the following three examples.
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{label}}]
\begin{pspicture}(-2,-2)(2,2)
  \psset{position=end, optboxsize=1 0.6, innerlabel}
  \multido{\i=0+45}{8}{%
    \optbox(0,0)(1;\i){\i}
  }
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}[morekeywords={[21]{labelref}}]
\begin{pspicture}(-2,-2)(2,2)
  \psset{position=end, optboxsize=1 0.6, labelref=relgrav}
  \multido{\i=0+72}{5}{%
    \optbox(0,0)(1;\i){\i}
  }
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}[morekeywords={[21]{labelref}}]
\begin{pspicture}(-2,-2)(2,2)
  \psset{position=end, optboxsize=1 0.6, labelref=global}
  \multido{\i=0+72}{5}{%
    \optbox(0,0)(1;\i){\i}
  }
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \optitem{label}{\prm{offset}[ \prm{angle}[ \prm{ref string}[ \prm{labelref}]]]}
% \ifGERMAN
% Diese Option erlaubt die kompakte Definition mehrerer
% Beschriftungsparameter. Es können bis zu vier Leerzeichen-getrennte
% Argumente übergeben werden (\nxLkeyword{labeloffset},
% \nxLkeyword{labelangle}, \nxLkeyword{labelalign} und
% \nxLkeyword{labelref}). Mit einem Punkt kann eine Option übersprungen
% werden.
% \fi
% \ifENGLISH
% Allows compact definition of several label parameters. It takes up to
% four space-separated arguments (\nxLkeyword{labeloffset},
% \nxLkeyword{labelangle}, \nxLkeyword{labelalign}, and
% \nxLkeyword{labelref}). Unchanged intermediate arguments can be
% skipped with a dot.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{label}}]
\begin{pspicture}(0,0)(4,3)
  \psset{endbox, beam}
  \optbox[label=0.7](1.5,2.5)(2.5,2.5){box}
  \optbox[label=1 -45](1.5,1)(2.5,1){$-45$}
  \optbox[label=0 . . relative]%
         (0.6,0.6)(0.6,1.6){relative}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \choitem{innerlabel}{true}
% \ifGERMAN Das ist ein Alias für \opt{label=0 . . relative}\fi
% \ifENGLISH This is an alias for \opt{label=0 . . relative}\fi
% \end{optionlist}
%
%
%
% \ifGERMAN\section{Positionierung}\fi
% \ifENGLISH\section{Positioning}\fi
% \label{sec:positioning}
%
% \ifGERMAN
% Alle Komponenten außer den Freistrahl-Dreipolen können zwischen ihren
% beiden Referenzknoten (\Lcs{oenodeRefA} und \Lcs{oenodeRefB})
% positioniert werden.
% \fi
% \ifENGLISH
% All components but the tripoles can be positioned between their two
% reference nodes (\Lcs{oenodeRefA} and \Lcs{oenodeRefB}).
% \fi
% \begin{optionlist}
%   \choitem{position}{\prm{num},start,end}
%   \ifGERMAN 
%   Falls der Wert eine Zahl ist, wird damit die relative Position der Mitte
%   eines Objektes bezüglich seiner beiden Referenzknoten gesetzt. Das ist
%   äquivalent zum \Lkeyword*{npos} Parameter von \Lcs*{ncput}, d.h. eine Zahl
%   im Intervall $[0,1]$ (siehe \LPack{pst-node} Dokumentation).
%   \fi
%   \ifENGLISH
%   Controls the relative position of an object center between its two reference
%   points, if the value is a number. In this case it is equivalent to the
%   \Lkeyword*{npos} parameter of \Lcs*{ncput}, i.e. a number in the range
%   $[0,1]$ (see \LPack{pst-node} documentation).
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{position}}]
\begin{pspicture}(3,1.5) 
  \lens[beam, position=0.8](0,1)(3,1){L}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN 
% Der Wert \opt{start} setzt ein Objekt an den Anfang, \opt{end} ans Ende der
% Referenzlinie, so dass die entsprechende Grenzfläche auf dem Referenzknoten
% liegt, und nicht die Mitte des Objektes, wie es mit \opt{position=1}
% bzw. \opt{position=0} der Fall wäre. Unter Verwendung von Zahlen wäre dieses
% Verhalten deutlich schwieriger und weniger flexibel zu erreichen, da die Größe
% und Form des Objektes berücksichtigt werden muss.
% \fi
% \ifENGLISH
% The values \opt{start} and \opt{end} place an object at the start or end of
% the reference line, respectively. The respective object interface is placed on
% the respective reference node instead of the object center which would be the
% case for \opt{position=0} or \opt{position=1}. Achieving this with numerical
% values would me more difficult and unflexible, because the object size and
% shape must be taken into account.
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{endbox}}]
\begin{pspicture}(3,2)
  \pnode(1.5,1){A}\pnode(2.5,1){B}\psdot(A)\psdot(B)
  \optbox[position=start](A)(B)
  \lens[position=end](A)(B)
  \psline[style=Refline](A)(B)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem{abspos}{\prm{num},start,end}
% \ifGERMAN
% Eine Zahl setzt die absolute Position eines Objektes auf der
% Referenzlinie. Die Werte \opt{start} und \opt{end} werden identisch wie bei
% \Lkeyword{position} behandelt.
% \fi
% \ifENGLISH
% Controls the absolute position of an object on the reference line. The values
% \opt{start} and \opt{end} are handled identically to \Lkeyword{position}.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{abspos}}]
\begin{pspicture}(3,1.5) 
  \lens[beam, abspos=1](0,1)(3,1){L}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
%
%
% \ifGERMAN\section{Drehen und Verschieben}\fi
% \ifENGLISH\section{Rotating and shifting}\fi
% \label{sec:rotshift}
%
% \ifGERMAN
% Alle Komponenten können versetzt und um verschiedene Bezugspunkte
% gedreht werden. Beachten Sie, dass mit den Komponenten auch die
% Grenzflächenknoten transformiert werden. Die transformierten
% Referenzknoten sind als eigene Knoten verfügbar (siehe
% \prettyref{sec:refnode}).
% \fi
% \ifENGLISH
% All components can be shifted and rotated around different reference
% nodes. Please note, that together with the components also their
% interface nodes are transformed. The transformed reference nodes are
% accessible as new nodes (see \prettyref{sec:refnode}).
% \fi
% 
% \begin{optionlist}
% \numitem[0]{angle}
% \ifGERMAN
% Dreht eine Komponente um den Winkel \prm{num} (in Grad).
% \fi
% \ifENGLISH
% Rotate a component by an angle \prm{num} (in degree).
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-2,4-4,8-8}, morekeywords={[21]{angle}}]
\begin{pspicture}(3,2)
  \pnode(0,1){A}\pnode(2.7,1){B}
  \optbox[addtoOptComp={style=Refline, linestyle=dashed}](A)(B)
  \optbox[angle=20, innerlabel](A)(B){box}
  \psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
  \psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
  \psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
\end{pspicture}
\end{LTXexample}
%\iffalse
%</ignore>
%\fi
%
% \valitem[c]{rotateref}{refstring}
% \ifGERMAN
% Setzt den Bezugspunkt für die Drehung der Komponente. Bitte lesen Sie
% \prettyref{sec:rotrefnode} für eine genauere Beschreibung und entnehmen Sie
% \prettyref{sec:overview-extnode} die möglichen Bezugspunkte für alle
% Komponenten.
% \fi
% \ifENGLISH
% Set the reference point for the rotation of the component. Please see
% \prettyref{sec:rotrefnode} for a detailed explanation and
% \prettyref{sec:overview-extnode} for a list of the possible reference nodes of
% all components.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-2,4-4,8-8}, morekeywords={[21]{angle,rotateref}}]
\begin{pspicture}(3,2)
  \pnode(0,1){A}\pnode(2.7,1){B}
  \optbox[addtoOptComp={style=Refline, linestyle=dashed}](A)(B)
  \optbox[angle=20, rotateref=bl, innerlabel](A)(B){box}
  \psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
  \psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
  \psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
\end{pspicture}
\end{LTXexample}
%\iffalse
%</ignore>
%\fi
%
% \numitem[0]{compshift} Shift a component perpendicular to its
% reference line (see \prettyref{sec:refnode}). For reflective
% components it is shifted along the reflective interface.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-3,7-7}, morekeywords={[21]{compshift}}]
\begin{pspicture}(3,2)
  \pnode(0,1){A}\pnode(2.7,1){B}
  \lens[compshift=0.3](A)(B){L}
  \psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
  \psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
  \psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
\end{pspicture}
\end{LTXexample}
\begin{LTXexample}[linerange={1-3,7-7}, morekeywords={[21]{compshift}}]
\begin{pspicture}(3,2) 
  \pnode(0,1){A}\pnode(2,0){B}
  \mirror[compshift=0.3](A)(2,1)(B){mirror}
  \psline[style=Refline](\oenodeRefA{})(\oenodeRefB{}|\oenodeRefA{})(\oenodeRefB{})
  \psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
  \psdot(\oenodeRefB{})\uput[180](\oenodeRefB{}){RefB}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
%
% \ifGERMAN\section{Verwendung von Stilen}\fi
% \ifENGLISH\section{Using psstyles}\fi\label{sec:styles}
%
% \ifGERMAN
% Stile sind benutzerdefinierte Grafik-Konfigurationen für
% PSTricks-Objekte. Das \LPack{pst-optexp}-Paket macht umfangreichen
% Gebrauch von Stilen um einzelne, logische Bereiche von Komponenten
% flexibel gestalten zu können, was über das optionale Argument meistens
% nicht möglich ist. 
%
% Vorhandene Stile können mit \Lcs*{addtopsstyle} erweitert und mit
% \Lcs*{newpsstyle} überschrieben werden.
%
% Als Beispiel nehmen wir einen \opt{extended} Spiegel und möchten nur
% den «extended»-Teil verändern. Hierfür wird der Stil
% \Lstyle{ExtendedMirror} bereitgestellt:
% \fi
% \ifENGLISH
% Psstyles are custom graphics parameter configurations for PSTricks
% objects. The \LPack{pst-optexp} package makes extensive use of styles
% to facilitate flexible design of single, logical parts of
% components. This is in general not possible with the optional
% argument.
%
% Existing styles can be extended with \Lcs*{addtopsstyle} and
% overwritten with \Lcs*{newpsstyle}.
%
% As example we consider an \opt{extended} mirror and want to change
% only the «extended» part which is controlable with the
% \Lstyle{ExtendedMirror} style:
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \addtopsstyle{ExtendedMirror}{hatchcolor=red}
  \mirror[mirrortype=extended, beam](0,0)(2,1.5)(0,2)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \ifGERMAN 
% Die veränderbaren Unterbereiche einer Komponente sind in der
% jeweiligen Referenz zu finden.
% \fi
% \ifENGLISH 
% The changeable parts of each component are listed in the respective
% reference.
% \fi
%
%
%
% \ifGERMAN\section{Aussehen der Komponenten}\fi
% \ifENGLISH\section{Component appearance}\fi
% \label{sec:appearance}
%
% \begin{stylelist}
% \styleitem{OptComp} 
% \ifGERMAN
% Bestimmt das grundlegende Aussehen aller optischen Komponenten. Die
% üblichen Parameter, wie z.B. \opt{linestyle}, würden auch die
% Verbindungen beeinflussen, die mit der Komponente zusammen gezeichnet
% werden (\Lkeyword{beam}, \Lkeyword{fiber} usw.). Mit
% \Lkeyword{newOptComp} und \Lkeyword{addtoOptComp} kann der Stil für
% einzelne Komponenten oder zusammen mit \Lcs*{newpsobject} im optionalen
% Argument verwendet werden.
% \fi
% \ifENGLISH
% Affects the basic appearence of all optical components. Using standard
% graphics parameters like e.g. \opt{linestyle} would change also the
% connections that are drawn together with the component
% (\Lkeyword{beam}, \Lkeyword{fiber} etc.). Use the key
% \Lkeyword{newOptComp} and \Lkeyword{addtoOptComp} to change the style
% for single components or for use with \Lcs*{newpsobject} via the
% optional argument.
% \fi
% \iffalse
%<*ignore>
% \fi
\ifGERMAN
\begin{LTXexample}[morekeywords={[21]{addtoOptComp}}]
\begin{pspicture}(2.5,4)
  \psset{beam}
  % falsch, die Strahlbreite wird auch geändert
  \mirror[linewidth=3\pslinewidth](0,3)(2,3)(2,2)
  % korrektes Ergebnis
  \addtopsstyle{OptComp}{linewidth=3\pslinewidth}
  \mirror(0,1)(2,1)(2,0)
\end{pspicture}
\end{LTXexample}
\fi\ifENGLISH
\begin{LTXexample}[morekeywords={[21]{addtoOptComp}}]
\begin{pspicture}(2.5,4)
  \psset{beam}
  % wrong, also beam width is changed
  \mirror[linewidth=3\pslinewidth](0,3)(2,3)(2,2)
  % correct result
  \addtopsstyle{OptComp}{linewidth=3\pslinewidth}
  \mirror(0,1)(2,1)(2,0)
\end{pspicture}
\end{LTXexample}
\fi
% \iffalse
%</ignore>
% \fi
%
% \styleitem{OptionalStyle} 
% \ifGERMAN
% Der Stil wird zusätzlich zu \nxLkeyword{OptComp} auf Komponenten angewendet,
% die als \nxLkeyword{optional} markiert sind.
% \fi
% \ifENGLISH
% This style is applied in addition to \nxLkeyword{OptComp} to components marked
% as \nxLkeyword{optional}.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{optional}}]
\begin{pspicture}(3,1.5)
\lens[optional, beam](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \ifGERMAN
% \nxLkeyword{OptionalStyle} wird nach \nxLkeyword{OptComp} angewendet, so dass
% einzelne Einstellungen überschrieben werden können.
% \fi
% \ifENGLISH
% \nxLkeyword{OptionalStyle} is applied after \nxLkeyword{OptComp} so that it
% can overwrite the general settings.
% \fi
%
% \iffalse
%<*ignore>
% \fi
\ifGERMAN
\begin{LTXexample}[morekeywords={[21]{OptComp, OptionalStyle, optional}}]
\begin{pspicture}(3,1.5)
\addtopsstyle{OptComp}{linewidth=3\pslinewidth, linecolor=red}
\newpsstyle{OptionalStyle}{linecolor=blue}
\lens(0,1)(2,1)
% Liniefarbe wird überschrieben, die Linienbreite nicht.
\lens[optional](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
\fi\ifENGLISH
\begin{LTXexample}[morekeywords={[21]{OptComp, OptionalStyle, optional}}]
\begin{pspicture}(3,1.5)
\addtopsstyle{OptComp}{linewidth=3\pslinewidth, linecolor=red}
\newpsstyle{OptionalStyle}{linecolor=blue}
\lens(0,1)(2,1)
% linecolor overwritten, linewidth kept
\lens[optional](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
\fi
% \iffalse
%</ignore>
% \fi
%
% \end{stylelist}
%
% \begin{optionlist}
% \valitem{addtoOptComp}{list} 
% \addtostylemsg{OptComp}
%
% \valitem{newOptComp}{list}
% \newstylemsg{OptComp}
%
% \iffalse
%<*ignore>
% \fi
\ifGERMAN
\begin{LTXexample}[morekeywords={[21]{addtoOptComp,newOptComp}}]
\begin{pspicture}(3,1.5)
  \psset{beam}
  \newpsstyle{OptComp}{linewidth=3\pslinewidth}
  \mirror[addtoOptComp={linestyle=dotted}](0.5,0)(0.5,1)(1.5,1)
  % Überschreibt linewidth-Einstellungen
  \mirror[newOptComp={linestyle=dotted}](1.5,1)(2.5,1)(2.5,0)
\end{pspicture}
\end{LTXexample}
\fi\ifENGLISH
\begin{LTXexample}[morekeywords={[21]{addtoOptComp,newOptComp}}]
\begin{pspicture}(3,1.5)
  \psset{beam}
  \newpsstyle{OptComp}{linewidth=3\pslinewidth}
  \mirror[addtoOptComp={linestyle=dotted}](0.5,0)(0.5,1)(1.5,1)
  % overwrites the linewidth settings
  \mirror[newOptComp={linestyle=dotted}](1.5,1)(2.5,1)(2.5,0)
\end{pspicture}
\end{LTXexample}
\fi
% \iffalse
%</ignore>
% \fi
%
% \boolitem[false]{optional}
% \ifGERMAN
% Markiert eine Komponente als optional indem der Stil
% \nxLkeyword{OptionalStyle} angewendet wird.
% \fi
% \ifENGLISH
% Mark an object as optional by applying the \Lstyle{OptionalStyle} style.
% \fi
% \end{optionlist}
% 
% \ifGERMAN\chapter{Freistrahl-Komponenten}\fi
% \ifENGLISH\chapter{Free-ray components}\fi
% \label{chap:freeraycomp}
%
% \ifGERMAN \fi
% \ifENGLISH This chapter describes all free-ray components and their
% options. Free-ray components differ from fiber-components in that they provide
% transmittive or reflective interfaces which can be used to raytrace
% beams. They are divided in two types: components like lenses need only two
% nodes for positioning, whereas e.g. mirrors required three nodes to determine
% the orientation.
% \fi
%
% \ifGERMAN\section{Linse}\fi
% \ifENGLISH\section{Lens}\fi
% \label{sec:lens}
%
% \begin{ltxsyntax}
% \dipoledesc{lens}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \lens[beam](0,1)(3,1){L}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[1]{lensheight} 
% \ifGERMAN Setzt die Höhe der Linse.\fi
% \ifENGLISH Set the height of the lens.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{lensheight}}]
\begin{pspicture}(3,1.5)
  \lens[beam](0,1)(3,1){L1}
  \lens[lensheight=0.5](2,1)(3,1){L2}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \numitem[1]{lensradiusleft} 
% \ifGERMAN
% Setzt den Radius der linken Linsengrenzfläche. Ein positiver Wert \prm{num}
% ist für eine konvexe, ein negativer für eine konkave Krümmung. Null ergibt
% eine ebene Fläche.
% \fi
% \ifENGLISH
% Set the left radius of the lens. A positive \prm{num} is for convex, a
% negative one for concave curvatures. Use zero for a plain surface.
% \fi
% 
% \numitem[1]{lensradiusright} 
% \ifGERMAN
% Dasgleiche wie \Lkeyword{lensradiusleft}, nur für die rechte Grenzfläche.
% \fi
% \ifENGLISH
% Same as \Lkeyword{lensradiusleft} but for the right surface.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{lensradiusleft, lensradiusright}}]
\begin{pspicture}(3,1.5)
  \psset{lensradiusright=0, beam}
  \lens[lensradiusleft=1](0,1)(1.5,1){$R > 0$}
  \lens[lensradiusleft=-1](1.5,1)(3,1){$R < 0$}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \optitem{lensradius}{\prm{left} \prm{right}}
% \ifGERMAN
% Setzt die linke und rechte Linsenkrümmung. Wird nur ein Wert angegeben, so
% wird dieser für beide Krümmungen verwendet.
% \fi
% \ifENGLISH
% Set the left and right lens curvatures. If only a single value is given, it is
% used for both curvatures.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{lensradius}}]
\begin{pspicture}(3,1.5)
  \lens[lensradius=-2, beam](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \numitem[0]{lenswidth}
% \ifGERMAN
% Üblicherweise werden nur die Höhe und die beiden Radien für die
% Konstruktion der Linse verwendet, die Mittenbreite wird automatisch
% berechnet. Wenn \nxLkeyword{lenswidth} auf einen Wert größer Null gesetzt wird,
% wird diese Breite verwendet. Das ist nur sinnvoll, wenn dicke Linsen
% gezeichnet werden sollen, da es andernfalls für zu kleine Werte zu unschönen
% Ergebnissen führt.
% \fi
% \ifENGLISH
% Usually only the height and the two radii are used to construct the lens,
% the width is calculated automatically. For \nxLkeyword{lenswidth} greater
% than zero, this width is used instead. This is only useful if you want to draw
% thick lenses and it can give ugly results if the value is choosen too
% small.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{lenswidth}}]
\begin{pspicture}(3,2)
  \lens[lenswidth=0.5, beam](0,1)(2,1){thicklens}
  \lens[lenswidth=0.1, beam](2,1)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \optitem{lens}{\prm{radiusleft} [\prm{radiusright} [\prm{height} [\prm{width}]]]}
% \ifGERMAN
% Eine Option zum gleichzeitigen Setzen mehrerer Linsenparameter. Werte mittendrin können mit einem Punkt übersprungen und Werte am Ende können weggelassen werden (z.B. \opt{lens=. 1 1}).
% \fi
% \ifENGLISH
% A convenience option to specify all lens parameters with a single option. Intermediate values can be skipped with a dot, values at the end can be omitted (e.g. \opt{lens=.\ 1 1}).
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \lens[lens=1](0,1)(1,1){L1}
  \lens[lensradius=-2 1, beam](0,1)(3,1){L2}
  \lens[lens=2 -0.7 1.2](2,1)(3,1){L3}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\section{Optisches Pl\"attchen}\fi
% \ifENGLISH\section{Optical plate}\fi
% 
% \begin{ltxsyntax}
% \dipoledesc{optplate}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optplate[beam](0,1)(3,1){filter}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
%   \numitem[1]{plateheight} 
%   \ifGERMAN Die Höhe des Plättchens.\fi\ifENGLISH The height of the plate.\fi
% 
%   \optitem[2\nxLcs{pslinewidth}]{platelinewidth}{\prm{num} or \prm{dimen}} 
%   \ifGERMAN \linewidthexplanation{des Plättchens}{Plättchen}\fi
%   \ifENGLISH \linewidthexplanation{plate}{plates}\fi
% \end{optionlist}
% 
% \ifGERMAN\section{Verzögerungsplättchen}\fi
% \ifENGLISH\section{Retardation plate}\fi
%
% \begin{ltxsyntax}
% \dipoledesc{optretplate}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optretplate[beam](0,1)(3,1){$\nicefrac{\lambda}{2}$}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem*[1]{plateheight} \ifGERMAN Die Höhe des Plättchens.\fi\ifENGLISH The height of the plate.\fi
% \numitem[0.1]{platewidth} \ifGERMAN Die Breite des Plättchens.\fi\ifENGLISH The width of the plate.\fi
% \end{optionlist}
% 
% \ifGERMAN\section{Lochblende}\fi
% \ifENGLISH\section{Pinhole}\fi
% 
% \begin{ltxsyntax}
% \dipoledesc{pinhole}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \pinhole[beam](0,1)(3,1){PH}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[1]{outerheight} \ifGERMAN Die Gesamthöhe der Lochblende.\fi\ifENGLISH The total height of the pinhole.\fi
% \numitem[0.1]{innerheight} \ifGERMAN Die Höhe des Lochs.\fi\ifENGLISH The height of the hole.\fi
% \optitem[2\nxLcs{pslinewidth}]{phlinewidth}{\prm{num} or \prm{dimen}}
% \ifGERMAN \linewidthexplanation{der Lochblende}{Lochblende}\fi
% \ifENGLISH \linewidthexplanation{pinhole}{pinholes}\fi
% 
% \numitem[0]{phwidth} 
% \ifGERMAN 
% Die Lochblende wird plastischer gezeichnet, falls \nxLkeyword{phwidth} ungleich
% Null ist. In diesem Fall wird \Lkeyword{phlinewidth} ignoriert. Bei einem
% negativen Wert wird die Form gespiegelt.
% \fi
% \ifENGLISH
% The pinhole is drawn in a more plastic style if the \nxLkeyword{phwidth} is
% not zero, in this case the \Lkeyword{phlinewidth} is ignored. For negative
% values the shape is mirrored.
% \fi 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{phwidth}}]
\begin{pspicture}(3,1.5)
  \pinhole[beam, phwidth=-0.1](0,1)(1.5,1){neg}
  \pinhole[beam, phwidth=0.05](1.5,1)(3,1){pos}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\section{Kristall}\fi
% \ifENGLISH\section{Crystal}\fi
%
% \begin{ltxsyntax}
% \dipoledesc{crystal}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.3)
  \crystal[beam](0,1)(3,1){Crystal}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[1.4]{crystalwidth}
% \ifGERMAN Die Breite des Kristalls.\fi
% \ifENGLISH The width of the crystal.\fi
%
% \numitem[0.6]{crystalheight}
% \ifGERMAN Die Höhe des Kristalls.\fi
% \ifENGLISH The height of the crystal.\fi
%
% \numitem[0.6]{caxislength}
% \ifGERMAN Die Länge des Pfeils für die $c$-Achse, wird weggelassen falls die
% Länge \opt{0} ist und gespiegelt falls der Wert negativ ist.
% \fi
% \ifENGLISH 
% The length of the $c$-axis, is dropped when set to \opt{0} and is mirrored if
% the values is negative.
% \fi
%
% \boolitem[false]{caxisinv}
% \ifGERMAN 
% Invertiert die Richtung der $c$-Achse, alternativ kann auch gleich ein
% negativer Wert für \Lkeyword{caxislength} genommen werden.
% \fi
% \ifENGLISH 
% Invert the direction of the $c$-axis, this is equivalent to using a negative
% \Lkeyword{caxislength}.
% \fi
%
% \boolitem[false]{voltage}
% \ifGERMAN Zeichnet einen Spannungsanschluss und ein Erdungszeichen.\fi
% \ifENGLISH Draw a voltage connection and a ground symbol.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{voltage}}]
\begin{pspicture}(0,0.4)(3,1.5)
  \crystal[voltage, beam](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \boolitem[false]{lamp}
% \ifGERMAN Zeichne eine Lampe neben den Kristall.\fi
% \ifENGLISH Draw a lamp near the crystal.\fi
%
% \numitem{lampscale}
% \ifGERMAN Skalierung der Lampe.\fi
% \ifENGLISH Scaling of the lamp.\fi
% \deprecatedmsg{\Lstyle{CrystalLamp}}
% \end{optionlist}
%
% \begin{stylelist}
% \styleitem{CrystalCaxis}
% \ifGERMAN Der Stil für die $c$-Achse inklusive der Pfeilart.\fi
% \ifENGLISH The style of the $c$-axis including the arrow type.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{CrysalCaxis}}]
\begin{pspicture}(0,0.5)(3,1.6)
  \newpsstyle{CrystalCaxis}{linecolor=red, arrows=->>}
  \crystal[beam](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \styleitem{CrystalLamp}
% \ifGERMAN Der Stil für die Lampe.\fi
% \ifENGLISH The style of the crysal lamp.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{lamp}}]
\begin{pspicture}(0,0.4)(3,1.7)
  \crystal[lamp, beam](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{stylelist}
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{voltage, lamp}}]
\begin{pspicture}(3,1.7)
  \crystal[fillstyle=solid, fillcolor=yellow!90!black, 
           label=1.2 -45, voltage, 
           lamp, beam](0,1)(3,1){SBN:Ce}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \medskip
% 
% \ifGERMAN\section{Box}\fi
% \ifENGLISH\section{Box}\fi
% 
% \begin{ltxsyntax}
% \dipoledesc{optbox}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optbox[beam](0,0)(3,2){box}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[1.4]{optboxwidth}
% \ifGERMAN Die Breite der Box.\fi\ifENGLISH The width of the box.\fi
%
% \numitem[0.8]{optboxheight}
% \ifGERMAN Die Höhe der Box.\fi\ifENGLISH The height of the box.\fi
%
% \optitem{optboxsize}{\prm{width}[ \prm{height}]}
% \ifGERMAN Die Breite und Höhe der Box, äquivalent zum Aufruf von
% \Lkeyword{optboxwidth} und \Lkeyword{optboxheight}. Wird nur ein Wert
% angegeben, dann wird dieser für Breite und Höhe verwendet.
% \fi
% \ifENGLISH The width and height of the box, is equivalent to calling both
% \Lkeyword{optboxwidth} and \Lkeyword{optboxheight}. If only a single value is
% given it is used for both width and height.
% \fi
% \end{optionlist}
% 
% \ifGERMAN\section{Detektor}\fi
% \ifENGLISH\section{Detector}\fi
% 
% \begin{ltxsyntax}
% \dipoledesc{optdetector}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.2)
  \optdetector[beam](0,0)(1.5,1){detector}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.8]{detsize} 
%   \ifGERMAN 
%   Das ist die Seitenlänge (\opt{diode}) bzw. der Durchmesser (\opt{round}) des Detektors.
%   \fi
%   \ifENGLISH 
%   This is the side length (\opt{diode}) or the diameter \opt{round} of the detector.
%   \fi
% 
%   \choitem[round]{dettype}{round, diode} 
%   \ifGERMAN
%   Dieser Parameter bestimmt den Typ und damit das Aussehen des Detektors.
%   \fi
%   \ifENGLISH
%   This parameter selects between different types of detectors.
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{dettype}}] 
\begin{pspicture}(3,1.5)
  \optdetector[beam, dettype=diode](0,0)(1.5,1){detector}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \begin{stylelist}
% \styleitem{DetectorStyle} 
% \ifGERMAN 
% Der Stil der Diode für \Lkeyword{dettype}\opt{=diode}.
% \fi
% \ifENGLISH 
% The style of the diode for \Lkeyword{dettype}\opt{=diode}.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \newpsstyle{OptComp}{linewidth=2\pslinewidth}
  \newpsstyle{DetectorStyle}{linewidth=0.5\pslinewidth}
  \optdetector[dettype=diode](0,1)(2,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{stylelist}
% 
% \ifGERMAN\section{Optische Diode}\fi
% \ifENGLISH\section{Optical diode}\fi
%
% \begin{ltxsyntax}
% \dipoledesc{optdiode}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{optdiode}}] 
\begin{pspicture}(3,2)
  \optdiode[beam](0,1)(3,1){Diode}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.8]{optdiodesize}
% \ifGERMAN 
% Die Seitenlänge der optischen Diode.
% \fi
% \ifENGLISH
% The side length of the optical diode.
% \fi
% \end{optionlist}
% 
% \ifGERMAN\section{Doveprisma}\fi
% \ifENGLISH\section{Dove prism}\fi
% 
% \begin{ltxsyntax}
% \dipoledesc{doveprism}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{doveprism}}] 
\begin{pspicture}(3,1.5)
  \doveprism[beam](0,1)(3,1){Dove}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \optitem[0.6]{doveprismsize}{\prm{num}[ \prm{num}]}
%   \ifGERMAN
%   Die Höhe des Prismas, die Gesamtbreite ist das dreifache und die Winkel an
%   der Eingangs- und Ausgangsfläche betragen 45\textdegree.
%   \fi
%   \ifENGLISH
%    The height of the prism, the total width is set to
%   three times the height and the angles at the input and output faces are
%   45\textdegree.
%   \fi
% \end{optionlist}
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{doveprism}}] 
\begin{pspicture}(4,1.5)
  \optplane(0,1)
  \doveprism[doveprismsize=1.2](0,1)(4,1)
  \optplane(4,1)
  \drawbeam[raytrace=false, linecolor=black]{-}
  \drawbeam[n=1.5, linecolor=red]{-}
  \drawbeam[n=*sqrt(5), linecolor=green, linestyle=dashed]{-}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \ifGERMAN\section{Polarisation}\fi
% \ifENGLISH\section{Polarization}\fi
%
% \begin{ltxsyntax}
% \dipoledesc{polarization}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{polarization}}] 
\begin{pspicture}(3,1)
  \polarization[beam](0,0.5)(3,0.5)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.6]{polsize}
% \ifGERMAN Die Größe des Polarisationszeichens, der Kreis für \opt{perp} und
% \opt{polmisc} ist halb so groß.\fi
% \ifENGLISH The size of the polarization symbol, the circle for \opt{perp} and
% \opt{polmisc} is half of this.\fi
%
% \optitem[0.7\nxLcs{pslinewidth}]{pollinewidth}{\prm{num} or \prm{dimen}}
%   \ifGERMAN \linewidthexplanation{des Polarisationszeichens}{Polarisationszeichen}\fi
%   \ifENGLISH \linewidthexplanation{polarisation sign}{polarisation signs}\fi
%   \deprecatedmsg{\Lstyle{Polarization}}
%
% \choitem[parallel]{poltype}{parallel, perp, misc, lcirc, rcirc}
% \ifGERMAN Dieser Parameter wählt die Polarizationsart aus.\fi
% \ifENGLISH This parameter choses the polarization type.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{poltype}}] 
\begin{pspicture}(0,-0.3)(3,4.3)
  \psset[optexp]{beam}
  \begin{optexp}
  \polarization[poltype=parallel, abspos=0.5](0,4)(3,4)
  \polarization[poltype=perp, abspos=1](0,3)(3,3)
  \polarization[poltype=misc, abspos=1.5](0,2)(3,2)
  \polarization[poltype=lcirc, abspos=2](0,1)(3,1)
  \polarization[poltype=rcirc, abspos=2.5](0,0)(3,0)
  \end{optexp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \begin{stylelist}
% \styleitem{Polarization}
% \ifGERMAN Bestimmt das Aussehen der Polarisationssymbole.\fi
% \ifENGLISH Affects the style of the polarisation symbols.\fi
% \end{stylelist}
% 
% \ifGERMAN\section{Spiegel}\fi
% \ifENGLISH\section{Mirror}\fi
% 
% \begin{ltxsyntax}
% \tripoledesc{mirror}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{mirror}}] 
\begin{pspicture}(3,2)
  \mirror[beam](0,0)(1.8,1.5)(0,2){M}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[1]{mirrorwidth}
% \ifGERMAN 
%   Die Breite des Spiegels.
%  \fi
% \ifENGLISH 
%   The width of the mirror.
% \fi
% 
% \optitem[2\nxLcs{pslinewidth}]{mirrorlinewidth}{\prm{num} or \prm{dimen}} 
% \ifGERMAN \linewidthexplanation{des Spiegels}{Spiegel}\fi
% \ifENGLISH \linewidthexplanation{mirror}{mirrors}\fi
%
% \numitem[0]{mirrorradius} 
% \ifGERMAN
% Diese Parameter setzt die Krümmung des Spiegels. Null ergibt einen
% ebenen, ein negativer Radius einen konvexen und ein positiver Radius
% einen konkaven Spiegel.
% \fi
% \ifENGLISH
% This parameter defines the curvature of the mirror. A value of \opt{0}
% is for a plain mirror, a negative radius for a convex mirror and a
% positive radius gives you a concave mirror.
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \psset{labeloffset=0.5}
  \mirror[mirrorradius=1](0,0)(1,2)(1.8,1){convex}
  \mirror[mirrorradius=-1](1,2)(1.8,1)(2.5,3){concave}
  \drawbeam{(0,0)}{1}{2}{(2.5,3)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[normal]{mirrortype}{normal, piezo, extended}
% \ifGERMAN
%   Diese Parameter wählt die Spiegelart aus. Beachten Sie, dass der
%   Anschlussdraht für den Piezospiegel nicht gezeichnet wird, falls
%   \Lkeyword{extnode} verwendet wird.
% \fi
% \ifENGLISH
% The \nxLkeyword{mirrortype} selects between different types of mirrors. Note,
% that the default piece of wire is omitted when using \Lkeyword{extnode} with a
% piezo mirror.
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \mirror[mirrortype=extended,
            beam](0,0)(1.8,1.5)(0,2){ext}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}
\begin{pspicture}(3,2)
\mirror[mirrortype=piezo,
          beam](0,0)(1.8,1.5)(0,2){piezo}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \boolitem[false]{variable}
% \ifGERMAN
% Zeichnet einen verstellbaren Spiegel, der mit zwei zusätzlichen
% gekrümmten Pfeilen an beiden Seiten angedeutet wird.
% \fi
% \ifENGLISH
% Draw an adjustable mirror which has two additional curved arrows on
% both sides.
% \fi
% 
% \numitem[0.1]{mirrordepth} 
% \ifGERMAN
%   Die Gesamttiefe eines breiten Spiegels.
% \fi
% \ifENGLISH
%   The total depth of an extended mirror.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \mirror[mirrortype=extended, mirrordepth=0.2,
            beam](0,0)(1.8,1.5)(0,2){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \begin{stylelist}
% \styleitem{ExtendedMirror} 
% \ifGERMAN Der Stil für den \opt{extended} Spiegel.\fi
% \ifENGLISH The style for the \opt{extended} mirror.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \newpsstyle{ExtendedMirror}{fillstyle=solid, 
                                fillcolor=gray!50,
                                linestyle=none}
  \mirror[mirrortype=extended,
            beam](0,0)(1.8,1.5)(0,2){ext}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \styleitem{PiezoMirror} 
% \ifGERMAN 
% Der Stil für den \opt{piezo} Spiegel. Dieser kann auch dazu verwendet
% werden, die Größe des Piezos zu verändern, wie in dem folgenden Beispiel zu sehen ist.
% \fi
% \ifENGLISH
% This style defines the appearance of the \opt{piezo} mirror. This can also
% be used to change the size of piezo part, as the example shows.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \addtopsstyle{PiezoMirror}{xunit=2}
  \mirror[mirrortype=piezo,
            beam](0,0)(1.8,1.5)(0,2){piezo}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \styleitem{VariableMirror} 
% \ifGERMAN
%   Der Stil der Pfeiles des verstellbaren Spiegels.
% \fi
% \ifENGLISH
% The style of the arrows of the variable mirror.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \mirror[beam, variable](0,0)(1.8,1.5)(0,2){var}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{stylelist}
% 
% \ifGERMAN\section{Strahlteiler}\fi
% \ifENGLISH\section{Beamsplitter}\fi
%
% \begin{ltxsyntax}
% \tripoledesc{beamsplitter}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \beamsplitter[beam](0,1)(2,1)(2,0){BS}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{bssize}
% \ifGERMAN
%   Die Größe des Strahlteilers.
% \fi
% \ifENGLISH
%   The beamsplitter size.
% \fi
%  
% \choitem[cube]{bsstyle}{cube, plate} 
% \ifGERMAN
% Wählt zwischen zwei Strahlteilertypen: einem Strahlteilerwürfel
% (\opt{cube}) und einem halbdurchlässigen Spiegel
% (\opt{plate}). Beachten Sie, dass trotz des gleichen Aussehens der
% halbdurchlässige Spiegel eine anderes Verhalten beim Strahlzeichnen
% als der gewöhnliche Spiegel hat.
% \fi
% \ifENGLISH
% Selects between two types of beamsplitters: the beamsplitter cube
% (\opt{cube}) and the semitransparent mirror (\opt{plate}).  Note, that
% despite the same look, the \opt{plate} beamsplitter behaves
% differently for beam drawing than a mirror.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \beamsplitter[bsstyle=plate, beam](0,1)(2,1)(2,0){BS}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\section{Optisches Gitter}\fi
% \ifENGLISH\section{Optical grating}\fi
% 
% \begin{ltxsyntax}
% \tripoledesc{optgrating}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[1]{gratingwidth} 
% \ifGERMAN Die Breite des Gitters.\fi
% \ifENGLISH The width of the grating.\fi
% 
% \numitem[0.15]{gratingheight} 
% \ifGERMAN Die Gesamthöhe des Gitters.\fi
% \ifENGLISH The total height of the grating.\fi
% 
% \numitem[0.075]{gratingdepth}
% \ifGERMAN 
% Die absolute Modulationstiefe der Gitterstruktur. Die Gesamthöhe wird
% an diesen Wert angepasst falls sie kleiner als die Modulationtiefe ist, 
% andernfalls wird sie nicht beinflusst.
% \fi
% \ifENGLISH
% The modulation depth of the grating structure. The total height is
% adapted to this value if it is smaller than the modulation
% depth. Otherwise the total height is not affected.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[gratingdepth=0.05, 
               beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \intitem[10]{gratingcount} 
% \ifGERMAN Die Anzahl der Gitterlinien.\fi
% \ifENGLISH The number of grating grooves.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[gratingcount=3, 
               beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[blazed]{gratingtype}{blazed, binary} 
% \ifGERMAN 
%   Wählt zwischen einem binären Gitter (\opt{binary}) und einem Blazegitter (\opt{blazed}).
% \fi
% \ifENGLISH
%   Select between a \opt{binary} and a \opt{blazed} grating.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[gratingtype=binary, 
               beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \boolitem[false]{reverse} 
% \ifGERMAN
%   Invertiere die Steigung des Blazegitters.
% \fi
% \ifENGLISH
%   Reverse the slope of the grooves of the \opt{blazed} grating.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[reverse, beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \optitem[0.7\nxLcs{pslinewidth}]{gratinglinewidth}{\prm{num} or \prm{dimen}} 
% \ifGERMAN \linewidthexplanation{des Gitters}{Gitter}\fi
% \ifENGLISH \linewidthexplanation{grating}{gratings}\fi
% \end{optionlist}
%
% \begin{stylelist}
% \item[\smash{%
%   \begin{tabular}[t]{@{}r@{}}
%     \Lkeyword*{optgridwidth}\\
%     \Lkeyword*{optgridheight}\\
%     \Lkeyword*{optgriddepth}\\
%     \Lkeyword*{optgridcount}\\
%     \Lkeyword*{optgridtype}\\
%     \Lkeyword*{optgridlinewidth}
%   \end{tabular}}]^^A
% \ifGERMAN Diese Parameter wurden in die entsprechenden \opt{grating*} Parameter umbenannt und seit Version 3.0 veraltet.\fi
% \ifENGLISH These parameters were renamed to the respective \opt{grating*} parameters and are deprecated since version 3.0.\fi
% \vspace*{2cm}
% \end{stylelist}
% 
% \ifGERMAN\section{Prisma}\fi
% \ifENGLISH\section{Prism}\fi
% 
% \begin{ltxsyntax}
% \tripoledesc{optprism}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optprism[beam](0,1)(2,1)(3,0){Prism}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \ifGERMAN
% Das Prisma wird immer symmetrisch bezüglich der \prm{in} und \prm{out}
% Knoten ausgerichtet. Für asymmetrischen Strahlengang siehe
% \prettyref{chap:connecting}.
% \fi
% \ifENGLISH
% The prism is always placed symmetric between \prm{in} and \prm{out}
% nodes. For asymmetric beam traces see \prettyref{chap:connecting}.
% \fi
%
% \begin{optionlist}
% \numitem[1]{prismsize} 
% \ifGERMAN Die Höhe des Prismas.\fi
% \ifENGLISH The height of the prism.\fi
% \numitem[60]{prismangle}
% \ifGERMAN Der obere Winkel des Prismas.\fi
% \ifENGLISH The upper angle of the prism.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optprism[prismangle=30, beam](0,1)(2,1)(3,0){Prism}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \choitem[auto]{prismalign}{auto,center}
% \ifENGLISH Sets the vertical alignment of the prism with respect to the
% «reflection» node. For \opt{center}, the prism center coincides with this
% node. For \opt{auto}, the prism is shifted vertically to the reflection plane
% such that input and output interface nodes lay on the connections between the
% reflection node and the input reference node or output reference,
% respectively.\fi
%
% \iffalse
%<*ignore>
% \fi
\begin{pspicture}(13,3)
  \footnotesize
  \pnode(0,0){A}\pnode(3,1.8){B}\pnode(6,0){C}
  \psdot(A)\uput[90](A){A}
  \psdot(B)\uput[90](B){B}
  \psdot(C)\uput[90](C){C}
  \optprism[prismsize=2](A)(B)(C)
  \psline[style=Refline, linestyle=dashed](A)(B)(C)
  \newpsstyle{IfcDot}{dotstyle=+, linecolor=red, linewidth=1.5\pslinewidth}
  \psdot[style=IfcDot](\oenodeCenter{})\uput{0.1}[-90](\oenodeCenter{}){\prm{center}}
  \psdot[style=IfcDot](\oenodeIn{})\uput{0.1}[150](\oenodeIn{}){\prm{in}}
  \psdot[style=IfcDot](\oenodeOut{})\uput{0.1}[30](\oenodeOut{}){\prm{out}}
  \rput[b](\oenodeCenter{}|0,0){\opt{prismalign=auto}}
  \pnode(7,0){A}\pnode(10,1.8){B}\pnode(13,0){C}
  \psdot(A)\uput[90](A){A}
  \psdot(B)\uput[90](B){B}
  \psdot(C)\uput[90](C){C}
  \optprism[prismsize=2, prismalign=center](A)(B)(C)
  \psline[style=Refline, linestyle=dashed](A)(B)(C)
  \newpsstyle{IfcDot}{dotstyle=+, linecolor=red, linewidth=1.5\pslinewidth}
  \psdot[style=IfcDot](\oenodeCenter{})\uput{0.1}[-90](\oenodeCenter{}){\prm{center}}
  \psdot[style=IfcDot](\oenodeIn{})\uput{0.1}[150](\oenodeIn{}){\prm{in}}
  \psdot[style=IfcDot](\oenodeOut{})\uput{0.1}[30](\oenodeOut{}){\prm{out}}
  \rput[b](\oenodeCenter{}|0,0){\opt{prismalign=center}}
\end{pspicture}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\section{Umkehrprisma}\fi
% \ifENGLISH\section{Right-angle prism}\fi
% 
% \begin{ltxsyntax}
% \tripoledesc{rightangleprism}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psdot(1.8,1)
  \rightangleprism[beam](0,1.5)(1.8,1)(0,0.5){RA}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \ifGERMAN
% Das Umkehrprisma wird so ausgerichtet, dass der einfallende und der
% reflektierte Strahl parallel sind und der \prm{center} Knoten vertikal
% zentriert in dem Prisma liegt.
% \fi
% \ifENGLISH
% The right-angle prisms is align such that the incoming and reflected
% beam are parallel and the \prm{center} node is vertically centered in
% the prism.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psdot(1.8,1.2)
  \rightangleprism[beam](0,1.25)(1.8,1.2)(0,0.75){RA}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \begin{optionlist}
% \numitem[1.5]{raprismsize}
% \ifGERMAN Die Länge der Eingangsfläche.\fi
% \ifENGLISH The length of the input plane.\fi
% \end{optionlist}
% 
% \ifGERMAN\section{Pentaprisma}\fi
% \ifENGLISH\section{Penta prism}\fi
% 
% \begin{ltxsyntax}
% \tripoledesc{pentaprism}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \pentaprism[beam](0,1)(2,1)(2,0){PP}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.7]{pentaprismsize} 
%   \ifGERMAN Die Länge der Eingangs- und Ausgangsfläche.\fi
%   \ifENGLISH The length of the input and output plane.\fi
% \end{optionlist}
% 
% 
% \ifGERMAN\chapter{Faseroptische Komponenten}\fi
% \ifENGLISH\chapter{Fiber-optical components}\fi
% \label{chap:fibercomp}
% \psset{usefiberstyle}
% \begin{optionlist}
%   \boolitem{usefiberstyle} 
%   \ifGERMAN
%   Bei manchen Komponenten kann es vorteilhaft sein interne Faserteile
%   hervorzuheben. Mit diesem Parameter werden z.B. die durchlässigen Teile
%   eines Filter angezeigt und mit dem \Lstyle{Fiber}-Stil gezeichnet. In der
%   Dokumentation ist dieses Verhalten angeschaltet um zu verdeutlichen, welche
%   Teile hervorgehoben werden.
%   \fi
%   \ifENGLISH
%   For some components it can be nice to highlight
%   some internals. If \Lkeyword{usefiberstyle} is enabled, for examples the
%   passing parts of the optical filter are drawn with the \Lstyle{Fiber}
%   style. In the documentation this parameter is enabled to show the parts
%   which would be highlighted.
%   \fi
% \end{optionlist}
%
% \ifGERMAN\section{Optische Faser}\fi
% \ifENGLISH\section{Optical fiber}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optfiber}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset{labeloffset=0.3}
  \optfiber(0,0.5)(3,0.5){SSMF}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \intitem[3]{fiberloops} 
% \ifGERMAN Anzahl der Faserschleifen.\fi
% \ifENGLISH Number of the fiber loops.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset{labeloffset=0.3}
  \optfiber[fiberloops=2](0,0.5)(3,0.5){SSMF}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem[0.4]{fiberloopradius}
% \ifGERMAN Radius der Faserschleifen.\fi
% \ifENGLISH Radius of the fiber loops.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset{labeloffset=0.3}
  \optfiber[fiberloopradius=0.2](0,0.5)(3,0.5){SSMF}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem[0.3]{fiberloopsep}
% \ifGERMAN Abstand zwischen zwei aufeinanderfolgenden Faserschleifen.\fi
% \ifENGLISH Separation between two successive fiber loops.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset{labeloffset=0.3}
  \optfiber[fiberloopsep=0.6](0,0.5)(3,0.5){SSMF}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\section{Optischer Verstärker}\fi
% \ifENGLISH\section{Optical amplifier}\fi
%
% \begin{ltxsyntax}
% \fiberdipoledesc{optamp}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optamp(0,1)(3,1){EDFA}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{optampsize} 
% \ifGERMAN 
% Die Höhe bzw. die Seitenlänge des Verstärkers. Um das Verhältnis zwischen Höhe
% und Breite zu ändern, verwenden Sie \opt{xunit} und \opt{yunit}.
% \fi
% \ifENGLISH
% The height and side length of the amplifier. To change the relation of width
% and height, use \opt{xunit} and \opt{yunit}.
% \fi
% \end{optionlist}
% 
% \ifGERMAN\section{Mach-Zehnder-Modulator}\fi
% \ifENGLISH\section{Mach-Zehnder modulator}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optmzm}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optmzm(0,1)(3,1){MZM}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{optmzmsize} \sizeexplanation{\ifGERMAN des Modulators\fi\ifENGLISH modulator\fi}
% \numitem{optmzmwidth}
% \numitem{optmzmheight}
% \end{optionlist}
% 
% \ifGERMAN\section{Polarisationssteller}\fi
% \ifENGLISH\section{Polarization controller}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{polcontrol}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \polcontrol(0,1)(3,1){PC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.15]{polcontrolsize} 
% \ifGERMAN Der Radius der Polarisationssteller-Kreise.\fi
% \ifENGLISH The radius of the polarization controller circles.\fi
% \choitem[linear]{polcontroltype}{linear, triangle}
% \ifGERMAN Der Typ des Polarisationsstellers.\fi
% \ifENGLISH The type of the polarization controller.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \polcontrol[polcontroltype=triangle](0,1)(3,1){PC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\section{Isolator}\fi
% \ifENGLISH\section{Isolator}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optisolator}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optisolator(0,1)(3,1){isolator}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem{isolatorwidth}
%   \numitem{isolatorheight}
%   \numitem[0.6]{isolatorsize} \sizeexplanation{\ifGERMAN des Isolators\fi\ifENGLISH isolator\fi}
% \end{optionlist}
%
% \begin{stylelist}
% \styleitem{IsolatorArrow} 
% \ifGERMAN 
% Der Stil für den Isolatorpfeil. Das kann insbesondere nützlich sein um
% die Länge des Pfeils zu verändern. 
% \fi
% \ifENGLISH 
% The style of the isolator arrow. This can be especially useful to
% adapt the length of the arrow.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \addtopsstyle{IsolatorArrow}{xunit=1.2, 
                                 arrowinset=0.1}
  \optisolator(0,1)(3,1){isolator}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{stylelist}
% 
% \ifGERMAN\section{Optischer Schalter}\fi
% \ifENGLISH\section{Optical switch}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optswitch}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optswitch(0,1)(3,1){opened switch}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{switchsize}
% \ifGERMAN Die Größe des Schalters.\fi
% \ifENGLISH The size of the switch.\fi
%
% \choitem[opened]{switchstyle}{opened, closed} 
% \ifGERMAN Der Zustand des Schalters kann geschlossen (\opt{closed}) oder geöffnet (\opt{opened}) sein. \fi
% \ifENGLISH Indicate the switch as \opt{opened} or \opt{closed}.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optswitch[switchstyle=closed](0,1)(3,1){closed switch}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\section{Faserverzögerungstrecke}\fi
% \ifENGLISH\section{Fiber delay line}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{fiberdelayline}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \fiberdelayline(0,1)(3,1){delay line}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.6]{fdlsize} \sizeexplanation{\ifGERMAN der Verzögerungsstrecke\fi\ifENGLISH delay line\fi}
% \end{optionlist}
%
% \begin{stylelist}
% \styleitem{FdlArrow} 
% \ifGERMAN 
% Der Stil für den Pfeil. Das kann insbesonders nützlich sein um die
% Länge des Pfeils zu verändern, die bei geänderter Größe nicht mehr
% passend sein kann, oder um den Pfeil zu spiegeln.
% \fi
% \ifENGLISH 
% The style of the arrow. This can be especially useful to
% adapt the length of the arrow which may not be appropriate depending
% on the \opt{fdlsize}, or to reverse the arrow.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \addtopsstyle{FdlArrow}{xunit=-1}
  \fiberdelayline(0,1)(3,1){Delay line}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{stylelist}
% 
% \ifGERMAN\section{Polarisator}\fi
% \ifENGLISH\section{Polarizer}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optfiberpolarizer}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfiberpolarizer(0,1)(3,1){polarizer}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.6]{fiberpolsize} \sizeexplanation{\ifGERMAN des Polarisators\fi\ifENGLISH polarizer\fi}
% \end{optionlist}
% 
%
% \ifGERMAN\section{Optischer Zirkulator}\fi
% \ifENGLISH\section{Optical circulator}\fi
%
% \begin{ltxsyntax}
% \xLfmultipole{optcirculator}%
% \cmditem{optcirculator}(left)(bottom)(right){label}%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \addtopsstyle{Fiber}{arrows=->}
  \addtopsstyle{FiberOut1}{linecolor=blue}
  \addtopsstyle{FiberOut2}{linecolor=green!80!black}
  \optcirculator(0,1)(1.5,0)(3,1){Circulator}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.8]{optcircsize}
% \ifGERMAN Der Durchmesser des Zirkulators.\fi
% \ifENGLISH The diameter of the circulator.\fi
%
% \numitem[-160]{optcircangleA}
% \ifGERMAN Der Startwinkel des internen Pfeils.\fi
% \ifGERMAN The starting angle of the internal arrow.\fi
%
% \numitem[-20]{optcircangleB}
% \ifGERMAN Der Endwinkel des internen Pfeils.\fi
% \ifGERMAN The ending angle of the internal arrow.\fi
%
% \optitem{optcircangle}{\prm{num} \prm{num}}
% \ifGERMAN Kurzschreibweise um beide Winkel gleichzeitig zu setzen.\fi
% \ifENGLISH Short notation for specifying both angles.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{}}]
\begin{pspicture}(3,1.5)
  \optcirculator[optcircangle=0 -90](0,1)(1.5,0)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \begin{stylelist}
% \styleitem[unit=0.7, arrows=->, arrowinset=0]{OptCircArrow}
% \ifGERMAN Der Stil für den internen Pfeil. Damit wird sowohl die Richtung des Pfeils als auch die Größe des Bogens bestimmt.\fi
% \ifENGLISH The style of the internal arrow. It specifies the direction of the arrow and the size of the arc.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{}}]
\begin{pspicture}(3,1.5)
  \newpsstyle{OptCircArrow}{unit=0.5, arrows=<-, arrowinset=0}
  \optcirculator[optcircangle=0 -90](0,1)(1.5,0)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{stylelist}
%
% \ifENGLISH
% The circulator is positioned by default such, that the input and output fibers are orthogonal to each other, like shown in the example:
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \addtopsstyle{Fiber}{arrowscale=1.3, arrows=->, arrowinset=0}
  \optcirculator(0,0.5)(1.5,0)(3,2)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \ifENGLISH The positioning parameters (\prettyref{sec:positioning})
% are not relative to the automatic position, but refer to the reference
% nodes as usual. This implies, that the default position in this case
% is not equivalent to \Lkeyword{position}\opt{=0.5}.  \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \addtopsstyle{Fiber}{arrowscale=1.3, arrows=->, arrowinset=0, ncurv=1.5}
  \optcirculator[position=0.5](0,0.5)(1.5,0)(3,2)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \ifGERMAN\section{Faserkoppler}\fi
% \ifENGLISH\section{Fiber coupler}\fi
% \label{sec:coupler}
% 
% \ifGERMAN \fi
% \ifENGLISH The package provides three fiber couplers, which all share the same shapes and parameters. \fi
% \begin{ltxsyntax}
% \xLfmultipole{optcoupler}%
% \cmditem{optcoupler}(lefttop)(leftbottom)(righttop)(rightbottom){label}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(0,-0.4)(3,1)
  \optcoupler(0,1)(0,0)(3,1)(3,0){optcoupler}  
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \xLfmultipole{wdmcoupler}%
% \cmditem{wdmcoupler}(lefttop)(leftbottom)(right){label}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(0,-0.4)(3,1)
  \wdmcoupler(0,1)(0,0)(3,0.5){wdmcoupler}  
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \xLfmultipole{wdmsplitter}%
% \cmditem{wdmsplitter}(left)(righttop)(rightbottom){label}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(0,-0.4)(3,1)
  \wdmsplitter(0,0.5)(3,1)(3,0){wdmsplitter}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.2]{couplersize} \sizeexplanation[2.5]{\ifGERMAN des Kopplers\fi\ifENGLISH coupler\fi}
% \numitem[0.1]{couplersep} 
% \ifGERMAN Der vertikale Abstand zwischen zwei Faserports.\fi
% \ifENGLISH The vertical distance between two fiber ports.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{couplersep}}]
\begin{pspicture}(3,1.5)
  \optcoupler[couplersep=0]%
               (0,1.5)(0,0.5)(3,1.5)(3,0.5){coupler}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[ellipse]{couplertype}{none, ellipse, rectangle, crossswitch}
% \ifGERMAN Wählt zwischen unterschiedlichen Kopplertypen.\fi
% \ifENGLISH Select between different coupler types.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{couplertype}}]
\begin{pspicture}(3,4.5)
  \psset{labeloffset=0.5}
  \optcoupler[couplertype=none]%
                (0,4.5)(0,3.5)(3,4.5)(3,3.5)
  \optcoupler[couplertype=rectangle]%
               (0,3)(0,2)(3,3)(3,2)
  \optcoupler[couplertype=crossswitch]%
               (0,1.5)(0,0.5)(3,1.5)(3,0.5)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[center]{coupleralign}{top, bottom, center}
% \ifGERMAN Die Ausrichtung des Kopplers bezüglich der Referenzknoten.\fi
% \ifENGLISH The alignment of the coupler with respect to the reference nodes.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{coupleralign}}]
\begin{pspicture}(3,3)
  \psset{labeloffset=0.4}
  \optcoupler[coupleralign=top]%
               (0,3)(0,2)(3,3)(3,2){top}
  \optcoupler[coupleralign=bottom]
               (0,1.5)(0,0.5)(3,1.5)(3,0.5){bottom}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \choitem[center]{align}{top, bottom, center}
% \ifGERMAN Dieser Parameter wurde in Version 3.0 in \Lkeyword{coupleralign} umbenannt und ist seitdem veraltet. \fi
% \ifENGLISH This parameter was renamed in version 3.0 to \Lkeyword{coupleralign} and is deprecated.\fi
%
% \boolitem*[true]{variable}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{couplersep}}]
\begin{pspicture}(3,1)
  \optcoupler[variable](0,1)(0,0)(3,1)(3,0)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \begin{stylelist}
% \styleitem{VariableCoupler}%
% \ifGERMAN
%   Der Stil des Pfeiles des verstellbaren Kopplers.
% \fi
% \ifENGLISH
% The style of the arrow of the variable coupler.
% \fi
% \end{stylelist}
% 
% \ifGERMAN\subsection{Eingangs- und Ausgangsknoten}\fi
% \ifENGLISH\subsection{Input and output nodes}\fi
% \label{sec:coupler-nodes}
%
% \ifGERMAN
% Die Definition der Eingangs- und Ausgangsknoten aus \prettyref{sec:ifcnode}
% ist für die Koppler nicht gültig. Hier werden die Knoten einfach von \opt{1} (links
% oben) bis \opt{N} (rechts unten) durchnummeriert.
% \fi
% \ifENGLISH
% The definition of input and output nodes from \prettyref{sec:ifcnode} is not
% valid for couplers. Here, the nodes are simply numbered from \opt{1} (left
% top) to \opt{N} (right bottom).
% \fi
% \begin{center}
% \begin{pspicture}(11,2)
% \psset{couplersize=0.5, couplertype=rectangle, couplersep=0.2}
% \wdmsplitter(0, 1.25)(3,2)(3,0.5)
% \psdot(\oenodeIfc{1}{})\uput[120](\oenodeIfc{1}{}){1}
% \psdot(\oenodeIfc{2}{})\uput[90](\oenodeIfc{2}{}){2}
% \psdot(\oenodeIfc{N}{})\uput[-90](\oenodeIfc{N}{}){N}
% \wdmcoupler(4, 2)(4,0.5)(7,1.25)
% \psdot(\oenodeIfc{1}{})\uput[90](\oenodeIfc{1}{}){1}
% \psdot(\oenodeIfc{2}{})\uput[-90](\oenodeIfc{2}{}){2}
% \psdot(\oenodeIfc{N}{})\uput[60](\oenodeIfc{N}{}){N}
% \optcoupler(8,2)(8,0.5)(11,2)(11,0.5)
% \psdot(\oenodeIfc{1}{})\uput[90](\oenodeIfc{1}{}){1}
% \psdot(\oenodeIfc{2}{})\uput[-90](\oenodeIfc{2}{}){2}
% \psdot(\oenodeIfc{3}{})\uput[90](\oenodeIfc{3}{}){3}
% \psdot(\oenodeIfc{N}{})\uput[-90](\oenodeIfc{N}{}){N}
% \rput[b](1.5,0){\nxLcs{wdmsplitter}}
% \rput[b](5.5,0){\nxLcs{wdmcoupler}}
% \rput[b](9.5,0){\nxLcs{optcoupler}}
% \end{pspicture}
% \end{center}
%
%
% \ifGERMAN\subsection{Referenzknoten}\fi
% \ifENGLISH\subsection{Reference nodes}\fi
% \label{sec:coupler-refnodes}
%
% \ifGERMAN
% Die Definition der Referenzknoten aus \prettyref{sec:refnode} ist für Koppler
% nicht gültig und hängt von dem \Lkeyword{coupleralign} Parameter ab.
% \fi
% \ifENGLISH
% The definition of reference nodes from \prettyref{sec:refnode} is not
% valid for couplers. Here, the nodes depend on the \Lkeyword{coupleralign} parameter.
% \fi
% \begin{center}
% \begin{pspicture}(12,2)
% \psset{couplersize=0.5, couplertype=rectangle, couplersep=0.2}
% \optcoupler(0, 2)(0,0.7)(3,2)(3,0.7)
% \psdot(\oenodeRefA{})\uput[90](\oenodeRefA{}){RefA}
% \psdot(\oenodeRefB{})\uput[90](\oenodeRefB{}){RefB}
% \optcoupler[coupleralign=top](4.5, 2)(4.5,0.7)(7.5,2)(7.5,0.7)
% \psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
% \psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
% \optcoupler[coupleralign=bottom](9, 2)(9,0.7)(12,2)(12,0.7)
% \psdot(\oenodeRefA{})\uput[90](\oenodeRefA{}){RefA}
% \psdot(\oenodeRefB{})\uput[90](\oenodeRefB{}){RefB}
% \rput[b](1.5,0){\opt{coupleralign=none}}
% \rput[b](6,0){\opt{coupleralign=top}}
% \rput[b](10.5,0){\opt{coupleralign=bottom}}
% \end{pspicture}
% \end{center}
% \psset{usefiberstyle=false}
%
% \ifGERMAN\chapter{Hybridkomponenten}\fi
% \ifENGLISH\chapter{Hybrid components}\fi
% \label{sec:hybridcomp}
%
% \ifENGLISH This chapter describes the components which can be used
% both for free-ray and fiber optics but which differ from these two
% categories.
%
% The optical filter is connected by default with automatic fiber
% connections, but can likewise be used with free-ray beams, in contrast
% to the fiber components (\prettyref{chap:fibercomp}). The fiber
% collimator has one interface only, the other connection is a fiber.
% \fi \ifGERMAN Dieses Kapitel beschreibt die Komponenten, die sowohl
% für Freistrahl- als auch Faseroptik zu verwenden sind, sich von diesen
% aber etwas abgrenzen.
%
% Der optische Filter wird mit den Voreinstellungen aber als
% Faserkomponente gehandhabt, kann im Gegensatz zu den reinen
% Faserkomponenten (\prettyref{chap:fibercomp}) jedoch auch als
% Freistrahlkomponente verwendet werden. Der Faserkollimator hat nur
% eine Faser, die andere Verbindung ist Freistrahl.  \fi
%
% \ifGERMAN\section{Optischer Filter}\fi
% \ifENGLISH\section{Optical filter}\fi
%
% \begin{ltxsyntax}
% \fiberdipoledesc{optfilter}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfilter(0,1)(3,1){bandpass}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{filtersize}
% \ifGERMAN Die Größe des Filters.\fi
% \ifENGLISH The size of the filter.\fi
%
% \choitem[bandpass]{filtertype}{bandpass, bandstop, lowpass, highpass}
% \ifGERMAN Wähle zwischen unterschiedlichen Filtertypen.\fi
% \ifENGLISH Select between different filter types.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset[optexp]{usefiberstyle}
  \optfilter[filtertype=bandstop](0,1)(3,1){bandstop}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset[optexp]{usefiberstyle}
  \optfilter[filtertype=lowpass](0,1)(3,1){lowpass}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset[optexp]{usefiberstyle}
  \optfilter[filtertype=highpass](0,1)(3,1){highpass}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \begin{stylelist}
% \styleitem{FilterStyle}
% \ifGERMAN Beinflusst das Aussehen der internen Filterlinien.\fi
% \ifENGLISH Change the style of the internal filter lines.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]FilterStyle}]
\begin{pspicture}(3,1.5)
  \newpsstyle{OptComp}{linewidth=2\pslinewidth}
  \optfilter(0,1)(1.5,1)
  \newpsstyle{FilterStyle}{linewidth=0.5\pslinewidth}
  \optfilter(1.5,1)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{stylelist}
%
% Verwendung als Freistrahlkomponenten:
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfilter[fiber=none](0,1)(3,1)
  \addtopsstyle{Beam}{beamwidth=0.3,
      fillstyle=solid, fillcolor=green, opacity=0.2}
  \drawwidebeam{(0,1)}{}{(3,1)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%
% \ifGERMAN\section{Faserkollimator}\fi
% \ifENGLISH\section{Fiber collimator}\fi
% 
% \begin{ltxsyntax}
% \xLdipole{fibercollimator}\cmditem{fibercollimator}(in)(A)(B)(out){label}%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \fibercollimator[beam](0,1)(3,1){FC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \ifGERMAN
% Der Faserkollimator kann mit zwei, drei oder vier Punkten verwendet
% werden. Bei zwei Punkten wird der Kollimator wie jeder andere Zweipol
% zwischen \prm{in} und \prm{out} Knoten platziert. Bei drei Punkten
% wird eine \Lcs*{psbezier} Kurve gezeichnet, wobei der mittlere Punkt
% doppelt verwendet wird. Die Positionierungsparameter (see
% \prettyref{sec:positioning}) können verwendet werden um den Kollimator
% zwischen dem \prm{in} und \prm{A} Knoten auszurichten.
% \fi
% \ifENGLISH
% The fiber collimator can be used with two, three or four
% points. With two points, the collimator is placed like any other
% dipole component between \prm{in} and \prm{out} node. For three nodes,
% the fiber is drawn as \Lcs*{psbezier} curve for which the central node
% \prm{A} is used twice. Positioning parameters can be used to shift the
% object between \prm{in} and \prm{A} nodes.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
   \fibercollimator[beam](0,1)(2,1)(3,2){FC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \medskip
%
% \ifGERMAN
% Bei vier Knoten wird eine \Lcs*{psbezier} Kurve mit allen vier Knoten
% gezeichnet. Die Positionierungsparameter (see
% \prettyref{sec:positioning}) können verwendet werden um den Kollimator
% zwischen dem \prm{in} und \prm{A} Knoten auszurichten.
% \fi
% \ifENGLISH
% For four nodes, the fiber is drawn as \Lcs*{psbezier} curve with the
% specified nodes. Positioning parameters can be used to shift the
% object between \prm{in} and \prm{A} nodes.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
   \fibercollimator[beam](0,1)(2,1)(3,1)(3,2){FC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \begin{optionlist}
% \numitem[0.3]{fibercolsize}
% \ifGERMAN
% Die Höhe bzw. Seitenlänge des Kollimators. Mit dem \opt{xunit} oder
% \opt{yunit} Parameter kann das Verhältnis zwischen Höhe und Breite geändert
% werden.
% \fi
% \ifENGLISH
% The height and side length of the collimator. Use the \opt{xunit} or
% \opt{yunit} parameter to change this relation.
% \fi
% \end{optionlist}
%
% \ifGERMAN\chapter{Spezielle Knoten}\fi
% \ifENGLISH\chapter{Special nodes}\fi
% \label{sec:objnodes}
% 
% \ifGERMAN
% Jedes \nxLPack{pst-optexp} Objekt stellt mehrere spezielle Knoten zur
% Verfügung, die mit dessen Geometrie und Positionierung zusammenhängen. Diese
% Knoten stehen für weitere Verwendung zur Verfügung.
%
% Sie sollten immer die dafür vorgesehenen Makros verwenden um auf die
% Knotennamen zuzugreifen.
% \fi
% \ifENGLISH
% Every \nxLPack{pst-optexp} object of an experimental setup provides
% several special nodes which are related to its geometry and
% positioning. They can be accessed and used for related positioning and
% drawing.
%
% You should always use the dedicated macros to access these node names.
% \fi
% \begin{ltxsyntax}
%   \cmditem{oenode}{node}{name} 
%
% \ifGERMAN
% Das ist das grundlegende Makro mit dem auf die Knotennamen einer Komponente
% zugegriffen werden kann. Das erste Argument \prm{node} ist der Bezeichner des
% angeforderten Knotens. Das zweite Argument \prm{name} ist der Name der
% Komponente (gemäß \prettyref{sec:namingobj}). Ist dieses leer so wird das
% zuletzt definierte Objekt verwendet.
%
% Für viele der Knoten wird ein eigenes Makro bereitgestellt, das Sie dann auch
% verwenden sollten, da sich die Namenskonventionen ändern könnten. Die Makros
% stellen sicher, dass Sie immer die passenden Knotennamen erhalten. Daher sind
% die verfügbaren Bezeichner auch nicht aufgelistet.
% \fi
% \ifENGLISH
% This is the basic command to access any node associated with a certain
% object. The first argument \prm{node} is the identifier of the requested
% node. The second argument \prm{name} is the name of the target object
% (according to \prettyref{sec:namingobj}). If it is left empty, the last
% defined component is used.
%
% For most special nodes an appropriate macro is provided, which you are
% strongly advised to use, because the naming conventions may change. Using the
% macros makes sure, that you always get the correct node names. Therefore, the
% available identifiers are not listed explicitely.
% \fi
% \end{ltxsyntax}
%
% \begin{optionlist}
%   \boolitem[false]{showoptdots}
%   \ifGERMAN 
%   Markiert einige der speziellen Komponentenknoten: die schwarzen Punkte sind
%   die normalen und die schwarzen Kreuze die transformierten Referenzknoten
%   (\prettyref{sec:refnode}), der rote Punkt ist der Mittelpunktknoten
%   (\prettyref{sec:centernode}) und das rote Kreuz der Beschriftungsknoten
%   (\prettyref{sec:labelnode}).
%   \fi
%   \ifENGLISH 
%   Draw some special component nodes for debugging: The black points are the
%   normal and the black crosses are the transformed reference nodes
%   (\prettyref{sec:refnode}), the red point is the center node
%   (\prettyref{sec:centernode}), and the red cross is the label node
%   (\prettyref{sec:labelnode}).
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
\mirror[showoptdots, angle=10, beam](0,1)(1.9,1)(1.9,0)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \ifGERMAN\section{Komponenten-Bezeichner}\fi
% \ifENGLISH\section{Component identifiers}\fi
% \label{sec:namingobj}
%
% \ifGERMAN
% Alle Komponenten einer Aufbauskizze werden in aufsteigender gemäß ihrer
% Definition im Code nummeriert. Die Komponenten und deren Spezialknoten können
% immer über diese Nummer referenziert werden.
% \fi
% \ifENGLISH
% All objects of an setup drawing are numbered automatically in increasing order
% according to their definition in the code. The objects as well as their special nodes
% can always be accessed via this number.
% \fi
%
% \begin{optionlist}
%   \valitem{compname}{string} 
%   \ifGERMAN
%   Weist einer Komponente einen Bezeichner zu. Die Komponente kann nun sowohl
%   über diesen Bezeichner als auch über die zugewiesene Nummer referenziert
%   werden. Dieser Parameter kann nur innerhalb einer \nxLPack{pst-optexp}
%   Komponente verwendet werden uns sollte. Der Bezeichner sollte innerhalb
%   einer \Lenv*{pspicture}-Umgebung eindeutig sein.
%   \fi
%   \ifENGLISH
%   Assigns a name identifier to an object, which can then be
%   referenced both by this name and by its number. The parameter can be
%   assigned only directly within a \nxLPack{pst-optexp} object and should be
%   unique within one \Lenv*{pspicture} environment.
%   \fi
% \iffalse
%<*ignore>
% \fi
\ifGERMAN
\begin{LTXexample}
\begin{pspicture}(2,2)
  \optbox[compname=MyBox](0,1)(2,2)
  \psdot[linecolor=red](\oenodeIn{MyBox}) % Verwende den Namen
  \psdot[linecolor=blue](\oenodeOut{1})   % Verwende die Nummer
  \psdot[linecolor=green](\oenodeCenter{})% Nimm die letzte Komponente
\end{pspicture}
\end{LTXexample}
\fi\ifENGLISH
\begin{LTXexample}
\begin{pspicture}(2,2)
  \optbox[compname=MyBox](0,1)(2,2)
  \psdot[linecolor=red](\oenodeIn{MyBox})% use the compname
  \psdot[linecolor=blue](\oenodeOut{1})  % use the number
  \psdot[linecolor=green](\oenodeCenter{})  % the last component
\end{pspicture}
\end{LTXexample}
\fi
% \end{optionlist}
% \iffalse
%</ignore>
% \fi
% 
% \ifGERMAN\section{Referenzknoten}\fi
% \ifENGLISH\section{Reference nodes}\fi
% \label{sec:refnode}
%
% \begin{ltxsyntax}
%   \cmditem{oenodeRefA}{name}
%   \cmditem{oenodeRefB}{name}
%
%  \ifGERMAN
%  Die Eingangs- und Ausgangs-Referenzknoten.
%
%  Das sind die ursprünglichen Knoten, die für die Positionierung der Komponente
%  benutzt wurden, \nxLcs{oenodeRefA} ist der erste und \nxLcs{oenodeRefB} der
%  letzte Knoten. Diese Zuordnung ist lediglich für die Faserkoppler nicht
%  gültig, siehe hierzu \prettyref{sec:coupler-refnodes}.
%  \fi
%  \ifENGLISH
%  The input and output reference nodes.
%
%  These are the original nodes which were used for the component positioning.
%  \nxLcs{oenodeRefA} is the first node and \nxLcs{oenodeRefB} the last
%  node. This does not hold for couplers, see \prettyref{sec:coupler-refnodes}.
%  \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, linerange={1-5, 7-7}]
\begin{pspicture}(5,1)
\pnode(0.5,0.5){A}\pnode(4.5,0.5){B}
\optbox(A)(B)
\psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
\psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
\psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%   \cmditem{oenodeTrefA}{name}
%   \cmditem{oenodeTrefB}{name}
%
%   \ifGERMAN
%   Die transformierten Eingangs- und Ausgangs-Referenzknoten.
%
%   Das sind die Referenzknoten nachdem sie zusammen mit der Komponente gemäß
%   der \Lkeyword{compshift} und \Lkeyword{angle} Parameter transformiert wurden.
%   \fi
%   \ifENGLISH
%   The transformed input and output reference nodes.
%
%   These are the input and output reference nodes which are transformed
%   together with the component according to the \Lkeyword{compshift} and
%   \Lkeyword{angle} parameters.
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, linerange={1-7,9-9}]
\begin{pspicture}(5,1.8)
\pnode(0.5,0.5){A}\pnode(4.5,0.5){B}
\optbox[compshift=0.5, angle=10](A)(B)
\psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
\psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
\psdot(\oenodeTrefA{})\uput[90](\oenodeTrefA{}){TrefA}
\psdot(\oenodeTrefB{})\uput[90](\oenodeTrefB{}){TrefB}
\psline[style=Refline](\oenodeTrefA{})(\oenodeTrefB{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
%
% \ifGERMAN\section{Mittelpunktknoten}\fi
% \ifENGLISH\section{Center node}\fi
% \label{sec:centernode}
%
% \begin{ltxsyntax}
%   \cmditem{oenodeCenter}{name}
% 
% \ifGERMAN
% Dieser Knoten liegt, bis auf wenige Ausnahmen (z.B. den
% \hyperref[cmd:optdetector]{Detektor}), im Mittelpunkt der Komponente.
% \fi
% \ifENGLISH
% This node lays, except for a few components (e.g. the
% \hyperref[cmd:optdetector]{detector}), in the center of the component.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-3, 5-6, 8-8}]
\begin{pspicture}(3,2)
\optbox(0,0.5)(3,0.5)
\psdot(\oenodeCenter{})
\psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
\optdetector(0,1.5)(2.5,1.5)
\psdot(\oenodeCenter{})
\psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \ifGERMAN\section{Beschriftungsknoten}\fi
% \ifENGLISH\section{Label node}\fi
% \label{sec:labelnode}
%
% \begin{ltxsyntax}
%   \cmditem{oenodeLabel}{name}
%
%   \ifGERMAN
%   Auf diesen Knoten wird die Beschriftung platziert. Der Knoten ist auch
%   verfügbar wenn keine Beschriftung angegeben wurde. Für
%   \xLkeyword{labeloffset}\nxLkeyword{labeloffset=0} ist dieser Knoten
%   identisch mit dem Mittelpunktsknoten (\prettyref{sec:centernode}).
%   \fi
%   \ifENGLISH
%   The component label is placed at this node. It is also available
%   if no label was specified. The label node is identical with the center
%   node for \xLkeyword{labeloffset}\nxLkeyword{labeloffset=0}.
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-4,6-6}]
\begin{pspicture}(3,1.5)
\pnode(0,1){A}\pnode(3,1){B}
\optbox(A)(B)
\psdot(\oenodeLabel{})
\psline[style=Refline](\oenodeTrefA{})(\oenodeTrefB{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
%
% \ifGERMAN\section{Externe Knoten}\fi
% \ifENGLISH\section{External nodes}\fi
% \label{sec:extnode}
%
% \begin{ltxsyntax}
%   \cmditem{oenodeExt}{name}
%
% \ifGERMAN
% Ein externer Knoten kann an unterschiedliche Positionen entlang des
% Komponentenrandes gesetzt werden. Dieser wird nur für den externen Zugriff
% definiert, und beeinflusst in keiner Weise die Komponente.
% \fi
% \ifENGLISH
% An external node can be placed at different positions along the component
% boundary. It gets defined only for external usage and does not affect the
% component in any way.
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \valitem{extnode}{refstring}
% \ifGERMAN
% Bestimmt die Position des externen Knotens. \refstringexplanation Nicht
% jede Komponente unterstützt alle möglichen Kombinationen, die möglichen
% Positionen jeder Komponente sind in \prettyref{sec:overview-extnode}
% zusammengefasst.
% \fi
% \ifENGLISH
% Set the position of the external node. \refstringexplanation Not all
% components support any possible combination. The allowed positions of each
% component are listed in \prettyref{sec:overview-extnode}.
% \fi
%
% \begin{pspicture}(6,2.5) 
%   \addtopsstyle{Beam}{beaminside=false, arrows=->, arrowinset=0, arrowscale=1.5}
%    \psset{optboxsize=2.5 1.5}\ttfamily
%    \pnode(0,1.25){A}\pnode(6,1.25){B}
%    \optbox[beam, extnode=tl](A)(B)
%    \psdot(\oenodeExt{})\uput[135](\oenodeExt{}){tl}
%    \backlayer{%
%      \optbox[extnode=t](A)(B)\psdot(\oenodeExt{})\uput[90](\oenodeExt{}){t}
%      \optbox[extnode=tr](A)(B)\psdot(\oenodeExt{})\uput[90](\oenodeExt{}){tr}
%      \optbox[extnode=r](A)(B)\psdot(\oenodeExt{})\uput[45](\oenodeExt{}){r}
%      \optbox[extnode=br](A)(B)\psdot(\oenodeExt{})\uput[-90](\oenodeExt{}){br}
%      \optbox[extnode=b](A)(B)\psdot(\oenodeExt{})\uput[-90](\oenodeExt{}){b}
%      \optbox[extnode=bl](A)(B)\psdot(\oenodeExt{})\uput[-90](\oenodeExt{}){bl}
%      \optbox[extnode=l](A)(B)\psdot(\oenodeExt{})\uput[135](\oenodeExt{}){l}
%      \optbox[extnode=c](A)(B)\psdot(\oenodeExt{})\uput[180](\oenodeExt{}){c}
%    }
% \end{pspicture}
%
% \choitem[abs]{extnodealign}{rel,relative,abs,absolute}
% \ifGERMAN
% Die Bezeichnung von «oben» (\opt{t}) und den anderen Positionierungsparametern von
% \Lkeyword{extnode} können global oder relativ zur Komponente betrachtet werden.
%
% In dem folgenden Beispiel ist der externe Knoten immer «oben rechts» (\opt{tr}) platziert,
% unabhängig von der Reihenfolge der Referenzknoten
% (\opt{extnodealign=abs}).
% \fi
% \ifENGLISH 
% The definition of «top» (\opt{t}) and the other \Lkeyword{extnode} refstring
% parameters can be global or relative to the component.
%
% In the next example the external node is always placed «top right»,
% independent of the actual order of the reference nodes
% (\opt{extnodealign=abs}). 
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(-2,-2)(2,2)
  \psset{endbox, optboxsize=1 0.6, dotscale=1.5}
  \psset{extnodealign=abs, extnode=tr}
  \multido{\i=0+45}{8}{%
    \optbox[innerlabel](0,0)(1;\i){\i}
    \psdot(\oenodeExt{})
  }
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% In dem darauffolgenden Beispiel bezieht sich die
% Positionierung relativ zur Verbindung zwischen Eingangs- und
% Ausgangsreferenzknoten (\opt{extnodealign=rel}).
% \fi
% \ifENGLISH
% In the following example the position is relative
% to the order of input and output reference node
% (\opt{extnodealign=rel}).
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(-2,-2)(2,2)
  \psset{endbox, optboxsize=1 0.6, dotscale=1.5}
  \psset{extnodealign=rel, extnode=tr}
  \multido{\i=0+45}{8}{%
    \optbox[innerlabel](0,0)(1;\i){\i}
    \psdot(\oenodeExt{})
  }%
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \ifGERMAN\section{Grenzflächenknoten}\fi
% \ifENGLISH\section{Interface nodes}\fi
% \label{sec:ifcnode}
%
% \begin{ltxsyntax}
%   \cmditem{oenodeIfc}{num}{name}
%
%   \ifGERMAN
%   Der Grenzflächenknoten \prm{num}, wobei \prm{num} eine Ganzzahl zwischen
%   \opt{1} und \opt{N} ist. Der letzte Knoten ist immer \opt{N}.
%   \fi
%   \ifENGLISH
%   The interface node \prm{num}, where the number is in the range \opt{1\ldots
%     N}. The last node is always defined as \opt{N}.
%   \fi
%
%   \cmditem{oenodeIn}{name}
%
%   \ifGERMAN
%   Der Knoten \prm{1} ist der Eingangsknoten, und sollte immer über
%   \nxLcs{oenodeIn} angesprochen werden.
%   \fi
%   \ifENGLISH
%   The interface node \prm{1} is the input node, and should always be accessed
%   via \nxLcs{oenodeIn}.
%   \fi
%
%   \cmditem{oenodeOut}{name}
%
%   \ifGERMAN
%   Der Knoten \opt{N} ist der Ausgangsknoten und sollte
%   immer über \nxLcs{oenodeOut} angesprochen werden.
%   \fi
%   \ifENGLISH
%   The interface node \prm{N} is the output node and should be accessed via
%   \nxLcs{oenodeOut}.
%   \fi
%
%   \ifGERMAN
%   «Eingang» und «Ausgang» können nur anhand einer relativen Orientierung
%   definiert werden. Per Definition ist der Eingangsknoten derjenige zu dem ein
%   Lichtstrahl ausgehend vom Referenzknoten \Lcs{oenodeRefA}
%   verläuft. Analog dazu ist die Definition ds Ausgangsknotens. Diese
%   Bezeichnung kann nur für Faserkoppler (siehe \prettyref{sec:coupler-nodes}) und
%   Strahlteiler (\ref{cmd:beamsplitter}) nicht angewendet werden.
%
%   \nxLcs{oenodeIn} ist äquivalent zu \nxLcs{oenodeIfc\{1\}} und
%   \nxLcs{oenodeOut} ist äquivalent zu \nxLcs{oenodeIfc\{N\}}. Die Eingangs-
%   und Ausgangsknoten sollten über die explizit bereitgestellten Makros
%   angesprochen werden, \nxLcs{oenodeIfc} sollte nur für die weiteren
%   Grenzflächenknoten, sofern vorhanden, verwendet werden.
%   \fi
%   \ifENGLISH
%   «Input» and «output» can define only relative orientations. The input node
%   is by definition the node to which a beam coming from the reference node
%   \Lcs{oenodeRefA} is connected to. Correspondingly is the definition of the
%   output node. This definition breaks down only for fiber couplers (see
%   \prettyref{sec:coupler-nodes}) and beamsplitter (\ref{cmd:beamsplitter}).
%
%   \nxLcs{oenodeIn} is equivalent to \nxLcs{oenodeIfc\{1\}} and
%   \nxLcs{oenodeOut} is equivalent to \nxLcs{oenodeIfc\{N\}}. You should use
%   the \nxLcs{oenodeIfc} macro only to access the nodes which are not the input
%   and output nodes as for those explicit macros are provided.
%   \fi
% \end{ltxsyntax}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(2.8,3) 
  \pentaprism[pentaprismsize=1.3](0,1.5)(1.5,1.5)(1.5,0)
  \drawbeam[arrows=->, arrowinset=0, arrowscale=1.5]{(0,1.5)}{}{(1.5,0)}
  \psdot(\oenodeIn{})\uput[135](\oenodeIn{}){1}
  \psdot(\oenodeIfc{2}{})\uput[0](\oenodeIfc{2}{}){2}
  \psdot(\oenodeIfc{3}{})\uput[90](\oenodeIfc{3}{}){3}
  \psdot(\oenodeOut{})\uput[-45](\oenodeOut{}){N}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% In \prettyref{sec:overview-ifcnode} finden Sie eine vollständige Liste aller
% Komponenten mit ihren Grenzflächenknoten.
% \fi
% \ifENGLISH
% See \prettyref{sec:overview-ifcnode} for a complete list of all
% components with their interface nodes.
% \fi
%
% \ifGERMAN\section{Referenzknoten für die Rotation}\fi
% \ifENGLISH\section{Rotation reference node}\fi
% \label{sec:rotrefnode}
%
% \begin{ltxsyntax}
%   \cmditem{oenodeRotref}{name}
%
%   \ifGERMAN 
%   Der Referenzknoten um den eine Komponente mit \Lkeyword{angle} gedreht
%   wird. Die Position des Knotens wird mit dem \Lkeyword{rotateref} Parameter
%   definiert und kann dieselben Werte annehmen wie der externe Knoten
%   (\prettyref{sec:extnode}). Eine vollständige Liste der möglichen Positionen
%   finden Sie in \prettyref{sec:overview-extnode}.
%   \fi
%   \ifENGLISH
%   The node around which a component is rotated by \Lkeyword{angle}. The
%   position is defined with the \Lkeyword{rotateref} parameter and can take the
%   same values as for the external node (\prettyref{sec:extnode}). See
%   \prettyref{sec:overview-extnode} for possible rotation reference nodes of
%   all components.
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, linerange={1-2, 6-7, 11-12}]
\begin{pspicture}(0,0.1)(12,1.8) 
  \optbox[angle=20](0.5,1)(4.5,1)
  \psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
  \psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
  \psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
  \psdot(\oenodeRotref{})\uput[-90](\oenodeRotref{}){Rotref}
  \optbox[angle=20, rotateref=bl](7.5,1)(11.5,1)
  \psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
  \psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
  \psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
  \psdot(\oenodeRotref{})\uput[-90](\oenodeRotref{}){Rotref}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
%
% \ifGERMAN\section{Strahlknoten}\fi
% \ifENGLISH\section{Beam nodes}\fi
% \label{sec:beamnode}
%
% \ifGERMAN
% Die Endknoten eines \Lcs{drawbeam} oder \Lcs{drawwidebeam} Kommandos
% können wieder verwendet werden, wenn \Lkeyword{savebeampoints} gesetzt ist.
% \fi
% \ifENGLISH
% The end points of a recent \Lcs{drawbeam} or \Lcs{drawwidebeam} command can
% be reused if \Lkeyword{savebeampoints} is set.
% \fi
% \begin{ltxsyntax}
%   \cmditem{oenodeBeam}
%
%   \ifGERMAN
%   Der Endknoten des letzten \Lcs{drawbeam} Kommandos.
%   \fi
%   \ifENGLISH
%   Access the end point of the most recent \Lcs{drawbeam} command.
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(0,0)(3,2) 
  \pnode(0,1){A}\pnode(1.6,1){B}
  \optbox[position=end](A)(B)
  \drawbeam[beaminsidelast=false]{(A)}{1}
  \psdot(\oenodeBeam{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%   \cmditem{oenodeBeamUp}
%   \cmditem{oenodeBeamLow}
%
%   \ifGERMAN
%   Der obere («upper») und untere («lower») Endknoten des letzten \Lcs{drawwidebeam} Kommandos.
%   \fi
%   \ifENGLISH
%   Access the upper or lower end point of the most recent \Lcs{drawwidebeam} command.
%   \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(0,0)(3,2) 
  \pnode(0,1){A}\pnode(3,1){B}
  \lens[abspos=1, lensradius=-2](A)(B)
  \addtopsstyle{Beam}{%
    fillstyle=solid, fillcolor=green, opacity=0.3}
  \drawwidebeam[beamwidth=0.5]{(A)}{}{(B)}
  \psdot(\oenodeBeamUp{})\psdot(\oenodeBeamLow{})
  \uput[90](\oenodeBeamUp{}){\rput[rb](0,0){BeamUp}}
  \uput[-90](\oenodeBeamLow{}){\rput[rt](0,0){BeamLow}}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% Beachten Sie, dass «oben» («upper») und «unten» («lower») bezüglich der
% Ausbreitungsrichtung des Strahls definiert ist. Ein Randstrahl der als «upper»
% startet can zu «lower» werden, wenn er den anderen Randstrahl kreuzt. Das wird
% in dem folgenden Beispiel erläutert:
% \fi
% \ifENGLISH
% Note, that «upper» and «lower» is defined with respect to the propagation
% direction of the beam. A marginal beam which started as «upper» can change to «lower»
% if it crosses the other marginal beam. This is shown in the following example,
% where the marginal rays exchange their roles:
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(0,0)(3,2) 
  \pnode(0,1){A}\pnode(3,1){B}
  \lens[abspos=1](A)(B)
  \addtopsstyle{Beam}{%
    fillstyle=solid, fillcolor=green, opacity=0.3}
  \drawwidebeam[beamwidth=0.5, savebeam]{(A)}{}
  \psdot(\oenodeBeamUp{})\psdot(\oenodeBeamLow{})
  \uput[90](\oenodeBeamUp{}){\rput[rb](0,0){BeamUp}}
  \uput[-90](\oenodeBeamLow{}){\rput[rt](0,0){BeamLow}}
  \drawwidebeam[loadbeam, beaminsidefirst]{}{(B)}
  \psdot(\oenodeBeamUp{})\psdot(\oenodeBeamLow{})
  \uput[90](\oenodeBeamUp{}){\rput[rb](0,0){BeamUp}}
  \uput[-90](\oenodeBeamLow{}){\rput[rt](0,0){BeamLow}}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
%
% \ifGERMAN
% Die Strahlknoten können nur innerhalb der \Lenv*{pspicture}-Umgebung verwendet
% werden, in der sie definiert wurden. Um auf bestimmte Strahlknoten von
% außerhalb zugreifen zu können müssen diese vorher explizit umdefiniert werden:
% \fi
% \ifENGLISH
% The beam nodes can be accessed only within the \Lenv*{pspicture} environment
% they were defined in. If you want to use one of these nodes from outside, you
% must explicitely redefine them beforehand:
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{lstlisting}
\pnode(\oenodeBeam{}){MyBeamNode}
\end{lstlisting}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% Desweiteren werden die Endknoten durch \Lkeyword{stopinside}
% beeinflusst. Siehe \prettyref{sec:custombeam} für weitere Details.
% \fi
% \ifENGLISH
% The end points are also affected by \Lkeyword{stopinside}. See
% \prettyref{sec:custombeam} for further details.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(0,0)(3,2) 
  \pnode(0,1){A}\pnode(1.6,1){B}
  \optbox[position=end](A)(B)
  \psset{beaminsidelast=false}
  \drawbeam[linecolor=red, beampos=0.3]{(A)}{1}
  \psdot(\oenodeBeam{})
  \drawbeam[stopinside]{(A)}{1}
  \psdot(\oenodeBeam{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%
% \ifGERMAN\chapter{Verbinden von Komponenten}\fi
% \ifENGLISH\chapter{Connecting components}\fi
% \label{chap:connecting}
% 
% \ifGERMAN 
% Das \nxLPack{pst-optexp}-Paket stellt unterschiedlichen Methoden bereit,
% Komponenten vollautomatisch oder manuell mit Fasern oder Lichtstrahlen zu
% verbinden.
% \begin{itemize}
% \item In \prettyref{sec:accessobj} wird beschrieben wie Komponenten und Knoten für Verbindungen angesprochen werden.
% \item \prettyref{sec:drawbeam} beschreibt Strahlverbindungen im Allgemeinen und das Verhalten von Einzelstrahlen.
% \item \prettyref{sec:drawwidebeam} erweitert die Beschreibung von Strahlverbindungen aus \prettyref{sec:drawbeam} auf ausgedehnte Strahlen.
% \item In \prettyref{sec:error-handling} wird gezeigt, wie fehlerhafte Strahlverbindungen (verfehlen von Grenzflächen) gehandhabt wird).
% \item \prettyref{sec:custombeam} erläutert, wie stückweise definierte Strahlengänge einfach realisiert werden können.
% \item \prettyref{sec:drawfiber} enthält alle Informationen zu manuellen und automatischen Faserverbindungen.
% \item \prettyref{sec:layers} erklärt das Konzept der «front» und «back»-Ebene.
% \end{itemize}
% \fi
% \ifENGLISH
% The \nxLPack{pst-optexp} package provides several methods for automatic and
% manual beam and fiber drawing.  
% 
% \begin{itemize}
% \item \prettyref{sec:accessobj} describes how to access objects and nodes for use with connections.
% \item \prettyref{sec:drawbeam} contains all information about beam drawing in general and for single beams.
% \item \prettyref{sec:drawwidebeam} extends the description of beam drawing in \prettyref{sec:drawbeam} to wide beams.
% \item \prettyref{sec:error-handling} shows how errors in beam connections (missed interfaces etc.) are handled.
% \item \prettyref{sec:custombeam} explains how customized, piecewise defined beam paths are constructed.
% \item \prettyref{sec:drawfiber} contains all about manual and automatic fiber connections.
% \item \prettyref{sec:layers} introduces the concept of front and back layer for the drawings.
% \end{itemize}
% \fi
% \ifGERMAN\section{Zugriff auf Komponenten}\fi
% \ifENGLISH\section{Accessing components}\fi\label{sec:accessobj}
% 
% All macros for connections can take either \nxLPack{pst-optexp} component
% identifier (see \prettyref{sec:namingobj}) or PSTricks nodes as arguments, which are denoted with \prm{obj$_1$},
% \prm{obj$_2$}, \ldots \prm{obj$_N$}. To distinguish between nodes and
% components, the nodes must be enclosed in parenthesis within the brackets.
%
% \begin{enumerate}
% \item 
% \ifGERMAN Auf alle Komponenten kann unter Verwendung der zugewiesenen Nummer zugegriffen werden. \fi
% \ifENGLISH All components can be accessed via their automatic number.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \pnode(0,1){A}\pnode(1.5,1){B}
  \optbox[position=end, labeloffset=0](A)(B){1}
  \drawbeam{(A)}{1}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \item 
%   \ifGERMAN Wenn eine Komponente mit \Lkeyword{compname} einen zusätzlichen
%   Namen erhalten hat, so kann dieser anstelle der Nummer verwendet werden.\fi
%   \ifENGLISH A component which has been assigned an identifier with
%   \Lkeyword{compname}, can also be accessed via this instead of its number.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psset{endbox, labeloffset=0}
  \optbox[compname=obj](0,1)(1.5,1){obj}
  \drawbeam{(0,1)}{obj}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \item
% \ifGERMAN Wird das Argument leer gelassen, so kann man auf die zuletzt definierte Komponente zugreifen. \fi
% \ifENGLISH If the argument is left empty, the last defined component is used.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psset{endbox, labeloffset=0}
  \optbox(0,0.5)(1.5,0.5){1}
  \optbox(0,1.5)(1.5,1.5){2}
  \drawbeam{(0,1)}{}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \item 
% \ifGERMAN 
% Bei \Lcs{drawbeam} und \Lcs{drawwidebeam} können auch Zahlintervalle verwendet
% werden. Gültige Intervallangaben sind
% \begin{description}
% \item[\parbox{2em}{\texttt{x-y}}] Von \opt{x} bis \opt{y}.
% \item[\parbox{2em}{\texttt{x-}}] Von \opt{x} bis zur letzten Komponente.
% \item[\parbox{2em}{\texttt{-y}}] Von der ersten Komponente bis \opt{y}.
% \item[\parbox{2em}{\texttt{-}}] Alle Komponenten.
% \end{description}
% \fi
% \ifENGLISH For \Lcs{drawbeam} and \Lcs{drawwidebeam} you can also specify a
% number range. Valid range specifications are
% \begin{description}
% \item[\texttt{x-y}] From \opt{x} to \opt{y}.
% \item[\texttt{x-}] From \opt{x} to the last component.
% \item[\texttt{-y}] From the first component to \opt{y}.
% \item[\texttt{-}] All components.
% \end{description}
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \psset{position=end, optboxsize=0.5, bssize=0.5}
  \optbox[compname=obj](0.5,0.5)(0.5,2.5){obj, 1}
  \beamsplitter(0.5,2.5)(0.5,1)(2.5,1){2}
  \optbox(0.5,1)(2.5,1){3}
  \drawbeam{1-3}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{enumerate}
% \section{Drawing beams}\label{sec:drawbeam}
% The package provides several ways to connect components and nodes with beams,
% which can be either single rays or extended beams. Most parameters have the
% same effect on both single and extended beams, so most examples will be shown
% for single beams only.
%
% \begin{ltxsyntax}
%   \xLcs{drawbeam}\cmditem{drawbeam}[options]{obj$_1$}{obj$_2$}\ldots
%   \xLcs{drawwidebeam}\cmditem*{drawwidebeam}[options]{obj$_1$}{obj$_2$}\ldots
%
%   These are the two macros for beam connections; they can take a variable
%   number of arguments (minimum of two) which can be either
%   \nxLPack{pst-optexp} component identifier or PSTricks nodes. To distinguish
%   between nodes and components, the nodes must be enclosed in parenthesis
%   within the brackets. For more information about component identifiers see
%   \prettyref{sec:namingobj}.
% \end{ltxsyntax}
%
% \subsection{Raytracing}
% The beam connection macros support two modes of tracing the beam across the
% optical components: one is to use refractive indices and Snell's law to
% determine the beam path. The other mode is to connect the components only
% regardless of their optical properties.
%
% You must always keep in mind, that this is a package for \emph{sketching}
% experimental setups. Therefore, we do not provide a comprehensive raytracing,
% because deviations from the actual physical path are often desired for
% sketches: beam angles and divergences should be in many cases more extreme
% than in the real setup in order to highlight certain aspects. Also you should
% consider the refractive index (see \prettyref{sec:n}) only as a tool to
% optimize the visual effects of the beam path, and not stick with its
% physically correct values.
%
% \begin{optionlist}
%   \boolitem[true]{raytrace} Chooses the mode of tracing the beam path,
%   \opt{true} uses the refractive index («raytracing»), \opt{false} selects
%   component connection («connect» mode).
%
%   In most cases, the «connect» mode is equivalent to «raytracing» with
%   \Lkeyword{n}\opt{=1}, except for \Lcs{optprism} and \Lcs{doveprism}, where
%   the interface nodes (\prettyref{sec:ifcnode}) are simply connected. 
%
%   See the following two example for the differences between the tracing modes
%   using these two components. The interface nodes are highlighted for clarity.
%
%   The raytraced beam with \Lkeyword{n}\opt{=1} (blue) passes the component
%   without changing its direction, the refraction for \Lkeyword{n}\opt{=1.5} is
%   calculated, and the «connect» beam just passes through the two interface
%   nodes.
%
%\iffalse
%<*ignore>
%\fi
\begin{LTXexample}[linerange={1-7,9-9}]
\begin{pspicture}(3,2.2)
  \pnode(0,1.5){A}\pnode(1,1.5){B}\pnode(3,1){C}
  \optprism[prismsize=1.2](A)(B)(C)
  \optplane(C)
  \drawbeam[n=1, linecolor=blue]{(A)}{1}{2}
  \drawbeam[n=1.5, linecolor=red]{(A)}{1}{2}
  \drawbeam[raytrace=false, linecolor=DGreen]{(A)}{1}{2}  
  \psdot(\oenodeIn{1})\psdot(\oenodeOut{1})
\end{pspicture}
\end{LTXexample}
%\iffalse
%</ignore>
%\fi
%
% For the \Lcs{doveprism} the same applies as for the \Lcs{optprism}, but the
% raytraced beam with \Lkeyword{n}\opt{=1} (blue) missed the second interface
% because it is not refracted, and stops therefore at the first interface (see
% \prettyref{sec:error-handling}).
%
%\iffalse
%<*ignore>
%\fi
\begin{LTXexample}[linerange={1-7,9-9}]
\begin{pspicture}(4,2)
  \pnode(0,1){A}\pnode(4,1){B}
  \doveprism[doveprismsize=1](A)(B)
  \optplane(B)
  \drawbeam[n=1, linecolor=blue, beampos=0.1]{(A)}{1}{2}
  \drawbeam[n=1.5, linecolor=red]{(A)}{1}{2}
  \drawbeam[raytrace=false, linecolor=DGreen]{(A)}{1}{2}  
  \psdot(\oenodeIn{1})\psdot(\oenodeIfc{2}{1})\psdot(\oenodeOut{1})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \subsection{Automatic connection}
% \begin{optionlist}
% \boolitem[false]{beam}
% \ifGERMAN Kann als Option für jede Komponente verwendet werden, ist äquivalent zu\fi
% \ifENGLISH Can be used as option for every component, is equivalent to the statement\fi
% \begin{lstlisting}[gobble=2]
% \drawbeam[raytrace=false]{(\oenodeRefA{})}{}{(\oenodeRefB{})}
% \end{lstlisting}
% \ifENGLISH which draws a beam from one reference node via the component to the
% other reference node.\fi 
% \ifGERMAN womit ein Strahl vom ersten Referenzknoten über die Komponente zum
% zweiten Referenzknoten gezeichnet wird.\fi
%
% \valitem{conn}{string}
% \ifGERMAN Diese Option wird nur aus Kompatibilitätsgründen noch bereitgestellt
% und wird aus zukünftigen Versionen entfernt.\fi
% \ifENGLISH This option is maintained for backward compatibility only and will be removed in future versions.\fi
% \end{optionlist}
%
% \subsection{Beam appearance}
%
% \begin{stylelist}
% \styleitem{Beam}
% \end{stylelist}
%
% \begin{optionlist}
%   \valitem{addtoBeam}{list} \addtostylemsg{Beam}
%   \valitem{newBeam}{list} \newstylemsg{Beam}
% \end{optionlist}
%
% \subsection{Refractive index}\label{sec:n}
%
% The raytracing depends on the refractive index, which can be set flexibly for
% each component. The refractive index is always relative to the background
% which has a constant value for the whole sketch.
%
% \begin{optionlist}
% \valitem[1.5]{n}{code}
% \ifGERMAN 
% Setzt den Brechungsindex relativ zum Hintergrund.
% \fi
% \ifENGLISH Sets the relative refractive index respect to the background. This
% parameter has two scopes, you can either set the refractive index of each
% component or of each beam ray: 
% \end{optionlist}
% \begin{enumerate}
% \item Using \Lkeyword{n} as global parameter or as argument of a component,
%   sets a fixed refractive index for each affected components, without further
%   actions, all beam paths experience this refractive index.
% \item As parameter for \Lcs{drawbeam} or \Lcs{drawwidebeam}, you can change or
%   overwrite the refractive index of the components for specific beam
%   paths. This can be very useful e.g. to simulate chromatic dispersion. To set
%   this globally for all beams, you must add the respective parameter
%   definition to the \Lstyle{Beam} style, because global definitions of
%   \Lkeyword{n} affect only the components and not the beams.
% \end{enumerate}
% \fi
% \ifGERMAN
% \end{optionlist}
% \begin{enumerate}
% \item
% \item
% \end{enumerate}
% \fi
% The \prm{code} can in general be any Postscript code which evaluates to a
% number, e.g. \opt{1.5}, or \opt{5 sqrt}. If the \prm{code} starts with a
% \opt{*}, it will be interpreted as an algebraic
% expression\fnurl{http://mirror.ctan.org/graphics/pstricks/base/doc/pst-news08.pdf},
% e.g. \opt{*sqrt(5)}. Inside the \prm{code} you can access the refractive index
% of the component via \opt{n} which allows you to change the index relative to
% the original value, e.g. use \opt{n=n 1.01 mul} to change \opt{n} by one
% percent.
%
% In the following you find several examples about the different aspects of
% using \Lkeyword{n}.
%
% \begin{enumerate}
% \item Set a fixed refractive index for the component. Interestingly, for the
%   default shape of the \Lcs{doveprism}, a refractive index of $\sqrt{5}$ gives
%   the ideal output direction which is the same as the input direction.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample} 
\begin{pspicture}(3,1.5)
  \pnode(0,1){A}\pnode(3,1){B}
  \doveprism[n=*sqrt(5)](A)(B)
  \drawbeam{(A)}{}{(B)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \item In this example one beam uses the default refractive index of the
%   components (green), the other one overwrites it with a value of \opt{2}
%   (red).
%\iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{n}}]
\begin{pspicture}(3,3)
  \pnode(0,1){A}\pnode(3,1){B}
  \optplane(A)
  \psset{lens=3 3 2, n=1.5}
  \lens[abspos=0.5](A)(B)
  \lens[abspos=2](A)(B)
  \optplane(B)
  \addtopsstyle{Beam}{beampos=0.5}
  \drawbeam{-}
  \drawbeam[linecolor=red, n=2]{-}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \item Now, the red beam uses the default refractive index of the component,
%   the yellow beam adds \opt{0.5} to the default index.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{n}}]
\begin{pspicture}(3,3)
  \pnode(0,1.5){A}\pnode(3,1.5){B}
  \lens[lens=4 4 3, n=2, abspos=0.3](A)(B)
  \optplane[compname=Plane](B)
  \psset{beampos=0.6}
  \drawbeam[linecolor=red]{(A)}{1}{Plane}
  \drawbeam[linecolor=yellow, n=*(n+0.5)]{(A)}{1}{Plane}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \item Dynamically changing the refractive index is very useful to emulate
%   chromatic dispersion. Here, we sketch dispersion of a prism by calculating
%   the refractive index with Sellmaier's
%   equation\fnurl{http://en.wikipedia.org/wiki/Sellmeier_equation} for
%   different wavelengths.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{n}}]
\begin{pspicture}(3,3)
  \pnode(-1,0){A}\pnode(1,2.2){B}\pnode(3,0){C}
  \optplane(0,2.19)
  \optprism[prismalign=center](A)(B)(C)
  \optplane(C)
  \definecolor[ps]{bl}{rgb}{%
    tx@addDict begin Red Green Blue end}%
  \addtopsstyle{Beam}{linecolor=bl, linewidth=0.4\pslinewidth}
  \multido{\i=0+1}{60}{%
    \pstVerb{%
      \i\space 650 400 sub 59 div mul 400 add 
      tx@addDict begin wavelengthToRGB end }%
    \drawbeam[n=\i\space 650 400 sub 59 div mul 400 add Sellmaier]{-}%
  }%
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{enumerate}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{beampos}}]
\begin{pspicture}(4,3.8)
  \pnode(1.5,0.5){A}\pnode(3.5,0.5){B}
  \pnode(3.5,3.5){C} 
  \optbox[position=end](B)(A){}
  \psset{mirrortype=extended}
  \mirror[mirrorradius=3](A)(B)(C){} 
  \mirror(B)(C)(B){} 
  \drawbeam[linecolor=red, beampos=-0.2]{1-3}
  \drawbeam[linecolor=blue, beampos=0]{1-3}
  \drawbeam[linecolor=green, beampos=0.2]{1-3}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-7,9-9}, morekeywords = {[21]{beampos}}, explpreset={escapeinside={}}]
\begin{pspicture*}(0,2)(3.05,6)
  \lens[lens=8 8 8, abspos=0.6](0.5,2)(3,2)
  \optplate[position=1, plateheight=6](0.5,2)(3,2)
  \psset{beampos=2.1}
  \drawbeam[beamangle=-60]{1}{2}
  \drawbeam[beamangle=-40]{1}{2}
  \drawbeam[beamangle=-20]{1}{2}
  \psline[style=Refline, linewidth=3\pslinewidth, arrows=->, arrowinset=0, arrowscale=1.3](\oenodeOut{1})([offset=2.1]\oenodeOut{1})
\end{pspicture*}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \subsection{Initial conditions}
%
% \begin{optionlist}
%   \optitem[0]{beampos}{[\prm{x}] \prm{y}} This is the start position (\prm{x},
%   \prm{y}) of the beam at the first interface. Both values are of \prm{psnum}
%   type. If only one number is given then the $x$-coordinate is set to \opt{0}.
% \psnumitem[0]{beamangle}
% \ifGERMAN
% Der Anfangswinkel des Strahls. Dieser ist relativ zu der Verbindung von der
% ersten zur zweiten Komponente, mit \Lkeyword{beamalign} kann dieser auf
% globale Werte geändert werden.
% \fi
% \ifENGLISH
% This is the start angle of the beam. It is relative to the connection between the first
% two components, use \Lkeyword{beamalign} to change this.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{beamangle}}]
\begin{pspicture}(4,4)
  \pnode(1.5,0.5){A}\pnode(3.5,0.5){B}
  \pnode(3.5,3.5){C} 
  \psset{mirrortype=extended}
  \optbox[position=end](B)(A){}
  \mirror(A)(B)(C){} 
  \mirror(B)(C)(B){} 
  \drawbeam[linecolor=red, beamangle=3]{-3}
  \drawbeam[linecolor=blue, beamangle=0]{1-}
  \drawbeam[linecolor=green, beamangle=-3]{-}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[relative]{beamalign}{rel, relative, abs, absolute}
% \ifGERMAN
% \fi
% \ifENGLISH
% Select whether the \Lkeyword{beamangle} is relative to the connection between
% the first two components, or if it is an absolute angle.
%
% A typical situation where an absolute angle is helpful is with rotated
% components. By rotating a component, also its interface nodes (see
% \prettyref{sec:ifcnode}) are rotated, which are used to determine the input
% angle for relative alignment. Accordingly, in the following example, the green
% beam with the relative alignment is not horizontal.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{beamalign, angle}}]
\begin{pspicture}(3,1.5)
  \pnode(0,0.75){A}\pnode(3,0.75){B}
  \optbox[angle=10, showifcnodes](A)(B)
  \drawbeam{(A)}{}{(B)}
  \drawbeam[linecolor=red, beamalign=abs]{(A)}{}{(B)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \subsection{Internal beam path}
%
% 
% \boolitem[true]{beaminside}
% \ifGERMAN
% Zeichne den Strahlengang innerhalb aller Komponenten mit Ausnahme der
% ersten und letzten.
% \fi
% \ifENGLISH
% Draw the internal beams in all components except for the first and last one.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{beaminside}}]
\begin{pspicture}(0.3,0.3)(3,4)
  \psset{optboxwidth=1}
  \optbox[position=end](1,1)(1,3)
  \optretplate(1,1)(1,3)
  \pentaprism(1,3)(1,1)(2,1)
  \optbox[position=end](1,1)(2,1)
  \drawbeam[beampos=-0.05, linecolor=red]{1}{2}{3}{4}
  \drawbeam[beampos=0.05, beaminside=false]{1}{2}{3}{4}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \boolitem[false]{beaminsidefirst}
% \ifGERMAN
% Zeichne den Strahlengang innerhalb der ersten Komponenten.
% \fi
% \ifENGLISH
% Draw the internal beams in the first component.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{beaminsidefirst}}]
\begin{pspicture}(0.3,0.3)(3,4)
  \psset{optboxwidth=1}
  \optbox[position=end](1,1)(1,3)
  \optretplate(1,1)(1,3)
  \pentaprism(1,3)(1,1)(2,1)
  \optbox[position=end](1,1)(2,1)
  \drawbeam[beampos=-0.05, linecolor=red]{1}{2}{3}{4}
  \drawbeam[beampos=0.05, beaminsidefirst]{1}{2}{3}{4}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \boolitem[false]{beaminsidelast}
% \ifGERMAN
% Zeichne den Strahlengang innerhalb der letzten Komponenten.
% \fi
% \ifENGLISH
% Draw the internal beams in the last component.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{beaminsidelast}}]
\begin{pspicture}(0.3,0.3)(3,4)
  \psset{optboxwidth=1}
  \optbox[position=end](1,1)(1,3)
  \optretplate(1,1)(1,3)
  \pentaprism(1,3)(1,1)(2,1)
  \optbox[position=end](1,1)(2,1)
  \drawbeam[beampos=-0.05, linecolor=red]{1}{2}{3}{4}
  \drawbeam[beampos=0.05, beaminsidelast]{1}{2}{3}{4}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \boolitem[true]{allowbeaminside}
% \ifGERMAN
% Damit kann bestimmt werden, ob der Strahlengang innerhalb einer Komponente
% gezeichnet werden darf. Dieser Parameter wirkt nur auf Komponenten und
% überschreibt, falls auf \opt{false} gesetzt, jegliche Strahleinstellungen mit
% \Lkeyword{beaminside}, \Lkeyword{beaminsidefirst} und
% \Lkeyword{beaminsidelast}. Damit kann der Strahlengang in einzelnen
% Komponenten unterdrückt werden, für die es keinen Sinn macht
% (z.B. \Lcs{optfilter} und \Lcs{optdiode}, was sonst nicht möglich ist. 
% \fi
% \ifENGLISH
% Draw the internal beams in all components except for the first and last one.
% \fi
%
% \end{optionlist}
% \begin{ltxsyntax}
%   \xLcs{optplane}\cmditem{optplane}(center)
% \end{ltxsyntax}
%
% \ifGERMAN\subsection{Bekannte Einschränkungen}\fi
% \ifENGLISH\subsection{Known limitations}\fi
%
% \ifGERMAN
% \begin{itemize}
% \item Erweiterte Pfeileigenschaften von \LPack{pstricks-add} wie
%   z.B. \opt{ArrowInside} werden für Strahlen nicht unterstützt.
% \end{itemize}
% \fi
% \ifENGLISH
% \begin{itemize}
% \item Extended arrow settings from \LPack{pstricks-add} like \opt{ArrowInside}
%   are not supported for beam paths.
% \end{itemize}
% \fi
% 
% \ifGERMAN\section{Aufgeweitete Strahlen}\fi
% \ifENGLISH\section{Drawing wide beams}\fi
% \label{sec:drawwidebeam}
% 
% \begin{ltxsyntax}
%   \xLcs{drawwidebeam}\cmditem{drawwidebeam}[options]{obj$_1$}{obj$_2$}{\ldots}{obj$_N$}
% \end{ltxsyntax}
% \begin{optionlist}
% \psnumitem[0]{beamwidth}
% 
% \psnumitem[0]{beamdiv}
% \end{optionlist}
%
% \ifGERMAN\section{Fehlerbehandlung}\fi
% \ifENGLISH\section{Error handling}\fi
% \label{sec:error-handling}
%
% \ifGERMAN
% Da alle Strahlen direkt mit Postscript berechnet und gezeichnet werden, ist
% eine umfassende Fehlerbehandlung zur Zeit der Kompilation nicht möglich. Um
% jedoch trotzdem fehlerfreie Bilder zu bekommen, wird der Strahlengang
% abgebrochen, sobald eine Situation eintritt, die nicht unterstützt wird. Das kann
% eintreten, falls der Strahl eine Grenzfläche nicht trifft, oder
% Totalreflektion auftritt.
% \fi
% \ifENGLISH All beam are calculated and drawn directly in Postscript, so that a
% comprehensive error handling at compilation time is not possible. If a
% situation arises, which is not supported by the drawing algorithm, the beam
% path is truncated at this point. This happens when a beam misses an
% interface or if total internal reflection would occur.
% \fi
% \begin{optionlist}
%   \boolitem[true]{pswarning}
% \end{optionlist}
% \iffalse
%<*ignore>
% \fi
\ifGERMAN
\begin{LTXexample}
\begin{pspicture}(3,2.7)
  \lens[lens=2 2 2, abspos=2.5](0,1)(3,1)
  \optplane[compname=A](0,1)
  \optplane[compname=B](3,1)
  \drawbeam{A}{1}{B}
  \drawbeam[beamangle=15]{A}{1}{B}
  % Verfehlt die zweite Grenzfläche, der Strahl wird nur bis zur ersten Grenzfläche gezeichnet.
  \drawbeam[beamangle=28]{A}{1}{B}
  % Verfehlt schon die erste Grenzfläche, kein Strahl wird gezeichnet.
  \drawbeam[beamangle=29]{A}{1}{B}
\end{pspicture}
\end{LTXexample}
\fi\ifENGLISH
\begin{LTXexample}
\begin{pspicture}(3,2.7)
  \lens[lens=2 2 2, abspos=2.5](0,1)(3,1)
  \optplane[compname=A](0,1)
  \optplane[compname=B](3,1)
  \drawbeam{A}{1}{B}
  \drawbeam[beamangle=15]{A}{1}{B}
  % misses the second interface, draw only until the first interface
  \drawbeam[beamangle=28]{A}{1}{B}
  % misses first interface, skipped completely
  \drawbeam[beamangle=29]{A}{1}{B}
\end{pspicture}
\end{LTXexample}
\fi
% \iffalse
%</ignore>
% \fi
% 
% \ifGERMAN Bei aufgeweiteten Strahlen (siehe \prettyref{sec:drawwidebeam}) wird
% der Strahlengang abgebrochen, falls einer der beiden Randstrahlen einen Fehler
% aufweist.
% \fi
% \ifENGLISH For wide beams (see \prettyref{sec:drawwidebeam}) the beam ray is
% interrupted if one of the marginal rays has an error.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2.5)
  \pnode(0,2){A}\pnode(3,0){B}
  \optplane(A)
  \optprism[n=1.8](A)([Xnodesep=1.5]A)(B)
  \optplane(B)
  \addtopsstyle{Beam}{fillcolor=green, fillstyle=solid, opacity=0.3, linewidth=3\pslinewidth}
  \drawwidebeam[beamdiv=10]{-}
  \newpsstyle{Beam}{linecolor=red, linestyle=dashed}
  \drawbeam[beamangle=5]{-}
  \drawbeam[beamangle=-5]{-}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \ifGERMAN\section{Angepasste Strahlen}\fi
% \ifENGLISH\section{Custom beams}\fi
% \label{sec:custombeam}
%
% \ifGERMAN 
% Im Prinzip können alle Strahlengänge mit passender Wahl des Brechungsindex und
% der Komponentenparameter (z.B. der Linsenkrümmung) realisiert werden, was
% jedoch sehr aufwendig werden kann.  Um das zu vereinfachen, besteht die
% Möglichkeit die Endpunkte eines Strahls als Anfangspunkte für den nächsten
% Strahl zu nutzen, so dass man abschnittsweise die Divergenz und die
% Ausbreitungsrichtung definieren kann.
% \fi
% \begin{optionlist}
%   \choitem[true]{savebeampoints}{true,false,\prm{int}}
%   \ifGERMAN Speichert die Endpunkte jedes \nxLcs{draw*beam} Makros,
%   vorangegangene Punkte werden überschrieben. \Lcs{drawbeam} und
%   \Lcs{drawwidebeam} werden getrennt behandelt.
%   \fi
%   \ifENGLISH Saves the end points of each \nxLcs{draw*beam} macro, previous
%   points are overwritten. \Lcs{drawbeam} and \Lcs{drawwidebeam} are treated
%   separately.
%   \fi
%
%   \choitem[false]{loadbeampoints}{true,false,\prm{int}}
%   \ifGERMAN Verwende die Endpunkte des letzten Strahls als Startpunkte.\fi
%   \ifENGLISH Use the end points of the last beam as starting points for the next beam.\fi
% \end{optionlist}
%
% \ifGERMAN Als Beispiel nehmen wir ein Teleskop, die Strahldivergenz am Eingang
% und am Ausgang ist Null. Anstatt die Linsenparameter und den Brechungsindex
% genau einzustellen, so dass die Ausgangsdivergenz Null ist, zeichnen wir
% einfach die drei Strahlenteile mit den gewünschten Divergenzen, und verwenden
% die Endpunkte des jeweils vorangegangenen Strahls als neue Ausgangspunkte. 
% \fi
% \ifENGLISH As example we consider a telescope which has zero divergence at the
% input and output. Usually we would need to tweak the refractive index and the
% lens parameters to get an output beam with no divergence. Instead, we draw the
% three beam parts separately using the end points of the previous beams as new
% starting points and specifying the divergence for each beam part
% explicitely.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{savebeampoints, loadbeampoints}}]
\begin{pspicture}(4,2) 
  \pnode(0,1){A}\pnode(4,1){B}
  \begin{optexp}
  \lens[lens=0.5 0.5 0.5, abspos=0.5](A)(B)
  \lens[lens=4 4 2, abspos=2](A)(B)
  \addtopsstyle{Beam}{%
    fillstyle=solid, fillcolor=green, opacity=0.3}
  \psset{loadbeampoints}
  \drawwidebeam[beamwidth=0.2, stopinside]{(A)}{1}
  \drawwidebeam[beamdiv=-60]{1}{2}
  \drawwidebeam{2}{(B)}
  \end{optexp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN Als weiteres Beispiel betrachten wir die Beugung an einem Gittern in
% die nullte und erste Beugungsordnung. Zuerst wird der Strahl von dem Eingang
% bis zum Gitter gezeichnet, die Endpunkte dieses Strahls werden nun für die
% Strahlen in beide Beugungsordnungen verwendet.
% \fi
% \ifENGLISH The next example show diffraction from a grating in the zeroth and
% first diffraction order. First we draw the beam to the grating, its end points
% are used for the beams into both diffraction orders.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{savebeampoints, loadbeampoints}}, linerange={1-10,13-13}]
\begin{pspicture}(4,3)
  \pnode(0,0.5){A}\pnode(2,0.5){B}\pnode(4,3){C}
  \nodexn{(C)-(1.5,0)}{C'}
  \optgrating(A)(B)(C)
  \addtopsstyle{Beam}{%
    fillstyle=solid, fillcolor=green, opacity=0.3}
  \drawwidebeam[beamwidth=0.3]{(A)}{1}
  \psset{savebeampoints=false, loadbeampoints}
  \drawwidebeam{1}{(C)}
  \drawwidebeam{1}{(C')}
  \rput[rb]([Xnodesep=0.3, offset=0.2]C){0. order}
  \rput[rb]([offset=0.2]C'){1. order}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \begin{optionlist}
%   \boolitem[true]{savebeam}
%   \ifGERMAN Speichert die Endzustände jedes \nxLcs{draw*beam} Makros,
%   vorangegangene Werte werden überschrieben. \Lcs{drawbeam} und
%   \Lcs{drawwidebeam} werden getrennt behandelt.
%   \fi
%   \ifENGLISH Saves the end conditions of each \nxLcs{draw*beam} macro, previous
%   values are overwritten. \Lcs{drawbeam} and \Lcs{drawwidebeam} are treated
%   separately.
%   \fi
%
%   \boolitem[false]{loadbeam}
%   \ifGERMAN Verwende die Endpunkte des letzten Strahls als Startpunkte.\fi
%   \ifENGLISH Use the end points of the last beam as starting points for the next beam.\fi
% \end{optionlist}
%
% \begin{optionlist}
%   \boolitem[false]{startinside}
%   
%   \boolitem[false]{stopinside}
% \end{optionlist}
%
% \ifGERMAN\section{Faserverbindungen}\fi
% \ifENGLISH\section{Drawing fibers}\fi
% \label{sec:drawfiber}
% 
% Fiber-optical components are automatically connected to the reference
% nodes. The style of all fiber connections can be configured
% independently (see \prettyref{fig:fiberstyles}).
%
% This works quiet well if the components are aligned in series, but ceases to
% give good result for more complicated situations (e.g. loop setups). In that
% case individual fibers can be omitted and drawn separately.
%
% \subsection{Automatic fiber connections}\label{sec:drawfiber-auto}
%
% All fiber-optical components described in \prettyref{chap:fibercomp} are
% connected automatically to their reference nodes with \Lcs*{pccurve}. The
% styles of the fiber connections can be configured independently by the
% styles shown in \prettyref{fig:fiberstyles}.
%
% \begin{figure}\centering
% \begin{pspicture}(12,4.4)
% \rput[lt](0,4.4){%
%   \pstree[levelsep=1.5cm, treesep=0.6, 
%           nodesep=4pt, arrows=<-, 
%           arrowinset=0, arrowscale=1.5]{\poeTR{Fiber}}{%
%     \pstree{\poeTR{FiberIn}}{%
%       \poeTR{FiberIn1} \poeTR{FiberIn2}%
%     }%
%     \pstree{\poeTR{FiberOut}}{%
%       \poeTR{FiberOut1} \poeTR{FiberOut2}%
%     }%
%   }%
%   \rput[l](-1,0|T-0){\ifGERMAN Grundstil\fi\ifENGLISH parent style\fi}
%   \rput[l](-1,0|T-0-0){%
%     \ifGERMAN\parbox{\widthof{ausgehende Fasern}}{%
%       \RaggedRight eingehende und ausgehende Fasern}\fi
%     \ifENGLISH\parbox{\widthof{outgoing fibers}}{%
%       \RaggedRight incoming and outgoing fibers}\fi}
%   \rput[t](! \psGetNodeCenter{T-0-0-0} \psGetNodeCenter{T-0-0-1}
%      T-0-0-0.x T-0-0-1.x add 2 div T-0-0-0.y 0.4 sub){%
%      \ifGERMAN\parbox{\widthof{Obere(1) oder untere(2)}}{\RaggedRight Obere(1) oder untere(2) eingehende Faser.}\fi
%      \ifENGLISH\parbox{\widthof{Upper(1) or lower(2)}}{\RaggedRight Upper(1) or lower(2) incoming fiber.}\fi}
%   \rput[t](! \psGetNodeCenter{T-0-1-0} \psGetNodeCenter{T-0-1-1}
%      T-0-1-0.x T-0-1-1.x add 2 div T-0-1-0.y 0.4 sub){%
%      \ifGERMAN\parbox{\widthof{Obere(1) oder untere(2)}}{\RaggedRight Obere(1) oder untere(2) ausgehende Faser.}\fi
%      \ifENGLISH\parbox{\widthof{Upper(1) or lower(2)}}{\RaggedRight Upper(1) or lower(2) outgoing fiber.}\fi}
% }%
% \end{pspicture}
% \ifGERMAN
% \caption{Vererbungsdiagramm der PS-Stile für die automatischen
%   Faserverbindungen. Sie sollten diese Stile mit \protect\Lcs*{addtopsstyle}
%   ändern um die Vererbungslinie beizubehalten.}%
% \fi
% \ifENGLISH
% \caption{Inheritance diagram for the psstyles used for the automatic fiber
%   connections. These styles should be changed with \protect\Lcs*{addtopsstyle}
%   to preserve the inheritance.}%
% \fi
% \label{fig:fiberstyles}
% \xLstyle{Fiber}\label{prm:Fiber}\xLstyle{FiberIn}\label{prm:FiberIn}%
% \xLstyle{FiberIn1}\label{prm:FiberIn1}\xLstyle{FiberIn2}\label{prm:FiberIn2}%
% \xLstyle{FiberOut}\label{prm:FiberOut}\xLstyle{FiberOut1}\label{prm:FiberOut1}%
% \xLstyle{FiberOut2}\label{prm:FiberOut2}%
% \end{figure}
%
% \begin{stylelist}
% \item[\smash{\begin{tabular}[t]{@{}r@{}}\opt{new}\prm{style}\\\opt{addto}\prm{style}\end{tabular}}]
%   \xLkeyword{newFiber}\xLkeyword{addtoFiber}
%   \xLkeyword{newFiberIn}\xLkeyword{addtoFiberIn}
%   \xLkeyword{newFiberIn1}\xLkeyword{addtoFiberIn1}
%   \xLkeyword{newFiberIn2}\xLkeyword{addtoFiberIn2}
%   \xLkeyword{newFiberOut}\xLkeyword{addtoFiberOut}
%   \xLkeyword{newFiberOut1}\xLkeyword{addtoFiberOut1}
%   \xLkeyword{newFiberOut2}\xLkeyword{addtoFiberOut2} For every style two
%   appropriate keys \opt{new}\prm{style} and \opt{addto}\prm{style} are
%   provided which can be used to change the styles for single objects. This
%   can be used to define own components with respectively changed fiber
%   connections or to avoid explicit grouping.
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{addtoFiberOut1}}]
\begin{pspicture}(3,2)
  \newpsobject{tapcoupler}{wdmsplitter}{%
    coupleralign=bottom, 
    addtoFiberOut1={arrows=->, arrowscale=1.2, arrowinset=0}
  }
  \tapcoupler(0,0.5)(3,1.5)(3,0.5){99/1}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{stylelist}
%
% \begin{optionlist}
%   \choitem[all]{fiber}{none,all,\prm{refstring}} Some components can be used either for free-ray or
%   fiber-optical setups (\Lcs{optbox}, \Lcs{optdetector}). The \nxLkeyword{fiber}
%   parameter enables automatic fiber connections for them.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{fiber}}]
\begin{pspicture}(3,2)
  \optbox[fiber](0,1)(3,1){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%   \choitem[all]{fiber*}{none, all, \prm{refstring}} Choose which output fiber
%   connections to draw automatically. The values \opt{top} and \opt{bottom}
%   affect only \Lcs{optcoupler} and \Lcs{wdmsplitter}.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{fiber}}]
\begin{pspicture}(3,2)
  \wdmsplitter[fiber=br](0,1)(3,2)(3,0){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \minisec{Fiber angles}
%
% The angles of the fiber connections are calculated automatically from the
% orientation of the component. The automatic connections are a special case of
% \Lcs{drawfiber} from a node to a component, see
% \prettyref{sec:drawfiber-manual} for detail.
% 
% \subsection{Manual fiber connections}\label{sec:drawfiber-manual}
%
% \begin{ltxsyntax}
%   \xLcs{drawfiber}\cmditem{drawfiber}[Options]{Obj$_1$}{Obj$_2$}
% \end{ltxsyntax}
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, linerange={1-2,10-12}]
\begin{pspicture}(-1,0)(7,2.4)
  \optbox[fiber, angle=20, rotateref=bl](0,1)(6,1)
  \psdot(\oenodeRefA{})\uput[180](\oenodeRefA{}){RefA}%
  \psdot(\oenodeRefB{})\uput[0](\oenodeRefB{}){RefB}%
  \psdot(\oenodeRotref{})\uput[-90](\oenodeRotref{}){Rotref}%
  \psdot(\oenodeTrefA{})\uput[180](\oenodeTrefA{}){TrefA}%
  \psdot(\oenodeTrefB{})\uput[0](\oenodeTrefB{}){TrefB}%
  \uput{0.5}[180](\oenodeTrefB{}){\textcolor{Refline}{reference line}}%
  \psset{style=Refline, linestyle=dashed}
  \psline(\oenodeTrefA{})(\oenodeTrefB{})
  \psline(\oenodeRefA{})(\oenodeRefB{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, linerange={1-2,10-12}]
\begin{pspicture}(-1,-0.1)(7,3.2)
  \optbox[fiber, angle=-30, rotateref=t, compshift=0.5](0,1)(6,1)
  \psdot(\oenodeRefA{})\uput[180](\oenodeRefA{}){RefA}%
  \psdot(\oenodeRefB{})\uput[0](\oenodeRefB{}){RefB}%
  \psdot(\oenodeRotref{})\uput[60](\oenodeRotref{}){Rotref}%
  \psdot(\oenodeTrefA{})\uput[180](\oenodeTrefA{}){TrefA}%
  \psdot(\oenodeTrefB{})\uput[0](\oenodeTrefB{}){TrefB}%
  \uput{0.5}[180](\oenodeTrefB{}){\textcolor{Refline}{reference line}}%
  \psset{linecolor=Refline, linestyle=dashed}
  \psline(\oenodeTrefA{})(\oenodeTrefB{})
  \psline(\oenodeRefA{})(\oenodeRefB{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \ifGERMAN Für die Verbindungen mit \Lcs{drawfiber} werden für üblicherweise
% die Knoten genommen, die sich am nächsten sind. Das passt häufig, aber nicht
% immer.
% \fi
% \ifENGLISH The connections with \Lcs{drawfiber} are drawn usually between the
% two nodes which are closest to each other. This fits most of the time, but not
% always.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \pnode(-0.5,1){A}\pnode(1.5,1){B}\pnode(3.5,1){C}
  \psset{label=0, optboxwidth=1}
  \optbox(A)(B){Box1}\optbox(B)(C){Box2}
  \drawfiber{1}{2}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}
\begin{pspicture}(3,2)
  \pnode(0,0.5){A}\pnode(3,0.5){B}
  \pnode([offset=1]B){C}\pnode(A|C){D}
  \psset{label=0}
  \optbox(A)(B){Box1}\optbox(C)(D){Box2}
  \drawfiber{1}{2}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \begin{optionlist}
%   \choitem[auto]{startnode}{auto, 1, 2, 3, 4, N}
%   \choitem[auto]{stopnode}{auto, 1, 2, 3, 4, N}
%   \ifGERMAN Hiermit können die Start- und Stopknoten explizit gewählt werden.\fi
%   \ifENGLISH Choose the start and stop node explicitely.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(2,2)
  \pnode(0,0.5){A}\pnode(2,0.5){B}
  \pnode([offset=1]B){C}\pnode(A|C){D}
  \psset{label=0}
  \optbox(A)(B){Box1}\optbox(C)(D){Box2}
  \drawfiber[startnode=1]{1}{2}
  \drawfiber[startnode=N, linecolor=black]{1}{2}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(2.1,3)
\pnode(0,0){A}\pnode(2,0){B}
\pnode(0.3,3){C}\pnode(1.7,3){D}
\psset{fiber=none}
\optcoupler[fiber=l,
            addtoFiberIn1={angleA=0, ArrowInside=->},
            addtoFiberIn2={angleA=180, arrows=<-},
            abspos=0.5, compname=Cpl](A)(B)(C)(D){}
\optfiber[compname=Hnlf, abspos=1](C)(C|A){}
\optamp[abspos=2, compname=Amp](D|B)(D){}
\drawfiber{Cpl}{Hnlf}
\drawfiber[startnode=1, ncurv=1.2]{Hnlf}{Amp}
\drawfiber{Cpl}{Amp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%   \numitem[0]{fiberangleA}
%   \numitem[0]{fiberangleB}
%   \choitem[tref]{fiberalign}{rel,relative,center,abs,absolute}
%   Set the reference for the fiber angles.
%   \begin{valuelist}
%   \item[relative] The fiber angles are relative to the transformed reference
%     line of the component.
%   \item[center] The fiber angles are relative to the connection between the
%     involved componente node and the component center node. In most cases this
%     is equivalent to \opt{relative}, but necessary e.g. for
%     \Lcs{optcirculator}.
%     \item[absolute] The fiber angles are absolute.
%   \end{valuelist}
%
%   \valitem[curve]{fiberstyle}{string}
%   \ifGERMAN
%   \fi
%   \ifENGLISH 
%   Select the type of node connection \nxLcs{nc}\prm{string} which is use by
%   \Lcs{drawfiber}, see \LPack{pst-node} documentation for possible values. \prettyref{ex:transmission-loop} shows another use case.
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \pnode(1, 0.5){A}\pnode(2.5,0.5){B}\pnode(2.5,2){C}
  \psset{fiber=none, optboxsize=1 0.6, innerlabel}
  \optbox[position=start](A)(B){start}
  \optbox[position=end](B)(C){stop}
  \drawfiber[fiberstyle=diag, linearc=0.5]{1}{2}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(4,2.5)
  \pnode(1,2.5){In}\pnode(3,2.5){Out}
  \pnode(0,2){A}\pnode(4,2){B}\pnode(4,0){C}\pnode(0,0){D}
  \optcoupler[fiber=t, addtoFiber={ArrowInside=->}, coupleralign=bottom](In)(A)(Out)(B)
  \psset{fiber=none}
  \optamp[position=0.35](C)(D)
  \optfiber[position=0.35](D)(C)
  \drawfiber{2}{3}
  \addtopsstyle{Fiber}{fiberstyle=bar, linearc=0.5, armA=1.5}
  \drawfiber[stopnode=1]{1}{2}
  \drawfiber[stopnode=1]{1}{3}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
%
% \ifGERMAN\section{Zeichenebenen}\fi
% \ifENGLISH\section{Layers}\fi
% \label{sec:layers}
% 
% The necessary order of constructing a drawing is, that you must first set the
% components before you can connect them. This implies that all connections are
% drawn on top of the components, which might be unwanted.
%
% To circumvent this, we provide the \Lenv{optexp} environment, inside which all
% connections are drawn behind the components.
%
% \begin{ltxsyntax}
%   \envitem{optexp}
% \end{ltxsyntax}
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,4)
\psset{beam, fillstyle=solid, fillcolor=black}
\optbox(0,3.5)(3,3.5){no layers}
\begin{optexp}
  \optbox(0,1.5)(3,1.5){with layers}
\end{optexp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% Beware, that this is achieved by executing twice all code included in the
% environment. This works fine for all \LPack{pst-optexp} commands which take
% care of not drawing stuff twice, but only in a changed order. All other text
% and graphics are drawn twice, which leads to ugly results because of altered
% anti-aliasing in the viewer.
%
% To avoid this, you can either move all other code outside the environment, or
% use the following two commands to define code parts which are executed only
% once.
%
% \begin{ltxsyntax}
%   \cmditem{backlayer}{code} 
%
%   Execute \prm{code} only once in the first pass.
%
%   \cmditem{frontlayer}{code}
%
%  Execute \prm{code} only once in the second pass.
% \end{ltxsyntax}
%
% In this example, the text is put on top of the frame although the text is
% defined first: 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1)
\begin{optexp}
  \frontlayer{\rput(1.5,0.5){front}}
  \backlayer{\psframe*[linecolor=DOrange!50](1,0)(2,1)}
\end{optexp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% 
% \ifGERMAN\chapter{Benutzerdefinierte Komponenten}\fi
% \ifENGLISH\chapter{Custom components}\fi
% \label{chap:custom}
%
% \ifGERMAN
% Das \LPack{pst-optexp} Paket stellt zwei Makros zur Verfügung um
% eigene Komponenten zu zeichnen. Diese können z.B. aus Bildern oder
% eigenen Zeichnungen bestehen.
% \fi
% \ifENGLISH
% The \nxLPack{pst-optexp} package provides two commands which can use
% anything as optical components. This includes e.g. external images or
% your own drawings.
% \fi
% 
% \begin{ltxsyntax}
%   \dipoledesc{optdipole}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \optdipole[labeloffset=1, beam](0,2)(3,1){%
    \rput(0,0){\rule{0.5cm}{1cm}}%
  }{label}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \tripoledesc{opttripole}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \opttripole[beam](3,1.5)(1.5,2)(0,0){%
    \rput[b](0,0){text}%
  }{label}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
%
% If you want to use a custom component more often, you should define
% it as a new component. For details on how to define your own components see
% \prettyref{sec:newobj}.
%
% \ifGERMAN
% \section{Benutzerdefinierte Version existierender Komponenten}
% \fi
% \ifENGLISH
% \section{Customized versions of existing components}
% \fi
% \label{sec:customcomp}
% The easiest way to define your own components is to use the
% \Lcs*{newpsobject} macro. With this you can define a new component using
% predefined objects with a set of options. These options serve only as
% default values and can be overridden when calling the macro. 
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{newpsobject}}]
\begin{pspicture}(3,1.7)
\newpsobject{sbn}{crystal}{%
  voltage, lamp, %
  fillstyle=solid, fillcolor=yellow!90!black
}
\sbn[label=1.2 45, beam](0,1)(3,1){SBN:Ce}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}[morekeywords={[21]{newpsobject}}]
\begin{pspicture}(3,1.7) 
\newpsobject{pumpcoupler}{wdmcoupler}{%
  coupleralign=top, addtoFiberIn2={ArrowInside=->, arrowscale=2}
}
\pumpcoupler[label=0.5 180](0,1)(0,0)(3,1){Pumpcoupler}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, morekeywords={[21]{newpsobject}}, caption={caption}]
\begin{pspicture}(10,2)
\newpsobject{MOLensIn}{lens}{lens=0.5 0.5 0.5}
\newpsobject{MOLensOut}{lens}{lens=1.5 1.5 1.5}
\pnode(0,1){A}\pnode(10,1){B}
\MOLensIn[abspos=1](A)(B)\MOLensOut[abspos=2](A)(B)
\optplate[plateheight=1.5](A)(B)
\MOLensOut[abspos=8](A)(B)\MOLensIn[abspos=9](A)(B)
\addtopsstyle{Beam}{n=1, fillstyle=solid, fillcolor=green, opacity=0.3}
\psset{loadbeampoints}
\drawwidebeam[beamwidth=0.2, stopinside]{(A)}{1}
\drawwidebeam[beamdiv=60]{1}{2}
\drawwidebeam[stopinside]{2-4}
\drawwidebeam[beamdiv=-60]{4}{5}
\drawwidebeam{5}{(B)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \section{Defining new objects}\label{sec:newobj}
% \nxLPack{pst-optexp} provides some high-level macros to
% allow very convenient definition of your own custom components. 
%
% \begin{ltxsyntax}
%   \cmditem{newOptexpDipole}[fixopt]{name}{dftopt}\xLcs{newOptexpDipole}
%   \cmditem{newOptexpTripole}[fixopt]{name}{dftopt}\xLcs{newOptexpTripole}
%   \cmditem{newOptexpFiberDipole}[fixopt]{name}{dftopt}\xLcs{newOptexpFiberDipole}
% \end{ltxsyntax}
%
% These macros generate all organizing code for the components which handle the
% positioning, label placement, rotation and shifting and the layering. In the
% simplest case you only have to define the actual drawing of the component
% outline.
%
% The macro \Lcs*{newOptexpDipoleNolabel} is superfluous because since version
% 3.0 the label is optional for all components.
%
% The actual process of creating a new component is split up in different parts,
% depending on the component complexity and user requirements:
% \begin{enumerate}
% \item The component drawing, this is the only required part.
% \item Support for layering (optional).
% \item Support for \Lkeyword{rotateref} and \Lkeyword{extnode} (optional).
% \end{enumerate}
%
% \subsection{The component drawing}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{newOptexpDipole}}]
\begin{pspicture}(3.5,2.6)
\newOptexpDipole{mydipole}{}
\makeatletter
\def\mydipole@comp{%
  \psaxes[arrows=->](0,0)(0,-1.1)(1.3,1.3)[$x$,90][$y$,0]
}%
\makeatother
\mydipole(0,1)(3.5,1){\color{spot}label}
\drawbeam{(0,1)}{}{(3.5,1)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{newOptexpTripole}}]
\begin{pspicture}(3.5,3.7)
\newOptexpTripole{mytripole}{labelangle=-60}
\makeatletter
\def\mytripole@comp{%
  \psaxes[arrows=->](0,0)(-1.1,0)(1.3,1.3)[$x$,90][$y$,0]
}%
\makeatother
\mytripole(0,1)(2,1.7)(3,0){\color{spot}label}
\drawbeam{(0,1)}{}{(3,0)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \medskip
%
% \subsection{Adding external node}
%
% \subsection{Layering support}
%
% To support layering, the component nodes and the drawings must be separated
% into two macro. \nxLcs{component@nodes} contains the nodes and the Postscript
% definition of the component interfaces. \nxLcs{component@comp} hold only the drawings.
%
%
% \ifGERMAN\chapter{Zusatzinformationen}\fi
% \ifENGLISH\chapter{Additional information}\fi
%
% \section{Internal component structure}
% 
% In order to understand properly how the automatic beam drawing actually works,
% it is necessary to describe in more detail the internal component structure.
% 
% \begin{optionlist}
% \boolitem[false]{showifcnodes}
% \end{optionlist}
% \begin{stylelist}
% \styleitem{IfcNodeStyle}
% \end{stylelist}
% Every component type consists internally of interfaces which are defined by a
% node on the optical axis, a plane vector or a curvature radius, and by its
% optical characteristic (reflective or transmittive). The interface nodes can be
% visualized for each component type with the \Lkeyword{showifcnodes}
% parameter. 
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(4,3)
  \psset{showifcnodes}
  \optbox(0,2.5)(4,2.5){}
  \doveprism(0,1.5)(4,1.5){}
  \lens(0,0.5)(4,0.5){}
  \mirror(0,0.5)(3.5,0.5)(3.5,3){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \medskip
% 
% \nxLcs{draw*beam} calculates the distance between the interface nodes of two
% objects and connects the two nearest
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(-3,-3)(3,3)
  \psset{optboxsize=0.6 0.5, labeloffset=0}
  \multido{\i=0+60,\ii=1+1}{6}{%
    \pnode(2.5;\i){A}
    \optbox([Xnodesep=-1]A)([Xnodesep=1]A){\ii}
  }
  \optbox[compname=ref](-1,0)(1,0){ref}
  \addtopsstyle{Beam}{arrows=->}
  \multido{\i=1+1}{6}{\drawbeam{ref}{\i}}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \section{Overview of special nodes}
% \subsection{External and rotation reference nodes}\label{sec:overview-extnode}
%
% \subsection{Interface nodes}\label{sec:overview-ifcnode}
% Here, all available components and their interface nodes are listed. If
% a node is labeled as «1, N», it means that both nodes are equal.
% \bgroup \psset{unit=1.2}
% \subsubsection*{Free-ray components}
% \addtopsstyle{Beam}{arrows=->, arrowinset=0, arrowscale=1.5}
% \newcommand{\showdipoleifc}[1]{%
%   \begin{pspicture}(0,-0.5)(3,1) 
%     \pnode(0,0.5){A}\pnode(3,0.5){B}
%     \csname #1\endcsname(A)(B)
%     \drawbeam{(A)}{}{(B)}
%     \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1}
%     \psdot(\oenodeOut{})\uput[-45](\oenodeOut{}){N}
%     \rput[bl](0,-0.4){\ttfamily\textbackslash #1}
%   \end{pspicture}
% }%
% \newcommand{\showdipoleoneifc}[1]{%
%   \begin{pspicture}(0,-0.5)(3,1) 
%     \pnode(0,0.5){A}\pnode(3,0.5){B}
%     \csname #1\endcsname(A)(B)
%     \drawbeam{(A)}{}{(B)}
%     \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1, N}
%     \rput[bl](0,-0.4){\ttfamily\textbackslash #1}
%   \end{pspicture}
% }%
% \showdipoleifc{lens}\hspace{\fill}%
% \showdipoleoneifc{optplate}\hspace{\fill}%
% \showdipoleifc{optretplate}%
% \bigskip
%
% \noindent\showdipoleoneifc{pinhole}\hspace{\fill}%
% \showdipoleifc{crystal}\hspace{\fill}%
% \showdipoleifc{optbox}
% \bigskip
%
% \noindent
% \begin{pspicture}(0, -0.5)(3,1)
%   \pnode(0,0.5){A}\pnode(2.5,0.5){B}
%   \optdetector(A)(B)
%   \drawbeam{(A)}{}
%   \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1, N}
%   \rput[bl](0,-0.4){\ttfamily\textbackslash optdetector}
% \end{pspicture}%
% \hspace{\fill}%
% \bgroup
% \addtopsstyle{Beam}{beaminside=false}%
% \showdipoleifc{optdiode}\egroup%
% \hspace{\fill}%
% \begin{pspicture}(0,-0.5)(3,1) 
%   \pnode(0,0.5){A}\pnode(3,0.5){B}
%   \doveprism(A)(B)
%   \drawbeam[raytrace=false]{(A)}{}{(B)}
%   \psdot(\oenodeIn{})\uput[135](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[90](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeOut{})\uput[45](\oenodeOut{}){N}
%   \rput[bl](0,-0.4){\ttfamily\textbackslash doveprism}
% \end{pspicture}%
%
% \begin{pspicture}(3,1.5)
%   \pnode(0,1){A}\pnode(2.5,1){B}\pnode(2.5,0){C}
%   \mirror(A)(B)(C)
%   \drawbeam{(A)}{}{(C)}
%   \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1, N}
%   \rput[bl](0,0){\ttfamily\textbackslash mirror}
% \end{pspicture}%
% \hspace{\fill}%
% \begin{pspicture}(3,1.5) 
%   \pnode(0,1){A}\pnode(1.5,1){B}\pnode(3,0){C}
%   \optprism(A)(B)(C)
%   \drawbeam[raytrace=false]{(A)}{}{(C)}
%   \psdot(\oenodeIn{})\uput[135](\oenodeIn{}){1}
%   \psdot(\oenodeOut{})\uput[45](\oenodeOut{}){N}
%   \rput[bl](0,0){\ttfamily\textbackslash optprism}
% \end{pspicture}%
% \hspace{\fill}%
% \begin{pspicture}(3,1.5)
%   \pnode(0,1){A}\pnode(2.5,1){B}\pnode(2.5,0){C}
%   \optgrating(A)(B)(C)
%   \drawbeam{(A)}{}{(C)}
%   \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1, N}
%   \rput[bl](0,0){\ttfamily\textbackslash optgrating}
% \end{pspicture}%
% \bigskip
%
% \noindent
% \begin{pspicture}(3,2.5)
%   \pnode(0,1.5){A}\pnode(2.5,1.5){B}\pnode(2.5,0){C}
%   \beamsplitter[bssize=1.2](A)(B)(C)
%   \drawbeam{(A)}{}{(C)}
%   \psdot(\oenodeIfc{1}{})\uput[135](\oenodeIfc{1}{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[-45](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeIfc{3}{})\uput[0](\oenodeIfc{3}{}){3}
%   \psdot(\oenodeIfc{N}{})\uput[90](\oenodeIfc{N}{}){N}
%   \psdot(\oenodeIfc{C}{})\uput[-135](\oenodeIfc{C}{}){C}
%   \rput[bl](0,0){\ttfamily\textbackslash beamsplitter}
% \end{pspicture}%
% \hspace{\fill}%
% \begin{pspicture}(3,2.5)
%   \pnode(0,2){A}\pnode(2.5,1.5){B}\pnode(0,1){C}
%   \rightangleprism[raprismsize=2](A)(B)(C)
%   \drawbeam[arrows=->, arrowinset=0, arrowscale=1.5]{(A)}{}{(C)}
%   \psdot(\oenodeIn{})\uput[135](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[45](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeIfc{3}{})\uput[-45](\oenodeIfc{3}{}){3}
%   \psdot(\oenodeOut{})\uput[-135](\oenodeOut{}){N}
%   \rput[bl](0,0){\ttfamily\textbackslash rightangleprism}
% \end{pspicture}%
% \hspace{\fill}%
% \begin{pspicture}(3,2.5) 
%   \pnode(0,1.5){A}\pnode(2.1,1.5){B}\pnode(2.1,0){C}
%   \pentaprism[pentaprismsize=1](A)(B)(C)
%   \drawbeam[arrows=->, arrowinset=0, arrowscale=1.5]{(A)}{}{(C)}
%   \psdot(\oenodeIn{})\uput[135](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[0](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeIfc{3}{})\uput[90](\oenodeIfc{3}{}){3}
%   \psdot(\oenodeOut{})\uput[-45](\oenodeOut{}){N}
%   \rput[bl](0,0){\ttfamily\textbackslash pentaprism}
% \end{pspicture}%
%
% \subsubsection*{Fiber components}
% \newcommand{\showfdipoleifc}[1]{%
%   \begin{pspicture}(0,-0.5)(3,1) 
%     \pnode(0,0.5){A}\pnode(3,0.5){B}
%     \csname #1\endcsname(A)(B)
%     \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1}
%     \psdot(\oenodeOut{})\uput[-45](\oenodeOut{}){N}
%     \rput[bl](0,-0.4){\ttfamily\textbackslash #1}
%   \end{pspicture}%
% }%
% \addtopsstyle{Fiber}{ArrowInside=->, ArrowInsidePos=0.6, arrowscale=1.5, arrowinset=0}
% \vspace*{5mm}%
% \showfdipoleifc{optfiber}\hspace{\fill}%
% \showfdipoleifc{optamp}\hspace{\fill}%
% \showfdipoleifc{optmzm}%
% \bigskip
%
% \noindent\showfdipoleifc{optfilter}\hspace{\fill}%
% \showfdipoleifc{polcontrol}\hspace{\fill}%
% \showfdipoleifc{optisolator}%
% \bigskip
%
% \noindent\showfdipoleifc{optswitch}\hspace{\fill}%
% \showfdipoleifc{fiberdelayline}\hspace{\fill}%
% \showfdipoleifc{optfiberpolarizer}%
% \bigskip
%
% \bgroup\psset{beam}
% \noindent\showfdipoleifc{fibercollimator}\egroup
% \hspace{\fill}%
% \begin{pspicture}(0,-0.5)(3,1.4)
%   \pnode(0,1){A}\pnode(3,1){B}\pnode(1.2,-0.1){C}
%   \optcirculator(A)(C)(B)
%   \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[-45](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeOut{})\uput[-45](\oenodeOut{}){N}
%   \rput[bl](0,-0.4){\ttfamily\textbackslash optcirculator}
% \end{pspicture}\hspace{\fill}%
% \begin{pspicture}(3,1)
% \end{pspicture}%
% \bigskip
%
% \noindent
% \begin{pspicture}(0,-0.5)(3,1.5)
%   \pnode(0,0.75){A}\pnode(3,1.5){B}\pnode(3,0){C}
%   \wdmsplitter[couplersize=0.5, couplersep=0.2](A)(B)(C)
%   \psdot(\oenodeIn{})\uput[135](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[90](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeOut{})\uput[-90](\oenodeOut{}){N}
%   \rput[bl](0,-0.4){\ttfamily\textbackslash wdmsplitter}
% \end{pspicture}%
% \hspace{\fill}%
% \begin{pspicture}(0,-0.5)(3,1.5)
%   \pnode(0,1.5){A}\pnode(0,0){B}\pnode(3,0.75){C}
%   \wdmcoupler[couplersize=0.5, couplersep=0.2](A)(B)(C)
%   \psdot(\oenodeIn{})\uput[90](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[-90](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeOut{})\uput[45](\oenodeOut{}){N}
%   \rput[bl](0,-0.4){\ttfamily\textbackslash wdmcoupler}
% \end{pspicture}%
% \hspace{\fill}%
% \begin{pspicture}(0,-0.5)(3,1.5)
%   \pnode(0,1.5){A}\pnode(0,0){B}\pnode(3,1.5){C}\pnode(3,0){D}
%   \optcoupler[couplersize=0.5, couplersep=0.2](A)(B)(C)(D)
%   \psdot(\oenodeIn{})\uput[90](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[-90](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeIfc{3}{})\uput[90](\oenodeIfc{3}{}){3}
%   \psdot(\oenodeOut{})\uput[-90](\oenodeOut{}){N}
%   \rput[bl](0,-0.4){\ttfamily\textbackslash optcoupler}
% \end{pspicture}%
% \egroup
%
% \ifGERMAN
%   \chapter{Beispiele}
% \fi
% \ifENGLISH
%   \chapter{Examples}
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(10.4,1.7)
\newpsobject{mybox}{optbox}{position=end, label=0, optboxwidth=1.2}
\addtopsstyle{Beam}{linewidth=2\pslinewidth}
\pnode(1.2,1){Start}\pnode(9.2,1){CCD}
\begin{optexp}
\mybox(CCD)(Start){Laser}\mybox(Start)(CCD){CCD}
\polarization[poltype=perp,abspos=0.5](Start)(CCD)
\optretplate[abspos=1](Start)(CCD){$\nicefrac{\lambda}{2}$}
\lens[lens=0.4 0.4 0.5,abspos=2](Start)(CCD){$L_1$}
\lens[abspos=4](Start)(CCD){$L_2$}
\optplate[abspos=6, platelinewidth=3\pslinewidth](Start)(CCD){SLM}
\optplate[abspos=6.5, labelangle=180](Start)(CCD){PF}
\polarization[abspos=6.7](Start)(CCD)
\lens[abspos=7](Start)(CCD){$L_3$}
\drawbeam{1}{2}
\end{optexp}
\end{pspicture}
\end{LTXexample}
\bigskip

\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(10.4,1.7)
\newpsobject{mybox}{optbox}{position=end, label=0, optboxwidth=1.2}
\pnode(1.2,1){Start}\pnode(9.2,1){CCD}
\begin{optexp}
\mybox(CCD)(Start){Laser}
\polarization[poltype=perp,abspos=0.5](Start)(CCD)
\optretplate[abspos=1](Start)(CCD){$\nicefrac{\lambda}{2}$}
\lens[lens=0.4 0.4 0.5,abspos=2](Start)(CCD){$L_1$}
\pinhole[phwidth=0.05, abspos=2.35, labelangle=180](Start)(CCD){iris}
\lens[abspos=4](Start)(CCD){$L_2$}
\optplate[abspos=6,platelinewidth=3\pslinewidth](Start)(CCD){SLM}
\optplate[abspos=6.5,labelangle=180](Start)(CCD){PF}
\lens[abspos=7](Start)(CCD){$L_3$}\mybox(Start)(CCD){CCD}
\polarization[abspos=6.7, polsize=0.8](Start)(CCD)
\psset{loadbeampoints}
\addtopsstyle{Beam}{fillstyle=solid,fillcolor=green, opacity=0.3}
\drawwidebeam[beamwidth=0.1, stopinside]{1}{4}
\drawwidebeam[beamdiv=-20]{4}{6}
\drawwidebeam[stopinside]{6-9}
\drawwidebeam[beamdiv=-30]{9-10}
\end{optexp}
\end{pspicture}
\end{LTXexample}
\bigskip

\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(-4.2,-1)(3,3)
\pnode(-2,0){LOut}\pnode(0,0){Grat}\pnode(4;45){Out}\pnode(2.5;70){Mvar}
\newpsstyle{Beam}{linewidth=2\pslinewidth, linecolor=red!90!black}
\begin{optexp}
  \optbox[optboxwidth=2.2, labeloffset=0, position=start](LOut)(Grat){diode laser}
  \mirror[variable](Grat)(Mvar)(Grat){M$_\mathrm{var}$}
  \optretplate[position=0.3](LOut)(Grat){$\nicefrac{\lambda}{4}$}
  \optgrating(LOut)(Grat)(Out){grating}
  \drawbeam[arrows=->]{1}{3}{4}{(Out)}
  \drawbeam{2}{4}
\end{optexp}
\rput[l](-3,2){Littman setup}
\end{pspicture}
\end{LTXexample}
\bigskip

\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(8.5,1.9)
\pnode(1.4,1.3){Laser}\pnode(7.6,1.3){Diode}
\optbox[position=start, labeloffset=0](Laser)(Diode){Laser}%
\optbox[abspos=4, optboxsize=1 0.6, labeloffset=1, n=3,
        compname=PC, angle=-10, rotateref=l](Laser)(Diode){Photonic Crystal}
\optdetector[dettype=diode](\oenodeOut{PC})(Diode|\oenodeOut{PC}){PD}
\nodexn{(\oenodeIn{PC}) + (2;170)}{Angle1}
\psline[linestyle=dashed](\oenodeIn{PC})(Angle1)
\psarc{<->}(\oenodeIn{PC}){1.3}{330}{30}
\psarc[arcsep=1pt]{<->}(\oenodeIn{PC}){2}{170}{180}
\uput{2.1}[175](\oenodeIn{PC}){\small $\varphi$}
\drawbeam{-}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(0.1,0.4)(10,5)
  \psset[optexp]{lens=1 1 0.7, loadbeampoints}
  \pnode(2,4){L}\pnode([Xnodesep=4]L){M}
  \pnode([Xnodesep=1.5]M){IRSpec}\pnode([offset=-2.5]M){OSA}
  \begin{optexp}
  \optbox[position=start, innerlabel](L)(M){fs laser}
  \lens[abspos=1](L)(M)
  \optbox[abspos=1.85, optboxsize=0.7 0.15, fillstyle=solid, fillcolor=black](L)(M){sample}
  \lens[abspos=2.7](L)(M)
  \mirror[labelangle=45](L)(M)(OSA){flip mirror}
  \optbox[position=end, optboxsize=3 1, innerlabel, compshift=-0.2](M)(IRSpec){IR spectrometer}
  \lens[abspos=1](M)(OSA)
  \optplane([offset=-1.5]M)
  \newpsstyle{Fiber}{linewidth=2\pslinewidth}
  \optfiber[fiberloopradius=0.2, fiberloopsep=0.2, label=1]([offset=-1.5]M)(OSA){MM fiber}
  \optbox[position=end, innerlabel, optboxwidth=1.1](M)(OSA){OSA}
  \newpsstyle{Beam}{linestyle=none, fillcolor=red, fillstyle=solid, raytrace=false}
  \drawwidebeam[beamwidth=0.2, stopinside]{1-2}
  \drawwidebeam[beamdiv=-25]{2-3}
  \drawwidebeam[loadbeampoints=false, beamdiv=25]{3-4}
  \drawwidebeam[startinside]{4-5}
  \drawwidebeam[savebeampoints=false, beamalign=abs]{5-6}
  \drawwidebeam[stopinside]{5}{7}
  \drawwidebeam[beamdiv=-25]{7-8}
\end{optexp}
\end{pspicture}
\end{LTXexample}

%^^A An idea from <http://arxiv.org/abs/1112.5270>
\enlargethispage{3cm}
\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(0.3,0.6)(5.5,7.8)
\newOptexpTripole{reflslm}{}
\makeatletter
\def\reflslm@comp{%
  \psframe[fillstyle=solid,fillcolor=gray!50](-0.3,0)(0.3,0.2)
  \psline(-0.3,0.1)(-0.5,0.1)(-0.5,0.5)(0.5,0.5)(0.5,0.1)(0.3,0.1)}%
\makeatother
\pnode(2,7){L}\pnode(2,5.8){Pbs}\pnode([Xnodesep=1]Pbs){Blk1}\pnode(2,2.3){Bs}
\pnode([Xnodesep=-1]Bs){Blk2}\pnode([Xnodesep=3.5]Bs){Out}\pnode(2,1.3){Slm}
\begin{optexp}
  \optbox[position=end, innerlabel, optboxsize=1.2 0.6](Pbs)(L){Laser}
  \psset{labelalign=r, mirrortype=extended}
  \newpsstyle{ExtendedMirror}{fillstyle=solid, fillcolor=black}
  \optretplate[position=0.4](L)(Pbs){HWP}
  \beamsplitter[labelangle=-90](L)(Pbs)(Blk1){PBS}
  \mirror[label=. -90 c](Pbs)(Blk1)(Pbs){B}
  \lens[abspos=0.8, lens=0.7 0.7 0.7, n=2](Pbs)(Bs){MO}
  \pinhole[phwidth=0.15, abspos=1.2](Pbs)(Bs){PH}
  \lens[abspos=2.6, lensradius=1.4](Pbs)(Bs){L}
  \psset{labelalign=c}
  \beamsplitter[labelangle=-135](Pbs)(Bs)(Blk2){BS}
  \mirror[labeloffset=0.4](Bs)(Blk2)(Bs){B}
  \lens[abspos=1, lensradius=1.4](Bs)(Out){L}
  \lens[abspos=2.8, lens=0.7 0.7 0.7, n=2](Bs)(Out){L}
  \reflslm(Bs)(Slm)(Bs){SLM}
  \addtopsstyle{Beam}{linestyle=none, fillstyle=solid, fillcolor=green!70!black}
  \drawwidebeam[beamwidth=0.1]{1-4}
  \drawwidebeam[beamwidth=0.1, beaminsidefirst, beaminsidelast]{3}{5-8}
  \psset{savebeampoints=false, loadbeampoints}
  \drawwidebeam{8-11}{(Out)}\drawwidebeam[beaminsidefirst]{8}{12}
\end{optexp}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(6.4,3.2)
\addtopsstyle{Fiber}{linecolor=red}\psset{fiber=none}
\pnode(2.3,2.3){Lin}\pnode([Xnodesep=4.5]Lin){Det}
\optbox[label=0.2, position=start, compname=L, extnode=b](Lin)(Det){%
  \psGauss[yunit=0.03,sigma=0.03]{-0.5}{0.5}}
\optbox[label=0, compname=EAM, extnode=b, abspos=1.5](Lin)(Det){EAM}
\optfiber[labeloffset=0.3, abspos=3.2](Lin)(Det){fibre}
\optdetector(Lin)(Det){OSA}
\pnode([Xnodesep=-1,offset=-1]\oenodeExt{L}){Osc}
\pnode(\oenodeExt{L}|Osc){PSin}\pnode(\oenodeExt{EAM}|Osc){PSout}
\oscillator[output=right](Osc){10\,GHz}{}
\phaseshifter[arrowscale=1.5, inputarrow, labeloffset=-0.7](PSin)(PSout){$\tau$}
\drawfiber{1}{2}{3}{4}
\psset{arrows=->, arrowinset=0, arrowscale=1.5}
\wire(PSin)(\oenodeExt{L})\wire(PSout)(\oenodeExt{EAM})
\end{pspicture}
\end{LTXexample}

\enlargethispage{1cm}
\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(0.4,0.6)(8.2,3.5)
\pnode(2,3){Laser}\pnode(2,1){PwMeter}\pnode(6,3){CplTop}\pnode(6,1){CplBot}
\psset{arrowscale=1.5, arrowinset=0}
\optbox[position=start, optboxsize=1.6 1, labeloffset=0](Laser)([Xnodesep=0.1]Laser){%
  \begin{tabular}{@{}c@{}}Nd:YAG\\[-0.4ex]cw laser\end{tabular}}
\optcoupler[addtoFiberIn1={ArrowInside=->}, addtoFiberIn2={ArrowInside=-<},
            labeloffset=0.4](Laser)(PwMeter)(CplTop)(CplBot){WDM}
\optfiber[addtoFiberOut={ncurv=1, angleB=0}, addtoFiberIn={ncurv=1, angleA=0}, 
          compshift=-1, label=0.2 . l](CplBot)(CplTop){fiber}
\optdetector[dettype=diode]([Xnodesep=0.1]PwMeter)(PwMeter){power meter}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(0.9,0.9)(10.4,5.9)
\psset{arrowscale=1.5, arrowinset=0}
\pnode(2,5){PC1in}\pnode(4,5){PC1out}\pnode(6,5){PC2in}
\pnode(8,5){PC2out}\pnode(2,2){CplSig}\pnode(5,2){CplIn}
\pnode(2,1){CplOut}\pnode(10,4.5){Pump}\pnode(8,2){PumpSig}
\optisolator[compshift=0.8, addtoFiberIn={angleA=180}, 
             addtoFiberOut={angleB=180}, label=0.5 . l]%
             (CplSig)(PC1in){isolator}
\polcontrol[addtoFiberIn={arrows=|-}](PC1in)(PC1out){}
\optfiberpolarizer[labeloffset=0.6](PC1out)(PC2in){polarizer}
\polcontrol[addtoFiberOut={arrows=-|}](PC2in)(PC2out){}
\wdmsplitter[labeloffset=0.3, coupleralign=bottom, addtoFiberIn={arrows=|-}, 
             addtoFiberOut1={arrows=->}, addtoFiberOut2={arrows=-|}]%
             (CplIn)(CplOut)(CplSig){95/5}
\wdmcoupler[addtoFiberIn1={ArrowInside=->}, addtoFiberIn2={angleA=0}, 
            addtoFiberOut={angleB=0,arrows=-|}, ncurv=0.9, 
            coupleralign=bottom, compshift=0.8](Pump)(PC2out)(PumpSig){pump}
\optbox[position=start, innerlabel](Pump)([offset=-0.1]Pump){980~nm}
\optfiber[fiberloops=2, labeloffset=0.4](CplIn)(PumpSig){Er$^+$-doped}
\end{pspicture}
\end{LTXexample}
\bigskip

\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(1,1.2)(6.2,5)
\pnode(1,4){SigIn}\pnode(3,4){BS}\pnode(3,5){LO}
\pnode(5,4){Det1}\pnode(3,2){Det2}
\begin{optexp}
  \optplane[compname=LO, angle=90](LO)
  \beamsplitter[compname=BS](SigIn)(BS)(Det2)
  \lens[abspos=0.5, compname=L2, n=2.1](Det2)(BS){$L_2$}
  \lens[abspos=0.5, compname=L1, n=2.1](Det1)(BS){$L_1$}
  \psset[optexp]{extnodealign=rel, extnode=r}
  \optdetector[compname=Det1](BS)(Det1){PD1}
  \optdetector[compname=Det2](BS)(Det2){PD2}
  \addtopsstyle{Beam}{beamwidth=0.2, fillstyle=solid, 
                        fillcolor=green, opacity=0.2}
  \drawwidebeam{(SigIn)}{BS}{L2}{Det2}
  \drawwidebeam[beaminsidefirst]{BS}{L1}{Det1}
  \newpsstyle{Beam}{linecolor=red, linestyle=dashed, linewidth=1.5\pslinewidth}
  \drawbeam{LO}{BS}{L1}{Det1}
  \drawbeam[beaminsidefirst]{BS}{L2}{Det2}
\end{optexp}
\cnodeput([Xnodesep=0.5, offset=-0.5]\oenodeExt{Det1}|\oenodeExt{Det2})%
           {M}{\rule{3mm}{1pt}}
\psset{arrows=<-, arrowscale=1.5, arrowinset=0}
\nccurve[angleA=90]{M}{\oenodeExt{Det1}}
\nccurve[angleA=180, angleB=-90]{M}{\oenodeExt{Det2}}
\end{pspicture}
\end{LTXexample}
\bigskip

\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(-0.2,0)(9,5)
\makeatletter
\def\LCLV@nodes{%
  \newOptexpComp{ {-0.12 0} {0 1} -0.5 0.5 trans {PlainIfc}
                  {0.15 0} {0 1} -0.5 0.5 trans {PlainIfc} \POE@key@n}%
}%
\def\LCLV@comp{%
  \psframe[fillstyle=solid,fillcolor=black,dimen=outer](-0.12,-0.5)(0,0.5)
  \psframe[fillstyle=solid,fillcolor=gray!50,dimen=outer](0,-0.5)(0.15,0.5)
}%
\makeatother
\newOptexpDipole{LCLV}{}\psset{lens=1.2 0 1.2, n=1.72}
\addtopsstyle{Beam}{fillstyle=solid, fillcolor=green, opacity=0.3}
\pnode(2.4,1){BS1}\pnode([offset=3]BS1){M1}
\pnode([Xnodesep=5.5]M1){PP}\pnode(PP|BS1){BS2}
\begin{optexp}
  \optbox[label=0, position=start, optboxwidth=1.6]([Xnodesep=-1]BS1)(BS1){Nd:YAG}
  \beamsplitter[compname=BS](BS2)(BS1)(M1){BS}
  \LCLV[position=0.2, compname=LCLV](BS1)(BS2){LCLV}
  \optretplate(BS1)(M1){P}
  \mirror(BS1)(M1)(PP){M}
  \lens[position=0.2](M1)(PP){L}
  \pinhole(M1)(PP){}
  \lens[position=0.2](PP)(M1){L}
  \pentaprism(M1)(PP)(BS2){PP}
  \beamsplitter(PP)(BS2)(BS1){BS}
  \doveprism[compname=Dove, position=0.27, n=2.3](BS2)(BS1){Dove}
  \lens[n=2.5](BS2)(BS1){L}
  \drawwidebeam[beamwidth=0.3]{1-3}
  \drawwidebeam[loadbeampoints]{3}{2}{4-}{3}
\end{optexp}
\end{pspicture}
\end{LTXexample}

\enlargethispage{1cm}
\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(0,-0.2)(8.6,5.6)
\pnode(1.5,5){Laser}\pnode(4,5){PBS}\pnode(6.5,5){PBS2}\pnode(6.5,5.7){piezo}
\pnode(4,2){BSFwd}\pnode(6.5,2){BSBwd}\pnode(2,2){BS4f}\pnode(2,0.5){M4f3}
\pnode(8,2){M4f1}\pnode(8,0.5){M4f2}\pnode(1,2){CCD}
\psset{mirrorwidth=0.6, plateheight=0.7, outerheight=0.7, labeloffset=0.7, labelstyle=\scriptsize, lens=1.2 1.2 0.8, bssize=0.5} 
\optbox[position=start, optboxsize=1.5 0.7, innerlabel]% 
   (Laser)(PBS){\parbox{1.5cm}{\centering Nd:YAG\\ 532\,nm}}
\lens[lensheight=0.5, position=0.2](Laser)(PBS){MO}
\pinhole[position=0.3,labelangle=180](Laser)(PBS){PH}
\lens[position=0.5](Laser)(PBS){L}
\optretplate[position=0.8](Laser)(PBS){$\nicefrac{\lambda}{2}$}
\beamsplitter(Laser)(PBS)(BSFwd){PBS}
\optretplate[position=0.4](PBS)(BSFwd){$\nicefrac{\lambda}{2}$}
\polarization(PBS)(BSFwd)\polarization(PBS2)(BSBwd)
\lens[position=0.8](PBS)(BSFwd){L}
\optretplate(PBS)(PBS2){$\nicefrac{\lambda}{2}$}
\beamsplitter(PBS)(PBS2)(piezo){PBS}
\optretplate[abspos=0.5](PBS2)(piezo){$\nicefrac{\lambda}{4}$}
\mirror[mirrortype=piezo,labelangle=90](PBS2)(piezo)(PBS2){PZ}
\lens[position=0.8,labelangle=180](PBS2)(BSBwd){L}
\crystal[crystalwidth=1, crystalheight=0.5, voltage, lamp, fillstyle=solid, fillcolor=yellow!90!black, labeloffset=0.8](BSFwd)(BSBwd){SBN:Ce}
\beamsplitter(PBS)(BSFwd)(BSBwd){BS}
\beamsplitter[labelangle=-90](PBS2)(BSBwd)(BSFwd){BS}
\mirror(BSBwd)(M4f1)(M4f2){M}\mirror(M4f1)(M4f2)(M4f3){M}
\lens[labelangle=180](M4f2)(M4f3){L}\mirror(M4f2)(M4f3)(BS4f){M}
\beamsplitter(M4f3)(BS4f)(CCD){BS}
\optbox[position=end, label=0, optboxwidth=1](BS4f)(CCD){CCD}
\lens[abspos=0.7](BS4f)(BSFwd){L}\lens[abspos=0.7](BSBwd)(M4f1){L}
\addtopsstyle{Beam}{linewidth=2\pslinewidth}
\drawbeam{1-6}{11-14}{13}{12}{15}{18}{16}{17}{25}{23}{24}
\drawbeam[beaminsidefirst]{6}{7}{10}{17}{16}{18}{26}{19-24}
\end{pspicture}
\end{LTXexample}

\bgroup
\psset{unit=0.9}
\begin{LTXexample}[pos=t, caption={caption}, label=ex:transmission-loop]
\begin{pspicture}(13,5.5)
\psset{usefiberstyle, optboxwidth=1, labelstyle=\footnotesize, fiber=none}
\pnode(1,5){LD}\pnode([Xnodesep=5.5]LD){CPLin1}
\pnode([offset=-2]CPLin1){CPLin2}\pnode([Xnodesep=2.5]CPLin1){CPLout1}
\pnode([Xnodesep=2.5]CPLin2){CPLout2}\pnode([Xnodesep=3]CPLout1){RX}
\optbox[position=start, label=0](LD)(CPLin1){LD}
\optmzm[abspos=0.8](LD)(CPLin1){MZM}
\optamp[abspos=2](LD)(CPLin1){EDFA}
\optfilter[abspos=3](LD)(CPLin1){BPF}
\optswitch[abspos=4](LD)(CPLin1){SW}
\polcontrol[abspos=5, fiber=out](LD)(CPLin1)
\drawfiber{1}{2}{3}{4}{5}{6}
\optcoupler[couplertype=none, fiber](CPLin1)(CPLin2)(CPLout1)(CPLout2)
\optamp[abspos=0.8, fiber=in](CPLout1)(RX){EDFA}
\optfilter[abspos=2](CPLout1)(RX){BPF}
\optbox[position=end](CPLout1)(RX){RX}
\drawfiber{8}{9}{10}
\pnode([Xnodesep=-0.5]LD|CPLin2){TL}\pnode(RX|TL){TR}
\pnode([offset=-2.5]TR){BR}\pnode(TL|BR){BL}
\optamp[fiber=i](CPLout2)(TR){EDFA}
\optfiber[label=0.3 . t, position=0.85](BL)(BR){SSMF 89.8~km}
\drawfiber[fiberstyle=angle, arm=1.2, linearc=0.5, startnode=N]{11}{12}
\optamp[position=0.3](BR)(BL){EDFA}
\optfilter[position=0.55, labelangle=180](BL)(BR){BPF}
\optfiber[fiberloops=1, label=0.3 . t, position=0.35](BL)(BR){DCF 16.2~km}
\optamp[position=0.85](BR)(BL){EDFA}
\optfilter[position=0.2](TL)(CPLin2){BPF}
\optswitch(TL)(CPLin2){SW}
\polcontrol[position=0.8, fiber=out](TL)(CPLin2)
\drawfiber{12}{13}{14}{15}{16}\drawfiber{17}{18}{19}
\drawfiber[fiberstyle=angle, arm=0.5, linearc=0.5, stopnode=1]{16}{17}
\end{pspicture}
\end{LTXexample}
\egroup

\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(12, 4)
  \psset{labeloffset=0.3}
  \pnode(1.6,2){In}\pnode(12, 2){Ref}
  \optplate[linestyle=dashed, plateheight=3, 
              position=1, compname=RefPlane](In)(Ref)
  \addtopsstyle{Beam}{linestyle=none, beamdiv=20, beaminside=false, 
                        fillstyle=solid, fillcolor=red, opacity=0.3}
  \multido{\i=1+1, \ii=165+10}{4}{%
    \rput(Ref){\pnode(6;\ii){A\i}}
    \optbox[optboxsize=0.5 0.3, position=end, compname=Box\i, extnode=l](Ref)(A\i)
    \lens[lens=0 -0.6 0.6, abspos=0.5, compname=L\i](A\i)(Ref)
    \lens[lens=1.2 1.2 0.8, abspos=1.1, n=1.65, compname=LC\i](A\i)(Ref)
    \drawwidebeam{Box\i}{L\i}{LC\i}{RefPlane}
  }%
  \psset{fiber=none}
  \optcoupler[abspos=1](In)(In)(Ref)(Ref)
  \wdmsplitter[abspos=2.5, compshift=1](In)(Ref)(Ref)
  \wdmsplitter[abspos=2.5, compshift=-1](In)(Ref)(Ref)
  \optbox[compshift=-1, position=start, label=0](In)(Ref){Laser1}
  \optbox[compshift=1, position=start, label=0](In)(Ref){Laser2}
  \drawfiber{17}{14}{15}{Box1}
  \drawfiber{15}{Box2}
  \drawfiber{18}{14}{16}{Box3}
  \drawfiber{16}{Box4}
\end{pspicture}
\end{LTXexample}
\bigskip

\begin{LTXexample}[pos=t, caption={caption}]
\begin{pspicture}(0,-1)(8,4)
\psframe[fillstyle=solid,fillcolor=gray!90,linestyle=none](0,-1)(8.5,4)
\addtopsstyle{OptComp}{linecolor=white}\newpsstyle{Beam}{}
\addtopsstyle{ExtendedMirror}{hatchcolor=white, hatchsep=0.5\pslinewidth}
\pnode(0,3){A}\pnode(8,3){B}\pnode(3,1.5){C}\pnode(8,0){D}\pnode(0,0){E}%
\psset{linewidth=1.5\pslinewidth, mirrorradius=13,  mirrorwidth=1.5, gratingwidth=1.5, mirrortype=extended, phwidth=0.07, outerheight=1.5}%
\begin{optexp}
  \pinhole[position=0.2](A)(B)%
  \mirror(A)(B)(C)
  \optgrating[reverse, angle=15](B)(C)(D)
  \mirror(C)(D)(E)
  \pinhole[position=0.8](D)(E)
  \drawwidebeam[ArrowInside=->, beamwidth=0.2, linecolor=white,
                  beamdiv=0.1 8 0.2 mul atan neg 2 mul]{(A)}{1-3}
  \psset{loadbeampoints, savebeampoints=false}%
  \drawwidebeam[linecolor=green!60!white]{3-5}{(E)}
  \drawwidebeam[beamangle=3, linecolor=blue!60!white]{3-6}
  \drawwidebeam[beamangle=-3, linecolor=red!60!white]{3-6}
\end{optexp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \makeatletter
% \bgroup
% \newcommand*{\index@preamble}{}
% \let\index@preamble=\relax
% \renewcommand{\setindexpreamble}[1]{\def\index@preamble{#1}}
% \renewcommand*{\idx@heading}{%
%   \twocolumn[\idx@@heading{\indexname}]%
%   \@mkboth{\indexname}{\indexname}%
% }
% \renewenvironment{theindex}{%
%   \if@twocolumn
%     \@restonecolfalse
%   \else
%     \@restonecoltrue
%   \fi
%   \columnseprule \z@
%   \columnsep 35\p@
%   \idx@heading%
%   \index@preamble\par\nobreak
%   \thispagestyle{\indexpagestyle}\parindent\z@
%   \setlength{\parskip}{\z@ \@plus .3\p@}%
%   \setlength{\parfillskip}{\z@ \@plus 1fil}%
%   \let\item\@idxitem
% }{%
%   \if@restonecol\onecolumn\else\clearpage\fi
% }
% \renewcommand*\@idxitem{\par\hangindent 40\p@}
% \renewcommand*\subitem{\@idxitem \hspace*{20\p@}}
% \renewcommand*\subsubitem{\@idxitem \hspace*{30\p@}}
% \renewcommand*\indexspace{%
%   \par \vskip 10\p@ \@plus5\p@ \@minus3\p@\relax
% }
% \renewcommand*\indexname{Index}
% \printindex[doc]
% \egroup
% \makeatother
%
% \appendix
%
% \ifGERMAN
% \chapter{Versionsgeschichte}
%
% Diese Versionsgeschichte ist eine Liste von Änderungen, die für den Nutzer des
% Pakets von Bedeutung sind. Änderungen, die eher technischer Natur sind und für
% den Nutzer des Pakets nicht relevant sind und das Verhalten des Pakets nicht
% ändern, werden nicht aufgeführt. Wenn ein Eintrag der Versionsgeschichte ein
% Feature als \emph{improved} oder \emph{extended} bekannt gibt, so bedeutet dies,
% dass eine Modifikation die Syntax und das Verhalten des Pakets nicht
% beeinflusst, oder das es für ältere Versionen kompatibel ist. Einträge, die
% als \emph{modified}, \emph{renamed}, oder \emph{removed} deklariert sind,
% verlangen besondere Aufmerksamkeit. Diese bedeuten, dass eine Modifikation
% Änderungen in bereits existierenden Stilen oder Dokumenten mit sich zieht. Die
% Zahlen an der rechten Seite stehen für die relevante Stelle dieser
% Dokumentation.
% \fi
% \ifENGLISH
% \chapter{Revision history}
%
% This revision history is a list of changes relevant to users of this
% package. Changes of a more technical nature which do not affect the user
% interface or the behavior of the package are not included in the list. If an
% entry in the revision history states that a feature has been \emph{improved}
% or \emph{extended}, this indicates a modification which either does not affect
% the syntax and behavior of the package or is syntactically backwards
% compatible (such as the addition of an optional argument to an existing
% command). Entries stating that a feature has been \emph{modified},
% \emph{renamed}, or \emph{removed} demand attention. They indicate a
% modification which may require changes to existing styles or documents in
% some, hopefully rare, cases. The numbers on the right indicate the relevant
% section of this manual.
% \fi
%
% \begin{changelog}
%
%   \begin{release}{3.0}{2011-00-00}
%   \item Removed deprecated lens code\see{cmd:lens}
%   \item Added option \opt{phwidth}\see{cmd:pinhole}
%   \item Modified option \opt{caxislength}\see{cmd:crystal}
%   \item Added style \opt{CrystalCaxis}\see{cmd:crystal}
%   \item Added style \opt{CrystalLamp}\see{cmd:crystal}
%   \item Deprecated option \opt{lampscale}\see{cmd:crystal}
%   \item Added option \opt{optboxsize}\see{cmd:optbox}
%   \item Extended option \opt{detsize}\see{cmd:optdetector}
%   \item Added style \opt{DetectorStyle}\see{cmd:optdetector}
%   \item Extended option \opt{doveprismsize}\see{cmd:doveprism}
%   \item Added style \opt{Polarization}\see{cmd:polarization}
%   \item Deprecated option \opt{pollinewidth}\see{cmd:polarization}
%   \item Removed option \opt{polwidth}\see{cmd:polarization}
%   \item Removed option \opt{pol}\see{cmd:polarization}
%   \item Added style \opt{VariableMirror}\see{cmd:mirror}
%   \item Renamed \cs{optgrid} to \cs{optgrating}\see{cmd:optgrating}
%   \item Renamed \opt{optgridwidth} to \opt{gratingwidth}\see{cmd:optgrating}
%   \item Removed option \opt{labelrelative}\see{sec:labels}
%   \item Removed option \opt{iwidth}\see{cmd:pinhole}
%   \item Removed option \opt{owidth}\see{cmd:pinhole}
%   \item Removed option \opt{bswidth}\see{cmd:beamsplitter}
%   \item Deprecated \cs{newOptexpDipoleNolabel}, use \cs{newOptexpDipole}\see{sec:newobj}
%   \item Extended use of \opt{angle} and \opt{rotateref} to all components\see{sec:rotshift}
%   \item Deprecated option \opt{refractiveindex}\see{sec:drawbeam}
%   \item Renamed option \opt{refractiveindex} to \opt{n}\see{sec:drawbeam}
%   \item Deprecated option \opt{conn}\see{sec:drawbeam}
%   \end{release}
%   \begin{release}{2.1}{2009-11-05}
%   \item Added component \cs{optfiberpolarizer}\see{cmd:optfiberpolarizer}
%   \item Added option \opt{compshift}\see{sec:rotshift}
%   \item Added option \opt{label}\see{sec:labels}
%   \item Added option \opt{connjoin}
%   \item Added options \opt{addtoBeam} and \opt{newBeam}\see{sec:drawbeam}
%   \item Added options \opt{addtoOptComp} and \opt{newOptComp}\see{sec:appearance}
%   \item Added option \opt{bsstyle} to \cs{beamsplitter}\see{cmd:beamsplitter}
%   \item Extended \cs{fibercollimator}\see{cmd:fibercollimator}
%   \item Use pst-doc class for the documentation
%   \item Improved \opt{thicklens} to work with plain lenses\see{cmd:lens}
%   \end{release}
%
%   \begin{release}{2.0}{2008-07-27}
%     \item Added fiber-optical components\see{chap:fibercomp}
%     \item Added component \cs{optdiode}\see{cmd:optdiode}
%     \item Added component \cs{pentaprism}\see{cmd:pentaprism}
%     \item Added component \cs{rightangleprism}\see{cmd:rightangleprism}
%     \item Added component \cs{doveprism}\see{cmd:doveprism}
%     \item Added component \cs{optprism}\see{cmd:optprism}
%     \item Added \cs{drawbeam}\see{sec:drawbeam}
%     \item Added component connections (options \opt{fiber}, \opt{conn} and \opt{beam})\see{chap:connecting}
%     \item Added option \opt{compname}\see{sec:namingobj}
%     \item Added option \opt{extnode}\see{sec:extnode}
%     \item Deprecated \cs{detector}\see{cmd:optdetector}
%     \item Renamed \cs{detector} to \cs{optdetector}\see{cmd:optdetector}
%   \end{release}
%   \begin{release}{1.2}{2008-06-17}
%   \item Modified lens design\see{cmd:lens}
%   \item Added options \opt{lensradiusleft} and \opt{lensradiusright}\see{cmd:lens}
%   \item Added option \opt{thicklens}\see{cmd:lens}
%   \item Added option \opt{lenstype}\see{cmd:lens}
%   \item Added option \opt{mirrorradius} (curved mirrors)\see{cmd:mirror}
%   \item Added option \opt{optgridtype} (binary gratings)\see{cmd:optgrating}
%   \item Added \cs{newOptexpDipole}\see{sec:newobj}
%   \item Added \cs{newOptexpDipoleNolabel}\see{sec:newobj}
%   \item Added \cs{newOptexpTripole}\see{sec:newobj}
%   \item Added \cs{newOptexpFiberDipole}\see{sec:newobj}
%   \item General improvements of \TeX{} and Postscript code
%   \end{release}
%   \begin{release}{1.1}{2007-09-06}
%   \item Improved labeling features\see{sec:labels}
%   \item Added parameter \opt{labelref}\see{sec:labels}
%   \item Replaced \opt{labelrelative} by \opt{labelref=relative}\see{sec:labels}
%   \item Renamed \cs{polarisation} to \cs{polarization}\see{cmd:polarization}
%   \item Renamed \opt{polwidth} to \opt{polsize}\see{cmd:polarization}
%   \item Renamed \opt{pol} to \opt{poltype}\see{cmd:polarization}
%   \item Renamed \opt{bswidth} to \opt{bssize}\see{cmd:beamsplitter}
%   \item Renamed \opt{iwidth} to \opt{innerheight}\see{cmd:pinhole}
%   \item Renamed \opt{owidth} to \opt{outerheight}\see{cmd:pinhole}
%   \item Added support for fillstyle for all components
%   \end{release}
%
%   \begin{release}{1.0}{2007-07-18}
%   \item First CTAN version
%   \end{release}
% \end{changelog}
%
% \StopEventually{}
%
%
% \chapter{The \LaTeX/\TeX\ implementation}
%<*stylefile>
% \section{Requirements}
%    \begin{macrocode}
\RequirePackage{pstricks}
\RequirePackage{pst-xkey}
\RequirePackage{pst-node}
\RequirePackage{pst-plot}
\RequirePackage{multido}
\RequirePackage{pst-eucl}
\RequirePackage{pstricks-add}
\RequirePackage{environ}
%    \end{macrocode}
% Add the Postscript header file.
%    \begin{macrocode}
\@addtofilelist{pst-optexp.pro}{}%
\pst@addfams{optexp}
\pstheader{pst-optexp.pro}
%    \end{macrocode}
% This holds a comma-separated list of all component names which are defined in
% a \nxLenv{pspicture} environment. This list is cleared when leaving the
% \nxLenv{pspicture}.
%    \begin{macrocode}
\gdef\POE@complist{}%
\gdef\POE@beamlist{1}%
\g@addto@macro{\endpspicture}{%
%    \end{macrocode}
%
% Undefine all beam nodes at the end of the \nxLenv{pspicture}.
%    \begin{macrocode}
  \expandafter\XKV@for@n\expandafter{\POE@beamlist}\POE@temp{%
    \POE@Verb{%
      /lastBeamPointUp\POE@temp\space 
      /lastBeamPointLow\POE@temp\space 
      /lastBeamPoint\POE@temp\space 
      3 { currentdict exch undef } repeat 
      /N@\oenodeBeam{\POE@temp} 
      /N@\oenodeBeamUp{\POE@temp} 
      /N@\oenodeBeamLow{\POE@temp}
      3 { tx@NodeDict exch undef } repeat
    }%
  }%
%    \end{macrocode}
%
% Reset the component list.
%
%    \begin{macrocode}
  \gdef\POE@complist{}\gdef\POE@beamlist{1}\global\POE@cnt=0\relax
}%
%    \end{macrocode}
% Some convenience definitions.
%    \begin{macrocode}
\def\pst@optexpdict{tx@OptexpDict begin }
\def\POE@dict#1{\pst@optexpdict #1 end}
\SpecialCoor
%    \end{macrocode}
% \section{Basic definitions}
%
% \subsection{Switches for the boolean keys}
% See respective key definitions for explanation.
%    \begin{macrocode}
\newif\ifPOE@connjoin
\newif\ifPOE@backlayer
\newif\ifPOE@frontlayer
\newif\ifPOE@optexpenv
\newif\ifPOE@variable
\newif\ifPOE@voltage
\newif\ifPOE@caxisinv
\newif\ifPOE@reverse
\newif\ifPOE@lamp
\newif\ifPOE@component@optional
\newif\ifPOE@debug@showoptdots
\newif\ifPOE@debug@showifcnodes
\newif\ifPOE@endbox
\newif\ifPOE@startbox
\newif\ifPOE@thicklens
\newif\ifPOE@usefiberstyle
\newif\ifPOE@fiber@
\newif\ifPOE@nofiber@
\newif\ifPOE@fiberin@
\newif\ifPOE@fiberin@top
\newif\ifPOE@fiberin@bottom
\newif\ifPOE@fiberout@
\newif\ifPOE@fiberout@top
\newif\ifPOE@fiberout@bottom
\newif\ifPOE@beam
\newif\ifPOE@startinside
\newif\ifPOE@stopinside
\newif\ifPOE@beaminsidefirst
\newif\ifPOE@beaminsidelast
\newif\ifPOE@savebeam
\newif\ifPOE@loadbeam
\newif\ifPOE@beaminside
\newif\ifPOE@raytrace
\newif\ifPOE@pswarning
%    \end{macrocode}
% This is to check if \nxLkeyword{compname} is set inside or outside of a component. For this no boolean key is provided.
%    \begin{macrocode}
\newif\ifPOE@insideobj\POE@insideobjfalse
%    \end{macrocode}
% \subsection{Counters}
% Count the components in one \nxLenv{pspicture} environment.
%    \begin{macrocode}
\newcount\POE@cnt
\newcount\POE@oldcnt
%    \end{macrocode}
% Count the temporal planes which are created for connections to nodes.
%    \begin{macrocode}
\newcount\POE@nodecnt
%    \end{macrocode}
%    \begin{macrocode}
\newdimen\POE@dim
%    \end{macrocode}
% \subsection{Fixed strings}
% These are all the fixed strings which are used as possible values for
% choicekeys.
%    \begin{macrocode}
\def\POE@str@pol@polperp{perp}
\def\POE@str@pol@polparallel{parallel}
\def\POE@str@pol@polmisc{misc}
\def\POE@str@pol@polrcirc{rcirc}
\def\POE@str@pol@pollcirc{lcirc}
\def\POE@str@mirrortype@piezo{piezo}
\def\POE@str@mirrortype@plain{plain}
\def\POE@str@mirrortype@extended{extended}
\def\POE@str@gratingtype@blazed{blazed}
\def\POE@str@gratingtype@binary{binary}
\def\POE@str@relative{relative}
\def\POE@str@absolute{absolute}
\def\POE@str@labelref@relgrav{relgrav}
\def\POE@str@labelref@global{global}
\def\POE@str@filtertype@bandpass{bandpass}
\def\POE@str@filtertype@bandstop{bandstop}
\def\POE@str@filtertype@lowpass{lowpass}
\def\POE@str@filtertype@highpass{highpass}
\def\POE@str@couplertype@none{none}
\def\POE@str@couplertype@ellipse{ellipse}
\def\POE@str@couplertype@elliptic{elliptic}
\def\POE@str@couplertype@rectangle{rectangle}
\def\POE@str@couplertype@crossswitch{crossswitch}
\def\POE@str@polcontroltype@linear{linear}
\def\POE@str@polcontroltype@triangle{triangle}
\def\POE@str@top{top}
\def\POE@str@bottom{bottom}
\def\POE@str@center{center}
\def\POE@str@closed{closed}
\def\POE@str@opened{opened}
\def\POE@str@dettype@round{round}
\def\POE@str@dettype@diode{diode}
\def\POE@str@bsstyle@cube{cube}
\def\POE@str@bsstyle@plate{plate}
\def\POE@str@auto{auto}
\def\POE@str@center{center}
\def\POE@str@verbose{verbose}
\def\POE@str@quiet{quiet}
\def\POE@Verb#1{\pst@Verb{\pst@optexpdict #1 end }}%
%    \end{macrocode}
%
% \section{Parameter and style definitions}
% The parameters and styles are commented quiet well in the user documentation,
% here you will find only additional comments about technical peculiarities.
%    \begin{macrocode}
\newpsstyle{OptComp}{}%
\define@key[psset]{optexp}{newOptComp}{%
  \newpsstyle{OptComp}{#1}%
}
\define@key[psset]{optexp}{addtoOptComp}{%
  \addtopsstyle{OptComp}{#1}%
}
\newpsstyle{OptionalStyle}{linestyle=dashed,dash=1.5pt 1pt}%
\newpsstyle{IfcNodeStyle}{dotstyle=x, dotscale=1.5, linecolor=blue}%
\newpsstyle{Beam}{linecolor=green!90!black,
                  linewidth=\pslinewidth, linejoin=1}%
\define@key[psset]{optexp}{newBeam}{%
  \newpsstyle{Beam}{#1}%
}
\define@key[psset]{optexp}{addtoBeam}{%
  \addtopsstyle{Beam}{#1}%
}
%    \end{macrocode}
% Styles for the automatic fiber connections.
%    \begin{macrocode}
\newpsstyle{Fiber}{}%
\define@key[psset]{optexp}{newFiber}{%
  \newpsstyle{Fiber}{#1}%
}
\define@key[psset]{optexp}{addtoFiber}{%
  \addtopsstyle{Fiber}{#1}%
}
\newpsstyle{FiberIn}{style=Fiber}%
\define@key[psset]{optexp}{newFiberIn}{%
  \newpsstyle{FiberIn}{#1}%
}
\define@key[psset]{optexp}{addtoFiberIn}{%
  \addtopsstyle{FiberIn}{#1}%
}
\newpsstyle{FiberOut}{style=Fiber}%
\define@key[psset]{optexp}{newFiberOut}{%
  \newpsstyle{FiberOut}{#1}%
}
\define@key[psset]{optexp}{addtoFiberOut}{%
  \addtopsstyle{FiberOut}{#1}%
}
\newpsstyle{FiberIn1}{style=FiberIn}%
\define@key[psset]{optexp}{newFiberIn1}{%
  \newpsstyle{FiberIn1}{#1}%
}
\define@key[psset]{optexp}{addtoFiberIn1}{%
  \addtopsstyle{FiberIn1}{#1}%
}
\newpsstyle{FiberIn2}{style=FiberIn}%
\define@key[psset]{optexp}{newFiberIn2}{%
  \newpsstyle{FiberIn2}{#1}%
}
\define@key[psset]{optexp}{addtoFiberIn2}{%
  \addtopsstyle{FiberIn2}{#1}%
}
\newpsstyle{FiberOut1}{style=FiberOut}%
\define@key[psset]{optexp}{newFiberOut1}{%
  \newpsstyle{FiberOut1}{#1}%
}
\define@key[psset]{optexp}{addtoFiberOut1}{%
  \addtopsstyle{FiberOut1}{#1}%
}
\newpsstyle{FiberOut2}{style=FiberOut}%
\define@key[psset]{optexp}{newFiberOut2}{%
  \newpsstyle{FiberOut2}{#1}%
}
\define@key[psset]{optexp}{addtoFiberOut2}{%
  \addtopsstyle{FiberOut2}{#1}%
}
%    \end{macrocode}
% Special styles to change only a part of some devices.
%    \begin{macrocode}
\newpsstyle{ExtendedMirror}{%
  linestyle=none, hatchwidth=0.5\POE@key@mirrorlinewidth,
  hatchsep=1.4\POE@key@mirrorlinewidth, fillstyle=hlines
}%
\newpsstyle{VariableMirror}{%
  linewidth=0.8\pslinewidth, arrowinset=0, arrowscale=0.8, arrows=<->
}
\newpsstyle{PiezoMirror}{fillstyle=solid,fillcolor=black!30}%
\newpsstyle{IsolatorArrow}{linewidth=2\pslinewidth, arrowinset=0}
\newpsstyle{CrystalCaxis}{%
  linestyle=dashed, dash=2pt 2pt, linewidth=0.7\pslinewidth, 
  arrowinset=0, arrows=->
}
\newpsstyle{CrystalLamp}{linewidth=0.6\pslinewidth}
\newpsstyle{FdlArrow}{arrowinset=0, arrows=->}
\newpsstyle{VariableCoupler}{arrowinset=0, arrows=->}
%    \end{macrocode}
%
% \subsection{General parameters}
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@component@]{optional}[true]{}
\define@boolkey[psset]{optexp}[POE@]{usefiberstyle}[true]{}
\define@boolkey[psset]{optexp}[POE@debug@]{showoptdots}[true]{}
\define@boolkey[psset]{optexp}[POE@debug@]{showifcnodes}[true]{}
%    \end{macrocode}
% The positioning parameters.
%    \begin{macrocode}
\define@choicekey*+[psset]{optexp}{position}[\val\nr]{start,end}{%
  \ifcase\nr\relax
    \psset[optexp]{startbox, endbox=false}%
  \or
    \psset[optexp]{startbox=false, endbox=true}%
  \fi
}{\edef\POE@key@position{#1}}%
\define@choicekey*+[psset]{optexp}{abspos}[\val\nr]{start,end}{%
  \ifcase\nr\relax
    \psset[optexp]{startbox, endbox=false}%
  \or
    \psset[optexp]{startbox=false, endbox=true}%
  \fi
}{\edef\POE@key@abspos{#1}}%
\define@key[psset]{optexp}{compshift}{%
  \pst@checknum{#1}\POE@key@compshift
}
\define@key[psset]{optexp}{angle}{%
  \pst@checknum{#1}\POE@key@angle
}
\psset[optexp]{%
  position={},
  abspos={},
  compshift=0,
  angle=0
}%
%    \end{macrocode}
% Layering
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@]{backlayer}[true]{}
\define@boolkey[psset]{optexp}[POE@]{frontlayer}[true]{}
\define@boolkey[psset]{optexp}[POE@]{optexpenv}[true]{}
\psset[optexp]{backlayer, frontlayer}%
%    \end{macrocode}
% Labels
%    \begin{macrocode}
\define@key[psset]{optexp}{labelangle}{%
  \pst@checknum{#1}\POE@key@labelangle
}
\define@key[psset]{optexp}{labeloffset}{%
  \pst@checknum{#1}\POE@key@labeloffset
}
\define@key[psset]{optexp}{labelstyle}{%
  \def\POE@key@labelstyle{#1}%
}
\define@key[psset]{optexp}{labelalign}{%
  \def\POE@key@labelalign{#1}%
}
\define@key[psset]{optexp}{labelref}{%
  \edef\POE@key@labelref{#1}%
}
\define@choicekey*+[psset]{optexp}{innerlabel}%
  [\val\nr]{true}[true]%
  {\ifcase\nr\relax
     \psset[optexp]{labeloffset=0, labelref=relative}%
   \fi}
  {\PackageError{pst-optexp}{Unknown value '\val' for innerlabel}}%
\define@key[psset]{optexp}{label}{%
  \pst@expandafter\POE@psset@@label{#1} {} {} {} {} {}\@nil
}%
\def\POE@psset@@label#1 #2 #3 #4 #5\@nil{%
  \edef\POE@temp{#4}%
  \ifx\POE@temp\@empty\else
    \expandafter\ifx\POE@temp.\else
      \psset[optexp]{labelref=#4}%
    \fi
  \fi
  \edef\POE@temp{#3}
  \ifx\POE@temp\@empty\else
    \expandafter\ifx\POE@temp.\else
      \psset[optexp]{labelalign=#3}%
    \fi
  \fi
  \edef\POE@temp{#2}%
  \ifx\POE@temp\@empty\else
    \expandafter\ifx\POE@temp.\else
      \psset[optexp]{labelangle=#2}%
    \fi
  \fi
  \edef\POE@temp{#1}%
  \ifx\POE@temp\@empty\else
    \expandafter\ifx\POE@temp.\else
      \psset[optexp]{labeloffset=#1}%
    \fi
  \fi
}%
%    \end{macrocode}
% This is for internal use only, it sets the reference angle for the \opt{labelangle} parameter and can be different for some components.
%    \begin{macrocode}
\define@key[psset]{optexp}{ref@angle}{%
  \pst@checknum{#1}\POE@key@labelrefangle
}%
\psset[optexp]{%
  labeloffset=0.8,
  labelangle=0,
  labelstyle=,
  labelalign=c,
  labelref=relgrav,
  ref@angle=0
}%
%    \end{macrocode}
% External node
%    \begin{macrocode}
\define@choicekey+[psset]{optexp}{extnodealign}%
  [\val\nr]{rel,abs,relative,absolute}%
  {%
    \ifcase\nr\relax
      \let\POE@key@extnodealign\POE@str@relative
    \or
      \let\POE@key@extnodealign\POE@str@absolute
    \else
      \def\POE@key@extnodealign{#1}%
    \fi
  }%
  {\PackageError{pst-optexp}{Unknown value '\val' for extnodealign.}}
%    \end{macrocode}
% This part was copied and adapted from \cs{psset@@ref} from pstricks.tex
%    \begin{macrocode}
\define@key[psset]{optexp}{extnode}{%
   \edef\POE@key@extnode{#1}%
   \ifx\@empty\POE@key@extnode\else
      \pst@expandafter\POE@psset@@extnode{#1}\@empty,,\@nil
   \fi
}%
\def\POE@key@extnode@xref{0}%
\def\POE@key@extnode@yref{0}%
\def\POE@psset@@extnode#1#2,#3,#4\@nil{%
  \def\POE@key@extnode@xref{0}%
  \def\POE@key@extnode@yref{0}%
  \ifx\@empty#3\@empty
    \@nameuse{POE@getref@#1}%
    \@nameuse{POE@getref@#2}%
  \else
    \pst@checknum{#1#2}\POE@key@extnode@xref%
    \pst@checknum{#3}\POE@key@extnode@yref%
  \fi
}%
\def\POE@getref@c{}%
\def\POE@getref@t{\def\POE@key@extnode@yref{1}}%
\def\POE@getref@b{\def\POE@key@extnode@yref{-1}}%
\def\POE@getref@l{\def\POE@key@extnode@xref{-1}}%
\def\POE@getref@r{\def\POE@key@extnode@xref{1}}%
\psset[optexp]{%
  extnode=\@empty, 
  extnodealign=abs
}%
%    \end{macrocode}
% Set the rotation reference point. For this to work properly, the components
% must define a proper \cs{component@ref} macro which sets the origin and
% sizes. See below for detailed information.
%    \begin{macrocode}
\define@key[psset]{optexp}{rotateref}{%
   \def\POE@temp{#1}%
   \ifx\@empty\POE@temp\else
      \pst@expandafter\POE@psset@@rotateref{#1}\@empty,,\@nil
   \fi
}%
\def\POE@key@rotate@xref{0}%
\def\POE@key@rotate@yref{0}%
\def\POE@psset@@rotateref#1#2,#3,#4\@nil{%
  \def\POE@key@rotate@xref{0}%
  \def\POE@key@rotate@yref{0}%
  \ifx\@empty#3\@empty
    \@nameuse{POE@getref@rotate@#1}%
    \@nameuse{POE@getref@rotate@#2}%
  \else
    \pst@checknum{#1#2}\POE@key@rotate@xref%
    \pst@checknum{#3}\POE@key@rotate@yref%
  \fi}%
\def\POE@getref@rotate@c{}%
\def\POE@getref@rotate@t{\def\POE@key@rotate@yref{1}}%
\def\POE@getref@rotate@b{\def\POE@key@rotate@yref{-1}}%
\def\POE@getref@rotate@l{\def\POE@key@rotate@xref{-1}}%
\def\POE@getref@rotate@r{\def\POE@key@rotate@xref{1}}%
\psset[optexp]{rotateref=c}%
%    \end{macrocode}
% Naming parameters.
%    \begin{macrocode}
\define@choicekey*[psset]{optexp}{namingscheme}%
  [\val\nr]{old,new}[new]{%
  \ifcase\nr\relax
%    \end{macrocode}
% Use the old naming scheme which was used in version 2.x.
%    \begin{macrocode}
    \edef\POE@str@basicname@default{tempNode}
    \edef\POE@str@basicname@prefix{}
    \gdef\POE@str@basicname@sep{Intern}
    \edef\POE@str@extnode@postfix{ExtNode}
  \or
    \edef\POE@str@basicname@default{@}
    \edef\POE@str@basicname@prefix{OE@}
    \gdef\POE@str@basicname@sep{}
    \edef\POE@str@extnode@postfix{Ext}
  \fi
}%
\psset[optexp]{namingscheme=new}%
\define@key[psset]{optexp}{b@sicname}{%
  \edef\POE@key@b@sicname{\POE@str@basicname@prefix#1}%
}%
\define@key[psset]{optexp}{compname}{%
  \ifPOE@insideobj\else
    \PackageError{pst-optexp}{compname allowed only inside an object}
  \fi
  \edef\POE@temp{#1}%
  \ifx\POE@temp\@empty
    \edef\POE@key@compname{\the\POE@cnt}%
  \else
    \edef\POE@key@compname{#1}%
  \fi
%    \end{macrocode}
% check if compname was already defined.
%    \begin{macrocode}
  \@expandtwoargs\in@{,\POE@key@compname,}{,\POE@complist,}%
  \ifin@
    \PackageWarning{pst-optexp}{%
      ^^Jcompname '\POE@key@compname' already used,\MessageBreak
      previous nodes will be overwritten!^^J
    }%
  \else
%    \end{macrocode}
%
% Use definition of \cs{XKV@addtolist@x} with an \cs{xdef} instead of \cs{edef} in order to keep the bookkeeping global.
%    \begin{macrocode}
    \xdef\POE@complist{%
      \POE@key@compname\ifx\POE@complist\@empty\else,\fi\POE@complist
    }%
  \fi
}%
\POE@insideobjtrue
\psset[optexp]{compname=\@empty}
\POE@insideobjfalse
%    \end{macrocode}
% Error handling.
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@]{pswarning}[true]{}
\psset[optexp]{pswarning=true}%
%    \end{macrocode}
%
% \subsection{Free-ray component parameters}
% Lens
%    \begin{macrocode}
\define@key[psset]{optexp}{lensheight}{%
  \pst@checknum{#1}\POE@key@lensheight
}
\define@key[psset]{optexp}{lenswidth}{%
  \pst@checknum{#1}\POE@key@lenswidth
  \ifdim\POE@key@lenswidth pt > 0pt
    \psset[optexp]{thicklens=true}
  \fi
}
\define@key[psset]{optexp}{lensradiusleft}{%
  \pst@checknum{#1}\POE@key@lensradiusleft
}
\define@key[psset]{optexp}{lensradiusright}{%
  \pst@checknum{#1}\POE@key@lensradiusright
}
\define@boolkey[psset]{optexp}[POE@]{thicklens}[true]{}
\define@key[psset]{optexp}{lensradius}{%
  \pst@expandafter\POE@psset@@lensradius{#1} {} {} {}\@nil
}%
\def\POE@psset@@lensradius#1 #2 #3\@nil{%
  \edef\POE@temp{#1}%
  \ifx\POE@temp\@empty\else
    \psset[optexp]{lensradiusleft=#1}%
  \fi
  \edef\POE@temp{#2}%
  \ifx\POE@temp\@empty
    \psset[optexp]{lensradiusright=#1}%
  \else
    \psset[optexp]{lensradiusright=#2}%
  \fi
}%
\define@key[psset]{optexp}{lens}{%
  \pst@expandafter\POE@psset@@lens{#1} {} {} {} {} {}\@nil
}%
\def\POE@psset@@lens#1 #2 #3 #4 #5\@nil{%
  \edef\POE@temp{#4}%
  \ifx\POE@temp\@empty\else
    \expandafter\ifx\POE@temp.\else
      \psset[optexp]{lenswidth=#4}%
    \fi
  \fi
  \edef\POE@temp{#3}%
  \ifx\POE@temp\@empty\else
    \expandafter\ifx\POE@temp.\else
      \psset[optexp]{lensheight=#3}
    \fi
  \fi
  \edef\POE@temp{#2}%
  \ifx\POE@temp\@empty
     \psset[optexp]{lensradiusright=#1}%
  \else
    \expandafter\ifx\POE@temp.\else
      \psset[optexp]{lensradiusright=#2}%
    \fi
  \fi
  \edef\POE@temp{#1}%
  \expandafter\ifx\POE@temp.\else
    \psset[optexp]{lensradiusleft=#1}%
  \fi
}%
\psset[optexp]{%
  lenswidth=0,
  lensheight=1,
  lensradiusleft=1,
  lensradiusright=1
}%
%    \end{macrocode}
% Pinhole
%    \begin{macrocode}
\define@key[psset]{optexp}{innerheight}{%
  \pst@checknum{#1}\POE@key@innerheight
}
\define@key[psset]{optexp}{outerheight}{%
  \pst@checknum{#1}\POE@key@outerheight
}
\define@key[psset]{optexp}{phlinewidth}{%
  \edef\POE@key@phlinewidth{#1}%
}
\define@key[psset]{optexp}{phwidth}{%
  \edef\POE@key@phwidth{#1}%
}
\psset[optexp]{%
  phlinewidth=2\pslinewidth,
  phwidth=0,
  outerheight=1,
  innerheight=0.1
}%
%    \end{macrocode}
% Crystal
%    \begin{macrocode}
\define@key[psset]{optexp}{crystalwidth}{%
  \pst@checknum{#1}\POE@key@crystalwidth
}
\define@key[psset]{optexp}{crystalheight}{%
  \pst@checknum{#1}\POE@key@crystalheight
}
\define@key[psset]{optexp}{caxislength}{%
  \pst@checknum{#1}\POE@key@caxislength
}
\define@boolkey[psset]{optexp}[POE@]{voltage}[true]{}
\define@boolkey[psset]{optexp}[POE@]{caxisinv}[true]{}
\define@boolkey[psset]{optexp}[POE@]{lamp}[true]{}
\define@key[psset]{optexp}{lampscale}{%
  \pst@checknum{#1}\POE@key@lampscale
  \pst@divide{\POE@key@lampscale pt}{0.3pt}{\POE@key@lampscale}
  \addtopsstyle{CrystalLamp}{unit=\POE@key@lampscale}
  \PackageWarning{pst-optexp}{%
    Parameter 'lampscale' is deprecated, \MessageBreak
    use style 'CrystalLamp' instead.}%
}
\psset[optexp]{%
  crystalwidth=1.4,
  crystalheight=0.6,
  caxislength=0.3
}%
%    \end{macrocode}
% Box
%    \begin{macrocode}
\define@key[psset]{optexp}{optboxwidth}{%
  \pst@checknum{#1}\POE@key@optboxwidth
}
\define@key[psset]{optexp}{optboxheight}{%
  \pst@checknum{#1}\POE@key@optboxheight
}
\define@key[psset]{optexp}{optboxsize}{%
  \pst@expandafter\POE@psset@@optboxsize{#1} {} {} {}\@nil
}%
\def\POE@psset@@optboxsize#1 #2 #3\@nil{%
  \edef\POE@temp{#1}%
  \ifx\POE@temp\@empty\else
    \psset[optexp]{optboxwidth=#1}%
  \fi
  \edef\POE@temp{#2}%
  \ifx\POE@temp\@empty
    \psset[optexp]{optboxheight=#1}%
  \else
    \psset[optexp]{optboxheight=#2}%
  \fi
}%
\define@boolkey[psset]{optexp}[POE@]{endbox}[true]{}
\define@boolkey[psset]{optexp}[POE@]{startbox}[true]{}
\psset[optexp]{%
  optboxwidth=1.4,
  optboxheight=0.8
}%
%    \end{macrocode}
% Plate
%    \begin{macrocode}
\define@key[psset]{optexp}{platelinewidth}{%
  \edef\POE@key@platelinewidth{#1}%
}
\define@key[psset]{optexp}{plateheight}{%
  \pst@checknum{#1}\POE@key@plateheight
}
\psset[optexp]{%
  plateheight=1,
  platelinewidth=2\pslinewidth
}%
%    \end{macrocode}
% Optical retardation plate, the height is the same as for \cs{optplate}.
%    \begin{macrocode}
\define@key[psset]{optexp}{platewidth}{%
  \pst@checknum{#1}\POE@key@platewidth
}
\psset[optexp]{platewidth=0.1}%
%    \end{macrocode}
% Detector
%    \begin{macrocode}
\define@key[psset]{optexp}{detsize}{%
  \pst@expandafter\POE@psset@@detsize{#1} {} {} {}\@nil
}%
\def\POE@psset@@detsize#1 #2 #3\@nil{%
  \ifx\\#2\\
    \pst@checknum{#1}\POE@key@detsize
  \else
    \let\POE@key@detsize\@empty
    \pst@checknum{#1}\POE@key@detwidth
    \pst@checknum{#2}\POE@key@detheight
  \fi
}%
\define@choicekey*+[psset]{optexp}{dettype}[\val\nr]{round,diode}%
   {\edef\POE@key@dettype{\val}}
   {\PackageError{pst-optexp}{Unknown value '\val' for dettype.}}
\newpsstyle{DetectorStyle}{}
\psset[optexp]{%
  detsize=0.8,
  dettype=round
}%
%    \end{macrocode}
% Polarization
%    \begin{macrocode}
\define@key[psset]{optexp}{polsize}{%
  \pst@checknum{#1}\POE@key@polsize
}
\define@key[psset]{optexp}{pollinewidth}{%
  \edef\POE@key@pollinewidth{#1}%
  \PackageWarning{pst-optexp}{%
    Parameter 'pollinewidth' is deprecated, \MessageBreak
    use style 'Polarization'.}%
}%
%    \end{macrocode}
% This is defined manually, to avoid printing the warning inside the key definition above.
%    \begin{macrocode}
\def\POE@key@pollinewidth{0.7\pslinewidth}%
\newpsstyle{Polarization}{%
  linestyle=solid, linewidth=\POE@key@pollinewidth, 
  arrowscale=0.8, dotsize=3\pslinewidth
}
\define@choicekey+[psset]{optexp}{poltype}%
  [\val\nr]{parallel,misc,perp,rcirc,lcirc}%
  {\edef\POE@key@poltype{#1}}
  {\PackageError{pst-optexp}{Unknown value '\val' for poltype.}%
}
\psset[optexp]{%
  poltype=parallel,
  polsize=0.6
}%
%    \end{macrocode}
% Optical diode
%    \begin{macrocode}
\define@key[psset]{optexp}{optdiodesize}{%
  \pst@checknum{#1}\POE@key@optdiodesize
}
\psset[optexp]{optdiodesize=0.8}%
%    \end{macrocode}
% Dove prism
%    \begin{macrocode}
\define@key[psset]{optexp}{doveprismsize}{%
  \pst@expandafter\POE@psset@@doveprismsize{#1} {} {} {}\@nil
}%
\def\POE@psset@@doveprismsize#1 #2 #3\@nil{%
  \ifx\\#2\\
    \pst@checknum{#1}\POE@key@doveprismheight
    \pstFPmul\POE@key@doveprismwidth{3}{#1}
  \else
    \pst@checknum{#1}\POE@key@doveprismwidth
    \pst@checknum{#2}\POE@key@doveprismheight
  \fi
}%
\psset[optexp]{doveprismsize=0.6}%
%    \end{macrocode}
% Beamsplitter
%    \begin{macrocode}
\define@key[psset]{optexp}{bssize}{%
  \pst@checknum{#1}\POE@key@bssize
}
\define@key[psset]{optexp}{bsstyle}{%
  \edef\POE@key@bsstyle{#1}%
}
\psset[optexp]{%
  bssize=0.8,
  bsstyle=cube
}%
%    \end{macrocode}
% Mirror
%    \begin{macrocode}
\define@key[psset]{optexp}{mirrorwidth}{%
  \pst@checknum{#1}\POE@key@mirrorwidth
}
\define@key[psset]{optexp}{mirrorlinewidth}{%
  \edef\POE@key@mirrorlinewidth{#1}%
}
\define@choicekey*[psset]{optexp}{mirrortype}%
  [\val\nr]{piezo,extended,plain}{%
  \edef\POE@key@mirrortype{#1}%
}
\define@key[psset]{optexp}{mirrordepth}{%
  \pst@checknum{#1}\POE@key@mirrordepth
}
\define@key[psset]{optexp}{mirrorradius}{%
  \pst@checknum{#1}\POE@key@mirrorradius
}
\define@boolkey[psset]{optexp}[POE@]{variable}[true]{}
\psset[optexp]{%
  mirrorwidth=1,
  mirrordepth=0.15,
  mirrorradius=0,
  mirrortype=plain,
  mirrorlinewidth=2\pslinewidth
}%
%    \end{macrocode}
% Grating
%
% These are the old \opt{optgrid*} parameters, which have been deprecated.
%    \begin{macrocode}
\define@key[psset]{optexp}{optgridcount}{%
  \pst@checknum{#1}\POE@key@gratingcount
  \PackageWarning{pst-optexp}{%
    Parameter 'optgridcount' is deprecated,\MessageBreak
    use 'gratingcount' instead.}%
}%
\define@key[psset]{optexp}{optgridwidth}{%
  \pst@checknum{#1}\POE@key@gratingwidth
  \PackageWarning{pst-optexp}{%
    Parameter 'optgridwidth' is deprecated,\MessageBreak
    use 'gratingwidth' instead.}%
}%
\define@key[psset]{optexp}{optgridheight}{%
  \pst@checknum{#1}\POE@key@gratingheight
  \PackageWarning{pst-optexp}{%
    Parameter 'optgridheight' is deprecated,\MessageBreak
    use 'gratingheight' instead.}%
}%
\define@choicekey*[psset]{optexp}{optgridtype}%
  [\val\nr]{binary,blazed}{%
  \edef\POE@key@gratingtype{#1}%
  \PackageWarning{pst-optexp}{%
    Parameter 'optgridtype' is deprecated,\MessageBreak
    use 'gratingtype' instead.}%
}%
\define@key[psset]{optexp}{optgriddepth}{%
  \pst@checknum{#1}\POE@key@gratingdepth
  \PackageWarning{pst-optexp}{%
    Parameter 'optgriddepth' is deprecated,\MessageBreak
    use 'gratingdepth' instead.}%
}%
\define@key[psset]{optexp}{optgridlinewidth}{%
  \edef\POE@key@gratinglinewidth{#1}%
  \PackageWarning{pst-optexp}{%
    Parameter 'optgridlinewidth' is deprecated,\MessageBreak
    use 'gratinglinewidth' instead.}%
}%
%    \end{macrocode}
% These are the new grating parameters.
%    \begin{macrocode}
\define@key[psset]{optexp}{gratingcount}{%
  \pst@checknum{#1}\POE@key@gratingcount
}
\define@key[psset]{optexp}{gratingwidth}{%
  \pst@checknum{#1}\POE@key@gratingwidth
}
\define@key[psset]{optexp}{gratingheight}{%
  \pst@checknum{#1}\POE@key@gratingheight
}
\define@choicekey*[psset]{optexp}{gratingtype}%
  [\val\nr]{binary,blazed}{%
  \edef\POE@key@gratingtype{#1}%
}
\define@key[psset]{optexp}{gratingdepth}{%
  \pst@checknum{#1}\POE@key@gratingdepth
}
\define@key[psset]{optexp}{gratinglinewidth}{%
  \edef\POE@key@gratinglinewidth{#1}%
}
\define@boolkey[psset]{optexp}[POE@]{reverse}[true]{}
\psset[optexp]{%
  gratingcount=10,
  gratingwidth=1,
  gratingheight=0.15,
  gratingdepth=0.075,
  gratingtype=blazed,
  gratinglinewidth=0.7\pslinewidth,
}%
%    \end{macrocode}
% Penta prism
%    \begin{macrocode}
\define@key[psset]{optexp}{pentaprismsize}{%
  \pst@checknum{#1}\POE@key@pentaprismsize
}
\psset[optexp]{pentaprismsize=0.7}
%    \end{macrocode}
% Right-angle prism
%    \begin{macrocode}
\define@key[psset]{optexp}{raprismsize}{%
  \pst@checknum{#1}\POE@key@raprismsize
}
\psset[optexp]{raprismsize=1.5}
%    \end{macrocode}
% Prism
%    \begin{macrocode}
\define@key[psset]{optexp}{prismsize}{%
  \pst@checknum{#1}\POE@key@prismsize
}
\define@key[psset]{optexp}{prismangle}{%
  \pst@checknum{#1}\POE@key@prismangle
}
\define@choicekey+[psset]{optexp}{prismalign}[\val\nr]%
  {auto,center}%
  {\def\POE@key@prismalign{#1}}%
  {\PackageError{pst-optexp}{Unknown value '\val' for prismalign.}}%
\psset[optexp]{%
  prismsize=1,
  prismangle=60,
  prismalign=auto
}%
%    \end{macrocode}
% \subsection{Parameters of fiber-optical components}
% Fiber
%    \begin{macrocode}
\define@key[psset]{optexp}{fiberloops}{%
  \pst@checknum{#1}\POE@key@fiberloops
}
\define@key[psset]{optexp}{fiberloopradius}{%
  \pst@checknum{#1}\POE@key@fiberloopradius
}
\define@key[psset]{optexp}{fiberloopsep}{%
  \pst@checknum{#1}\POE@key@fiberloopsep
}
\psset[optexp]{%
  fiberloops=3,
  fiberloopradius=0.4,
  fiberloopsep=0.3
}%
%    \end{macrocode}
% Filter
%    \begin{macrocode}
\define@key[psset]{optexp}{filtersize}{%
  \pst@checknum{#1}\POE@key@filtersize
}
\define@choicekey+[psset]{optexp}{filtertype}[\val\nr]%
   {bandstop,bandpass,lowpass,highpass}%
   {\def\POE@key@filtertype{#1}}%
   {\PackageError{pst-optexp}{Unknown value '\val' for filtertype}}
\newpsstyle{FilterStyle}{}
\psset[optexp]{%
  filtersize=0.8,
  filtertype=bandpass
}%
%    \end{macrocode}
% Polarization controller
%    \begin{macrocode}
\define@key[psset]{optexp}{polcontrolsize}{%
  \pst@checknum{#1}\POE@key@polcontrolsize
}
\define@choicekey+[psset]{optexp}{polcontroltype}[\val\nr]%
   {linear,triangle}%
   {\def\POE@key@polcontroltype{#1}}%
   {\PackageError{pst-optexp}{Unknown polcontroltype '\val'}}
\psset[optexp]{%
  polcontrolsize=0.15,
  polcontroltype=linear
}%
%    \end{macrocode}
% Optical amplifier
%    \begin{macrocode}
\define@key[psset]{optexp}{optampsize}{%
  \pst@checknum{#1}\POE@key@optampsize
}
\psset[optexp]{optampsize=0.8}
%    \end{macrocode}
% Mach-Zehnder modulator
%    \begin{macrocode}
\define@key[psset]{optexp}{optmzmheight}{%
  \pst@checknum{#1}\POE@key@optmzmheight
}
\define@key[psset]{optexp}{optmzmwidth}{%
  \pst@checknum{#1}\POE@key@optmzmwidth
}
\define@key[psset]{optexp}{optmzmsize}{%
  \pst@expandafter\POE@psset@@optmzmsize{#1} {} {} {}\@nil
}%
\def\POE@psset@@optmzmsize#1 #2 #3\@nil{%
  \ifx.#1\relax\else
    \psset[optexp]{optmzmwidth=#1}%
  \fi
  \edef\POE@temp{#2}%
  \ifx\POE@temp\@empty
    \ifx.#1\relax\else
      \psset[optexp]{optmzmheight=#1}%
      \pstFPmul\POE@key@optmzmwidth{1.6}{#1}
    \fi
  \else
    \psset[optexp]{optmzmheight=#2}%
  \fi
}%
\psset[optexp]{optmzmsize=0.8}
%    \end{macrocode}
% Isolator
%    \begin{macrocode}
\define@key[psset]{optexp}{isolatorwidth}{%
  \pst@checknum{#1}\POE@key@isolatorwidth
}
\define@key[psset]{optexp}{isolatorheight}{%
  \pst@checknum{#1}\POE@key@isolatorheight
}
\define@key[psset]{optexp}{isolatorsize}{%
  \pst@expandafter\POE@psset@@isolatorsize{#1} {} {} {}\@nil
}%
\def\POE@psset@@isolatorsize#1 #2 #3\@nil{%
  \ifx.#1\relax\else
    \psset[optexp]{isolatorwidth=#1}%
  \fi
  \edef\POE@temp{#2}%
  \ifx\POE@temp\@empty
    \ifx.#1\relax\else
      \psset[optexp]{isolatorheight=#1}%
      \pstFPmul\POE@key@isolatorwidth{1.6}{#1}
    \fi
  \else\ifx.#2\relax\else
    \psset[optexp]{isolatorheight=#2}%
  \fi\fi
}%
\psset[optexp]{isolatorsize=0.6}%
%    \end{macrocode}
% Fiber polarizer
%    \begin{macrocode}
\define@key[psset]{optexp}{fiberpolsize}{%
  \pst@checknum{#1}\POE@key@fiberpolsize
}
\psset[optexp]{fiberpolsize=0.6}%
%    \end{macrocode}
% Optical switch
%    \begin{macrocode}
\define@key[psset]{optexp}{switchsize}{%
  \pst@checknum{#1}\POE@key@switchsize
}
\define@choicekey+[psset]{optexp}{switchstyle}%
  [\val\nr]{opened,closed}%
  {\edef\POE@key@switchstyle{#1}}%
  {\PackageError{pst-optexp}{Unknown value '\val' for switchstyle.}}
\psset[optexp]{%
  switchsize=0.8,
  switchstyle=opened
}%
%    \end{macrocode}
% Fiber delay line
%    \begin{macrocode}
\define@key[psset]{optexp}{fdlwidth}{%
  \pst@checknum{#1}\POE@key@fdlwidth
}
\define@key[psset]{optexp}{fdlheight}{%
  \pst@checknum{#1}\POE@key@fdlheight
}
\define@key[psset]{optexp}{fdlsize}{%
  \pst@expandafter\POE@psset@@fdlsize{#1} {} {} {}\@nil
}%
\def\POE@psset@@fdlsize#1 #2 #3\@nil{%
  \ifx.#1\relax\else
    \psset[optexp]{fdlwidth=#1}%
  \fi
  \edef\POE@temp{#2}%
  \ifx\POE@temp\@empty
    \ifx.#1\relax\else
      \psset[optexp]{fdlheight=#1}%
      \pstFPmul\POE@key@fdlwidth{1.6}{#1}
    \fi
  \else\ifx.#2\relax\else
    \psset[optexp]{fdlheight=#2}%
  \fi\fi
}%
\psset[optexp]{fdlsize=0.6}%
%    \end{macrocode}
% Fiber collimator 
%    \begin{macrocode}
\define@key[psset]{optexp}{fibercolsize}{%
  \pst@checknum{#1}\POE@key@fibercolsize
}
\psset[optexp]{fibercolsize=0.3}%
%    \end{macrocode}
% Optical Circulator
%    \begin{macrocode}
\define@key[psset]{optexp}{optcircsize}{%
  \pst@checknum{#1}\POE@key@optcircsize
}%
\define@key[psset]{optexp}{optcircangleA}{%
  \pst@checknum{#1}\POE@key@optcircangleA
}%
\define@key[psset]{optexp}{optcircangleB}{%
  \pst@checknum{#1}\POE@key@optcircangleB
}%
\define@key[psset]{optexp}{optcircangle}{%
  \pst@expandafter\POE@psset@@optcircangle{#1} {} {} {}\@nil
}%
\def\POE@psset@@optcircangle#1 #2 #3\@nil{%
  \edef\POE@tempA{#1}%
  \edef\POE@tempB{#2}%
  \ifx\\#2\\
    \PackageError{pst-optexp}{optcircangle requires two numbers}%
  \else\ifx\\#1\\
    \PackageError{pst-optexp}{optcircangle requires two numbers}%
  \else
    \psset[optexp]{optcircangleA=#1, optcircangleB=#2}%
  \fi\fi
}%
\psset[optexp]{%
  optcircsize=0.8, 
  optcircangle=-160 -20
}%
\newpsstyle{OptCircArrow}{unit=0.7, arrows=->, arrowinset=0}
%    \end{macrocode}
%
% Coupler
%    \begin{macrocode}
\define@key[psset]{optexp}{couplerwidth}{%
  \pst@checknum{#1}\POE@key@couplerwidth
  \let\POE@key@couplersize\@empty
}
\define@key[psset]{optexp}{couplerheight}{%
  \pst@checknum{#1}\POE@key@couplerheight
  \let\POE@key@couplersize\@empty
}
\define@key[psset]{optexp}{couplersize}{%
  \pst@expandafter\POE@psset@@couplersize{#1} {} {} {}\@nil
}%
\def\POE@psset@@couplersize#1 #2 #3\@nil{%
  \ifx\\#2\\
    \pst@checknum{#1}\POE@key@couplersize
  \else
    \psset[optexp]{couplerwidth=#1}
    \psset[optexp]{couplerheight=#1}
  \fi
}%
\define@key[psset]{optexp}{couplersep}{%
  \pst@checknum{#1}\POE@key@couplersep
}
\define@choicekey+[psset]{optexp}{couplertype}%
  [\val\nr]{none,elliptic,ellipse,crossswitch,rectangle}%
  {%
    \edef\POE@key@couplertype{#1}
    \ifx\POE@key@couplertype\POE@str@couplertype@elliptic
      \let\POE@key@couplertype\POE@str@couplertype@ellipse
    \fi
  }%
  {\PackageError{pst-optexp}{Unknown value '\val' for couplertype.}}
\define@key[psset]{optexp}{align}{%
  \psset[optexp]{coupleralign=#1}%
  \PackageWarning{pst-optexp}{%
    Parameter 'align' is deprecated,\MessageBreak
    use 'coupleralign' instead.}%
}
\define@choicekey+[psset]{optexp}{coupleralign}%
  [\val\nr]{top,bottom,center}%
  {\edef\POE@key@coupleralign{#1}}%
  {\PackageError{pst-optexp}{Unknown value '\val' for coupleralign.}}
\psset[optexp]{%
  couplerwidth=0.4,
  couplerheight=0.16,
  couplersize=0.2,
  couplersep=0.05,
  coupleralign=center,
  couplertype=elliptic
}%
%    \end{macrocode}
% \subsection{Beam-connection parameters}
% The keys related to the \cs{draw*} macros.
%
% Connect a component directly with its reference nodes using \cs{drawbeam}.
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@]{beam}[true]{}
%    \end{macrocode}
%    \begin{macrocode}
\define@key[psset]{optexp}{refractiveindex}{%
  \psset[optexp]{n=#1}%
  \PackageWarning{pst-optexp}{%
    Option 'refractiveindex' is deprecated,\MessageBreak
    use 'n' instead}%
}%
\define@key[psset]{optexp}{n}{%
  \POE@parsealg{n}#1\@nil
}
\def\POE@parsealg#1#2#3\@nil{%
  \ifx#2*\relax
    \POE@@parsealg#3\@nil
    \expandafter\let\csname POE@key@#1\endcsname\POE@tempA
  \else
    \@namedef{POE@key@#1}{[#2#3] }%
  \fi
}
\def\POE@@parsealg#1#2\@nil{%
  \edef\POE@tempA{tx@Dict begin (#1#2) AlgParser end }%
}
\define@key[psset]{optexp}{beamangle}{%
  \edef\POE@key@beamangle{#1}%
}%
\define@key[psset]{optexp}{beampos}{%
  \edef\POE@key@beampos{#1}%
}%
\define@key[psset]{optexp}{beamdiv}{%
  \edef\POE@key@beamdiv{#1}%
}%
\define@key[psset]{optexp}{beamwidth}{%
  \edef\POE@key@beamwidth{#1}%
}%
\define@boolkey[psset]{optexp}[POE@]{startinside}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{stopinside}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{beaminsidefirst}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{beaminsidelast}[true]{}%
\define@choicekey+[psset]{optexp}{savebeampoints}%
  [\val\nr]{true,false}[true]{%
    \ifcase\nr\relax
      \def\POE@key@savebeampoints{1}
    \or
      \def\POE@key@savebeampoints{0}
    \fi
  }{%
    \ifnum9<1#1
      \def\POE@key@savebeampoints{#1}
    \else
      \PackageError{pst-optexp}%
        {savebeampoints must be a positive integer or 0.}%
    \fi
    \@expandtwoargs\in@{,\POE@key@savebeampoints,}{,\POE@beamlist,}%
    \ifin@\else
      \xdef\POE@beamlist{%
        \POE@key@savebeampoints
        \ifx\POE@beamlist\@empty\else,\fi\POE@beamlist
      }%
    \fi
}%
\define@choicekey+[psset]{optexp}{loadbeampoints}%
  [\val\nr]{true,false}[true]{%
    \ifcase\nr\relax
      \def\POE@key@loadbeampoints{1}
    \or
      \def\POE@key@loadbeampoints{0}
    \fi
  }{%
    \ifnum9<1#1
      \def\POE@key@loadbeampoints{#1}%
    \else
      \PackageError{pst-optexp}%
        {loadbeampoints must be a positive integer or 0.}%
    \fi
    \@expandtwoargs\in@{,\POE@key@loadbeampoints,}{,\POE@beamlist,}%
    \ifin@\else
      \xdef\POE@beamlist{%
        \POE@key@loadbeampoints
        \ifx\POE@beamlist\@empty\else,\fi\POE@beamlist
      }%
    \fi
}%
\define@key[psset]{optexp}{loadbeam}[true]{%
  \setkeys+[psset]{optexp}{loadbeampoints=#1}%
  \ifdim\POE@key@loadbeampoints pt>0pt
    \POE@loadbeamtrue
  \else
    \POE@loadbeamfalse
  \fi
}%
\define@key[psset]{optexp}{savebeam}[true]{%
  \setkeys+[psset]{optexp}{savebeampoints=#1}%
  \ifdim\POE@key@savebeampoints pt>0pt
    \POE@savebeamtrue
  \else
    \POE@savebeamfalse
  \fi
}%
\define@boolkey[psset]{optexp}[POE@]{beaminside}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{allowbeaminside}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{raytrace}[true]{}%
\define@key[psset]{optexp}{skipconn}{%
  \pst@checknum{#1}\POE@key@skipconn
}%
\define@choicekey+[psset]{optexp}{beamalign}%
  [\val\nr]{rel,abs,relative,absolute}%
  {%
    \ifcase\nr\relax
      \let\POE@key@beamalign\POE@str@relative
    \or
      \let\POE@key@beamalign\POE@str@absolute
    \else
      \def\POE@key@beamalign{#1}%
    \fi
  }%
  {\PackageError{pst-optexp}{Unknown value '\val' for beamalign.}}
\psset[optexp]{%
  raytrace=true
  ,startinside=false
  ,stopinside=false
  ,allowbeaminside=true
  ,beaminside=true
  ,beaminsidefirst=false
  ,beaminsidelast=false
  ,loadbeam=false
  ,savebeam=false
  ,loadbeampoints=false
  ,savebeampoints=true
  ,beamangle=0
  ,beampos=\@empty
  ,beamalign=relative
  ,beamwidth=0
  ,beamdiv=0
  ,n=1.5
  ,skipconn=0
}%
%    \end{macrocode}
%
% \subsection{Fiber-connection parameters}
% Select which fibers are drawn automatically. The parameters \opt{fiber},
% \opt{fiberin} and \opt{fiberout} do not only select which fibers are drawn,
% but do also enable fiber connecting for the free-ray components. So you should
% use these switches only locally, or they must be followed by a
% \opt{fiber@=false}. (Need to rethink this part\ldots).
%    \begin{macrocode}
\define@choicekey*[psset]{optexp}{fiberconn}%
  [\val\nr]{none,preset,all}[preset]{%
  \ifcase\nr\relax
    \psset[optexp]{fiber@=false, nofiber@}
  \or
    \psset[optexp]{fiber@=false, nofiber@=false}
  \or
    \psset[optexp]{fiber@, nofiber@=false}
  \fi
}
\define@key[psset]{optexp}{fiber*}[all]{%
  \psset[optexp]{fiber=#1, fiberconn=preset}%
}%
\define@choicekey*+[psset]{optexp}{fiber}%
  [\val\nr]{false,none,true,all}[all]{%
  \ifcase\nr\relax
    \POE@getfiber@none
  \or
    \POE@getfiber@none
  \or
    \POE@getfiber@all
  \or
    \POE@getfiber@all
  \fi
}{%
  \ifx\@empty\val
    \POE@getfiber@none
  \else
    \pst@expandafter\POE@psset@@fiber{#1}\@empty,,\@nil
  \fi
}%
\def\POE@psset@@fiber#1#2,#3,#4\@nil{%
  \POE@getfiber@all
  \ifx\@empty#3\@empty
    \@nameuse{POE@getfiber@#1}%
    \@nameuse{POE@getfiber@#2}%
  \fi
}%
\def\POE@getfiber@none{%
  \psset[optexp]{%
    fiber@=false, fiberconn=none,
  }%
}%
\def\POE@getfiber@all{%
  \psset[optexp]{%
    fiberconn=all,
    fiber@, fiberin@, fiberout@,
    fiberin@top, fiberin@bottom, 
    fiberout@top, fiberout@bottom}%
}%
\def\POE@getfiber@t{%
  \psset[optexp]{fiberin@bottom=false, fiberout@bottom=false}}%
\def\POE@getfiber@b{%
  \psset[optexp]{fiberin@top=false, fiberout@top=false}}%
\def\POE@getfiber@l{\psset[optexp]{fiberout@=false}}%
\def\POE@getfiber@r{\psset[optexp]{fiberin@=false}}%
\let\POE@getfiber@i\POE@getfiber@l
\let\POE@getfiber@o\POE@getfiber@r
%    \end{macrocode}
% These are the internal boolkeys for the fiber choices done with \opt{fiberin},
% \opt{fiberout} and \opt{fiber}. Do not use them directly.
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@]{fiber@}[true]{}
\define@boolkey[psset]{optexp}[POE@]{nofiber@}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberin@}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberin@top}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberin@bottom}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberout@}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberout@top}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberout@bottom}[true]{}
\psset[optexp]{fiber, fiber@=false}%
\define@key[psset]{optexp}{fiberangleA}{%
  \pst@checknum{#1}\POE@key@fiberangleA
}%
\define@key[psset]{optexp}{fiberangleB}{%
  \pst@checknum{#1}\POE@key@fiberangleB
}%
\define@choicekey+[psset]{optexp}{fiberalign}%
  [\val\nr]{rel,abs,relative,center,absolute}%
  {%
    \ifcase\nr\relax
      \let\POE@key@fiberalign\POE@str@relative
    \or
      \let\POE@key@fiberalign\POE@str@absolute
    \else
      \def\POE@key@fiberalign{#1}%
    \fi
  }%
  {\PackageError{pst-optexp}{Unknown value '\val' for fiberalign.}}%  
\define@key[psset]{optexp}{fiberstyle}{%
  \@ifundefined{nc#1}%
    {\PackageError{pst-optexp}{Unknown value '#1' for fiberstyle.}}%
    {\def\POE@key@fiberstyle{#1}}}
\psset[optexp]{%
  fiberangleA=0,
  fiberangleB=0,
  fiberalign=relative,
  fiberstyle=curve
}%
%    \end{macrocode}
% Which nodes to take for the automatic fiber connections.
%    \begin{macrocode}
\define@choicekey+[psset]{optexp}{startnode}%
  [\val\nr]{auto,1,2,3,4,N}%
  {\edef\POE@key@startnode{\val}}
  {\PackageError{pst-optexp}{Unknown startnode number '\val'}}
\define@choicekey+[psset]{optexp}{stopnode}[\val\nr]{auto,1,2,3,4,N}%
   {\edef\POE@key@stopnode{\val}}
   {\PackageError{pst-optexp}{Unknown stopnode number '\val'}}
\psset[optexp]{%
  startnode=auto,
  stopnode=auto
}%
%    \end{macrocode}
%
% \section{Layering}
%    \begin{macrocode}
\newenvironment{optexp}{\Collect@Body\POE@collect}{}
\long\def\POE@collect#1{%
  \psset[optexp]{optexpenv}
  \global\POE@oldcnt=\POE@cnt
  \bgroup
    \psset[optexp]{backlayer=true, frontlayer=false}#1%
  \egroup
  \gdef\POE@complist{}\global\POE@cnt=\POE@oldcnt\relax
  \psset[optexp]{backlayer=false, frontlayer=true}%
  #1}%
%    \end{macrocode}
% \begin{macro}{\backlayer}
%    \begin{macrocode}
\def\backlayer#1{\ifPOE@backlayer #1\fi\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\frontlayer}
%    \begin{macrocode}
\def\frontlayer#1{\ifPOE@frontlayer #1\fi\ignorespaces}
%    \end{macrocode}
% \end{macro}
%
% \section{Connection code}
% \subsection{drawfiber}
% \begin{macro}{\POE@getnode}
%    \begin{macrocode}
\def\POE@getnode#1#2\@nil{%
  \ifx(#1\relax%)
    \POE@getcoor#1#2
    \edef\POE@temp{{\pst@coor}}%
  \else
    \edef\POE@temp{/\oenode{}{#1#2}\space}%
  \fi%
}%
%    \end{macrocode}
% \begin{macro}{\POE@getcoor}
%    \begin{macrocode}
\def\POE@getcoor(#1){\pst@@getcoor{#1}}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\drawfiber}
%    \begin{macrocode}
\def\drawfiber{\drawfiber@{Fiber}}%
\def\drawfiber@#1{%
  \ifPst@custom\else
    \def\pst@par{style=#1}%
  \fi
  \@ifnextchar[%]
    {\drawfiber@i}{\drawfiber@i[]}%
}%
\def\drawfiber@i[#1]#2{%
  \addafter@par{#1}%
  \def\POE@tempe{#2}%
  \@ifnextchar\bgroup{\drawfiber@ii}{}%
}%
\def\drawfiber@ii#1{%
  \expandafter\drawfiber@iii\expandafter{\POE@tempe}{#1}%
  \def\POE@tempe{#1}%
  \@ifnextchar\bgroup{\drawfiber@ii}{}%
}%
\def\drawfiber@iii#1#2{%
  \begingroup
    \let\psk@angleA\relax
    \let\psk@angleB\relax
    \use@par
    \def\POE@tempa{#1}
    \ifx\POE@tempa\@empty
      \edef\POE@comps{/\oenode{}{}\space}
    \else
      \expandafter\POE@getnode#1\@nil
      \edef\POE@comps{\POE@temp}
    \fi
    \def\POE@tempb{#2}
    \ifx\POE@tempb\@empty
      \edef\POE@comps{/\oenode{}{}\space \POE@comps}
    \else
      \expandafter\POE@getnode#2\@nil
      \edef\POE@comps{\POE@temp\space \POE@comps}
    \fi
    \ifPOE@backlayer
      \ifx\POE@key@startnode\POE@str@auto\else
        \POE@pnode{/\POE@key@startnode\space \POE@comps exch pop 
          \POE@dict{getsubnode} \tx@UserCoor}{@@A}
      \fi
      \ifx\POE@key@stopnode\POE@str@auto\else
        \POE@pnode{/\POE@key@stopnode\space \POE@comps pop 
                 \POE@dict{getsubnode} \tx@UserCoor}{@@B}
      \fi
      \ifx\POE@key@startnode\POE@str@auto
        \ifx\POE@key@stopnode\POE@str@auto
          \POE@pnode{\POE@comps exch \POE@dict{NearestNode} 
                   \tx@UserCoor}{@@A}
          \POE@pnode{\POE@comps \POE@dict{NearestNode} 
                   \tx@UserCoor}{@@B}
        \else
          \POE@pnode{\POE@comps exch pop /N@@@B 
                   \POE@dict{@GetCenter ToVec NearestNode} 
                   \tx@UserCoor}{@@A}
        \fi
      \else\ifx\POE@key@stopnode\POE@str@auto
        \POE@pnode{\POE@comps pop /N@@@A
                 \POE@dict{@GetCenter ToVec NearestNode} 
                 \tx@UserCoor}{@@B}
      \fi\fi
      \pst@getcoor{@@A}\POE@tempa
      \pst@getcoor{@@B}\POE@tempb
      \ifx\psk@angleA\relax
        \ifx\POE@key@fiberalign\POE@str@absolute
          \psset{angleA=\POE@key@fiberangleA}%
        \else
          \psset{angleA=! \POE@dict{%
            \POE@tempb \POE@tempa \POE@comps exch 
            \POE@key@fiberalign\space RelFiberAngle
            \POE@key@fiberangleA\space add }
          }%
        \fi
      \fi
      \ifx\psk@angleB\relax
        \ifx\POE@key@fiberalign\POE@str@absolute
          \psset{angleB=\POE@key@fiberangleB}%
        \else
          \psset{angleB=! \POE@dict{%
            \POE@tempa \POE@tempb \POE@comps 
            \POE@key@fiberalign\space RelFiberAngle
            \POE@key@fiberangleB\space add}
          }%
        \fi
      \fi
      \@nameuse{nc\POE@key@fiberstyle}{@@A}{@@B}
    \fi
  \endgroup
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{POE@pnode}
%   Do some trickery to define \cs{pnode} inside \cs{pscustom}, which is
%   required if one wants to use \cs{drawfiber} inside \cs{pscustom}.
%    \begin{macrocode}
\def\POE@pnode#1#2{%
  \ifPst@custom
    \code{%
      gsave 
        /currentpoint load stopped { 0 0 moveto } if 
        1 8.3021995 div dup neg scale 
        tx@NodeDict begin 
          {#1 \tx@ScreenCoor } false /N@#2 10 {InitPnode} 
          /NodeScale {} def NewNode 
        end 
      grestore 
    }%
  \else
    \pnode(!#1){#2}
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \subsection{drawbeam}
%
% \begin{macro}{\begin@BeamObj}
%    \begin{macrocode}
\def\begin@BeamObj{%
  \addbefore@par{n=n}%
  \begin@SpecialObj%
  \addto@pscode{%
     \pst@optexpdict
     /loadbeampoints \POE@key@loadbeampoints\space def 
     /loadbeam \ifPOE@loadbeam true \else false \fi def
     /savebeampoints \POE@key@savebeampoints\space def
     /savebeam \ifPOE@savebeam true \else false \fi def
     /beaminsidefirst \ifPOE@beaminsidefirst true \else false \fi def
     /beaminsidelast \ifPOE@beaminsidelast true \else false \fi def
     /beaminside \ifPOE@beaminside true \else false \fi def
     /startinside \ifPOE@startinside true \else false \fi def
     /stopinside \ifPOE@stopinside true \else false \fi def
     /connectifc \ifPOE@raytrace false \else true \fi def
     /beamalign 
       \ifx\POE@key@beamalign\POE@str@absolute\space 
         absolute
       \else 
         relative
       \fi def
     /skipconn \POE@key@skipconn\space def
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\begin@WideBeamObj}
%    \begin{macrocode}
\def\begin@WideBeamObj{%
  \addbefore@par{style=Beam}%
  \begin@BeamObj
  \let\pst@linetype\pst@arrowtype
  \pst@addarrowdef%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\begin@SingleBeamObj}
%    \begin{macrocode}
\let\begin@SingleBeamObj\begin@WideBeamObj
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\drawbeam}
%    \begin{macrocode}
\def\drawbeam{\pst@object{drawbeam}}%
\def\drawbeam@i{%
  \def\POE@conntable{,a-a,b-b,A-A,B-B}%
  \begin@SingleBeamObj
  \POE@getcomps[\drawbeam@ii%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\drawwidebeam}
%    \begin{macrocode}
\def\drawwidebeam{\pst@object{drawwidebeam}}%
\def\drawwidebeam@i{%
  \begin@WideBeamObj
  \POE@getcomps[\drawwidebeam@ii%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@beam@use@pscode}
%
%   This is a hack which allows us to leave the names and coordinates of the
%   beam end points on the stack after the \opt{@endspecial} call. This replaces
%   \nxLcs{use@pscode} in \nxLcs{end@BeamObj}. These values on the stack must be
%   consumed directly after closing the beam object.
%    \begin{macrocode}
\def\POE@beam@use@pscode{%
  \pstverb{%
    \pst@dict
    \tx@STP
    \pst@newpath
    \psk@origin
    \psk@swapaxes
    \pst@code
    end
    count /ocount exch def
  }%
  \gdef\pst@code{}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\end@BeamObj}
%    \begin{macrocode}
\def\end@BeamObj{%
  \addto@pscode{ end }%
  \let\psk@fillstyle\relax
  \ifPOE@optexpenv
    \ifPOE@frontlayer
%    \end{macrocode}
% Erase all beam-drawing code and leave only \opt{false} on the stack to 
% indicate that no beampoints should be stored.
%    \begin{macrocode}
      \def\pst@code{ false false }%
    \fi
  \fi
  \let\use@pscode\POE@beam@use@pscode
  \end@SpecialObj%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\drawbeam@ii}
%    \begin{macrocode}
\def\drawbeam@ii{%
  \ifx\POE@key@conn\@empty
    \drawbeam@iii
  \else
    \drawbeam@compat
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\drawbeam@iii}
%    \begin{macrocode}
\def\drawbeam@iii{%
  \ifx\pslinestyle\@none
    \addto@pscode{ false false }%
  \else
    \addto@pscode{%
%    \end{macrocode}
% I need to pack it this way in order to avoid replacing the \opt{n} inside the
% code here. This must be done later, when it refers to the correct refractive
% indices.
%    \begin{macrocode}
      {/nbeam {\POE@key@n cvx exec} bind def
       \ifPOE@pswarning
         /Warning /PrintWarning load def
       \else
         /Warning /pop load def
       \fi}%
      [ \POE@key@beampos\space counttomark dup 
      0 eq { 
        pop 0 0 
      } {
        1 eq {
          0 exch
        } if
      } ifelse \tx@ScreenCoor] cvx
      \POE@key@beamangle\space
      currentdict /lastBeamPointTmp undef
      currentdict /lastVecTmp undef
      loadbeampoints 1 ge 
      tx@NodeDict /N@\oenodeBeam{\POE@key@loadbeampoints} known and {
        /N@\oenodeBeam{\POE@key@loadbeampoints} @GetCenter ToVec 
        /lastBeamPointTmp ED
      } if
      currentdict /lastVec\POE@key@loadbeampoints\space known 
      loadbeam and {
        /lastVecTmp /lastVec\POE@key@loadbeampoints\space load def
      } if
      TraceBeam 
      \POE@strokesinglebeam
      savebeampoints 1 ge
      currentdict /lastBeamPointTmp known and dup { 
        lastBeamPointTmp 
        /N@\oenodeBeam{\POE@key@savebeampoints}\space 4 -1 roll
      } if 
      savebeam currentdict /lastVecTmp known and dup {
        /lastVec\POE@key@savebeampoints\space lastVecTmp 4 -1 roll
      } if
    }%
  \fi
  \end@BeamObj
  \POE@Verb{%
    { tx@OptexpDict begin ToVec def end } if
    { \tx@NodeScale @NewNode } if 
  }%
}%
%    \end{macrocode}
% \end{macro}
% This fix is necessary for pst-node since version 1.21.
%    \begin{macrocode}
\def\tx@NodeScale{%
  \pst@nodedict 
    /NodeScale {\ifx\pstnodescale\@undefined\else\pstnodescale\fi} def 
  end }
%    \end{macrocode}
% 
% \begin{macro}{\POE@strokesinglebeam}
%    \begin{macrocode}
\def\POE@strokesinglebeam{%
  gsave 
    Drawbeam 
    \tx@setlinejoin
    \pst@number\pslinewidth SLW
    \pst@usecolor\pslinecolor
    \tx@setStrokeTransparency
    \@nameuse{psls@\pslinestyle}
  grestore
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\drawwidebeam@ii}
%    \begin{macrocode}
\def\drawwidebeam@ii{%
  \def\pst@fill##1{ gsave ##1 grestore }%
  \addto@pscode{%
    {/nbeam {\POE@key@n cvx exec} bind def
      \ifPOE@pswarning
        /Warning /PrintWarning load def
      \else
        /Warning /pop load def
      \fi}%
  }%
%    \end{macrocode}
% arrange and create the input vectors
%    \begin{macrocode}
  \addto@pscode{%
    \POE@key@beamangle\space dup
    \POE@key@beamdiv\space 0.5 mul dup 4 -1 roll add 3 1 roll sub
  }%
%    \end{macrocode}
% the start positions
%    \begin{macrocode}
  \addto@pscode{%
    [ \POE@key@beampos\space counttomark dup
      0 eq {
        pop 0 0 
      } {
        1 eq {
          0 exch 
        } if
      } ifelse
      mark \POE@key@beamwidth\space counttomark 0 eq {
        0 
      } {
        0.5 mul
      } ifelse
      exch pop
      3 copy add \tx@ScreenCoor\space ToVec 
      5 1 roll sub \tx@ScreenCoor
    ] cvx
  }%
%    \end{macrocode}
% rearrange options
%    \begin{macrocode}
  \addto@pscode{ exch 4 -1 roll 4 2 roll exch }% 
%    \end{macrocode}
% stroke and/or fill
%    \begin{macrocode}
  \addto@pscode{%
    counttomark mark exch 2 add 1 roll
    gsave
      \ifx\psk@fillstyle\relax
        currentdict /fillBeam undef
      \else
        /fillBeam {\psk@fillstyle} def
      \fi
      /strokeBeam \ifx\pslinestyle\@none false \else true \fi def
      [/lastBeamPointTmpLow /lastBeamPointTmpUp
      /lastVecTmpLow /lastVecTmpUp]
      {currentdict exch undef} forall
      tx@NodeDict /N@\oenodeBeamLow{\POE@key@loadbeampoints} known
      tx@NodeDict /N@\oenodeBeamUp{\POE@key@loadbeampoints} known
      loadbeampoints 1 ge and and {
        /N@\oenodeBeamLow{\POE@key@loadbeampoints} @GetCenter ToVec 
        /lastBeamPointTmpLow ED
        /N@\oenodeBeamUp{\POE@key@loadbeampoints} @GetCenter ToVec 
        /lastBeamPointTmpUp ED
      } if
      loadbeam 
      currentdict /lastVecLow\POE@key@loadbeampoints\space known and 
      currentdict /lastVecUp\POE@key@loadbeampoints\space known and {
        /lastVecTmpLow /lastVecLow\POE@key@loadbeampoints\space load def
        /lastVecTmpUp /lastVecUp\POE@key@loadbeampoints\space load def
      } if
      TraceAndFillWideBeam
    grestore pop % pop off the mark
%    \end{macrocode}
% Rearrange the points so that we can use two Drawbeam calls.
% 
%    \begin{macrocode}
    counttomark 0 gt strokeBeam and {
      counttomark dup /cnta ED /cntb ED
      cnta 6 idiv {
        cnta 3 roll /cnta cnta 3 sub def
        /cntb cntb 3 sub def
        cntb 3 roll /cntb cntb 3 sub def
      } repeat
      counttomark 2 idiv 1 add mark exch 1 roll
      \POE@strokesinglebeam
      \POE@strokesinglebeam
    } {
      pop % pop off the mark
    } ifelse
    currentdict /fillBeam known strokeBeam or
    savebeampoints 1 ge and
    currentdict /lastBeamPointTmpLow known and
    currentdict /lastBeamPointTmpUp known and dup {
      lastBeamPointTmpLow /N@\oenodeBeamLow{\POE@key@savebeampoints}
      lastBeamPointTmpUp /N@\oenodeBeamUp{\POE@key@savebeampoints}
      7 -1 roll
    } if
    currentdict /fillBeam known strokeBeam or 
    savebeam and
    currentdict /lastVecTmpLow known and
    currentdict /lastVecTmpUp known and dup {
      /lastVecLow\POE@key@savebeampoints\space lastVecTmpLow
      /lastVecUp\POE@key@savebeampoints\space lastVecTmpUp
      7 -1 roll
    } if
  }%
  \end@BeamObj
  \POE@Verb{%
    { tx@OptexpDict begin ToVec def ToVec def end } if
    { \tx@NodeScale @NewNode @NewNode } if 
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
%    \begin{macrocode}
\def\POE@getcomprange#1-#2\@nil{%
  \ifx\\#2\\%
    \ifx\\#1\\%
      % empty option
      \edef\POE@firstcomp{\the\POE@cnt}%
      \edef\POE@lastcomp{\the\POE@cnt}%
    \else
      \edef\POE@firstcomp{#1}%
      \edef\POE@lastcomp{#1}%
    \fi
  \else
    \ifx\\#1\\%
      \edef\POE@firstcomp{1}%
    \else
      \edef\POE@firstcomp{#1}%
    \fi
    \POE@getlastcomp#2%
  \fi
  \ifnum\POE@firstcomp<1
    \def\POE@firstcomp{1}%
  \else\ifnum\POE@firstcomp>\the\POE@cnt
    \edef\POE@firstcomp{\the\POE@cnt}%
  \fi\fi
  \ifnum\POE@lastcomp>\the\POE@cnt
    \edef\POE@lastcomp{\the\POE@cnt}%
  \else\ifnum\POE@lastcomp<1
    \def\POE@lastcomp{1}%
  \fi\fi
}
\def\POE@getlastcomp#1-{%
  \ifx.#1.%
    \edef\POE@lastcomp{\the\POE@cnt}%
  \else
    \ifx\@empty#1\relax
      \edef\POE@lastcomp{\the\POE@cnt}%
    \else
      \edef\POE@lastcomp{#1}%
    \fi
  \fi
}
%    \end{macrocode}
%
% \begin{macro}{\POE@getcomps}
%    \begin{macrocode}
\def\POE@getcomps#1#2{%
  \ifx\POE@key@conn\@empty
    \def\POE@aftercomps{\addto@pscode{#1 \POE@comps }#2}%
  \else
    \def\POE@aftercomps{#2}%
  \fi
  \def\POE@comps{}%
  \POE@@getcomps%
}%
\def\POE@@getcomps{%
  \@ifnextchar\bgroup{\POE@@@getcomps}{\POE@aftercomps}%
}%
\def\POE@@@getcomps#1{%
  \def\POE@temp{#1\@empty}%
  \expandafter\POE@@@@getcomps\POE@temp\@nil
}%
\def\POE@@@@getcomps#1#2\@nil{%
  \edef\POE@temp{#1}%
  \ifx\POE@temp\@empty
    \POE@getcomp{(\oenode{}{})}%
  \else\ifx(#1\relax%)
    \POE@getplanenode#1#2%
  \else\ifnum9<1#1\relax
    \POE@getcomprange#1#2-\@nil
    \POE@getcomp{%
      (\POE@str@basicname@prefix\POE@str@basicname@default)
      \POE@firstcomp\space\POE@lastcomp\space GetCompRange %
    }%
  \else\ifx-#1\relax
    \POE@getcomprange#1#2-\@nil
    \POE@getcomp{%
      (\POE@str@basicname@prefix\POE@str@basicname@default) 
      \POE@firstcomp\space\POE@lastcomp\space GetCompRange %
    }%
  \else
    \POE@getcomp{(\oenode{}{#1#2})}%
  \fi\fi\fi\fi%
  \POE@@getcomps%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@getplanenode}
%    \begin{macrocode}
\def\POE@getplanenode(#1){%
  \pst@@getcoor{#1}%
  \ifx\POE@key@conn\@empty
    \advance\POE@nodecnt by 1
    \POE@getcomp{%
      {\pst@coor} {0 1} 
      (\POE@str@basicname@default N@\the\POE@nodecnt) 
      {\tx@UserCoor} NewTempNodeComp 
      (\POE@str@basicname@default N@\the\POE@nodecnt)
    }%
  \else
    \POE@getcomp{{\pst@coor} }%
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@getcomp}
%    \begin{macrocode}
\def\POE@getcomp#1{%
  \ifx\POE@comps\@empty
    \edef\POE@tempc{#1}%
  \else
    \edef\POE@tempd{#1}%
  \fi
  \edef\POE@comps{#1 \POE@comps}%
}%
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Automatic connections}
%
% \begin{macro}{\POE@drawInternalConnections}
%    \begin{macrocode}
\def\POE@drawInternalConnections{%
  \ifx\POE@key@conn\@empty
    \POE@drawInternalConnectionsNew
  \else
    \POE@drawInternalConnectionsOld
  \fi
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\POE@drawInternalFibers}
%    \begin{macrocode}
\def\POE@drawInternalFibers{%
  \ifPOE@endbox
    \ifPOE@fiberin@
      \drawfiber@{FiberIn}{(\oenodeRefA{})}{}
    \fi
  \else\ifPOE@startbox
    \ifPOE@fiberout@
      \drawfiber@{FiberOut}{}{(\oenodeRefB{})}
    \fi
  \else
    \ifPOE@fiberin@
      \drawfiber@{FiberIn}{(\oenodeRefA{})}{}
    \fi
    \ifPOE@fiberout@
      \drawfiber@{FiberOut}{}{(\oenodeRefB{})}
    \fi
  \fi\fi
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\POE@drawInternalConnectionsNew}
%    \begin{macrocode}
\def\POE@drawInternalConnectionsNew{%
  \ifPOE@beam
    \ifPOE@endbox
      \drawbeam[raytrace=false]{(\oenodeRefA{})}{}
    \else\ifPOE@startbox
      \drawbeam[raytrace=false]{}{(\oenodeRefB{})}
    \else
      \drawbeam[raytrace=false]{(\oenodeRefA{})}{}{(\oenodeRefB{})}
    \fi\fi
  \else\ifPOE@fiber@
    \POE@drawInternalFibers
  \fi\fi
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\POE@drawInternalConnectionsOld}
%    \begin{macrocode}
\def\POE@drawInternalConnectionsOld{%
  \ifPOE@endbox
    \@nameuse{\POE@connIn}
  \else
    \ifPOE@fiber@
      \ifPOE@fiberin@
        \@nameuse{\POE@connIn}
      \fi
      \ifPOE@fiberout@
        \@nameuse{\POE@connOut}
      \fi
    \else
      \ifPOE@connjoin
        \def\POE@tempa{POE@conn@in@i}%
        \ifx\POE@tempa\POE@connIn
          \def\POE@tempb{POE@conn@out@o}
          \ifx\POE@tempb\POE@connOut
            \pscustom[style=Beam, linejoin=\POE@key@connjoin]{%
              \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}}%
          \else\ifx\@empty\POE@connOut
            \pscustom[style=Beam, linejoin=\POE@key@connjoin]{%
              \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}}%
          \else
            \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}%
          \fi\fi
        \else
          \def\POE@tempa{POE@conn@in@o}%
          \ifx\POE@tempa\POE@connIn
            \def\POE@tempb{POE@conn@out@o}
            \ifx\POE@tempb\POE@connOut
              \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}%
            \else\ifx\@empty\POE@connOut
              \pscustom[style=Beam, linejoin=\POE@key@connjoin]{%
                \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}}%
            \else
              \pscustom[style=Beam, linejoin=\POE@key@connjoin]{%
                \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}}%
            \fi\fi
          \else
            \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}%
          \fi
        \fi
      \else
        \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}%
      \fi
    \fi
  \fi
}%
%    \end{macrocode}
% \end{macro}
%
% \subsection{Old connection code}
%
% The old connection code for backward compatibility to version 2.x. As this is
% obsolete and was broken by design, there is no need to comment on this.
%    \begin{macrocode}
\def\optexp@nodeA{\oenodeIn{}}%
\def\optexp@nodeB{\oenodeOut{}}%
\define@key[psset]{optexp}{connjoin}{%
 \edef\POE@temp{#1}%
 \ifnum\POE@temp<0
   \POE@connjoinfalse
 \else\ifnum\POE@temp>2
   \POE@connjoinfalse
 \else
   \POE@connjointrue
   \edef\POE@key@connjoin{\POE@temp}
 \fi\fi
}%
\def\POE@key@conn{}%
\define@key[psset]{optexp}{conn}{%
  \edef\POE@key@conn{#1}%
  \expandafter\POE@psset@@conn\POE@key@conn\@empty-\@empty\@nil
  \if@pst\else
    \PackageError{pst-optexp}{Bad connection specification: #1}%
  \fi
}%
\def\POE@psset@@conn#1-#2\@empty#3\@nil{%
  \@psttrue
  \def\POE@next##1,#1-##2,##3\@nil{\def\POE@temp{##2}}%
  \expandafter\POE@next\POE@conntable,#1-#1,\@nil
  \@ifundefined{POE@conn@in@\POE@temp}%
    {\@pstfalse\def\POE@connIn{}}%
    {\edef\POE@connIn{POE@conn@in@\POE@temp}}%
  \@ifundefined{POE@conn@out@#2}%
    {\@pstfalse\def\POE@connOut{}}%
    {\def\POE@connOut{POE@conn@out@#2}}%
}%
\def\POE@connIn{}%
\def\POE@connOut{}%
\def\POE@conntable{,o-o,i-i,f-f}%
\def\POE@conn@out@{\ifPOE@insideobj\else\POE@conn@out@a\fi}%
\def\POE@conn@in@{\ifPOE@insideobj\else\POE@conn@in@a\fi}%
\def\POE@conn@in@o{%
  \psline[style=Beam](\oenodeRefA{})(\optexp@nodeA)%
}%
\def\POE@conn@out@o{%
  \psline[style=Beam](\optexp@nodeB)(\oenodeRefB{})%
}%
\def\POE@conn@in@f{%
  \pccurve[%
    angleA=!\POE@dict{/N@\oenodeRefA{} /N@\oenodeRefB{} SlopeAngle},
    angleB=!\POE@dict{/N@\oenodeRefB{} /N@\oenodeRefA{} SlopeAngle},
    style=FiberIn](\oenodeRefA{})(\optexp@nodeA)%
}%
\def\POE@conn@out@f{%
  \pccurve[%
    angleA=!\POE@dict{/N@\oenodeRefA{} /N@\oenodeRefB{} SlopeAngle},
    angleB=!\POE@dict{/N@\oenodeRefB{} /N@\oenodeRefA{} SlopeAngle},
    style=FiberOut](\optexp@nodeB)(\oenodeRefB{})%
}%
\def\POE@conn@in@i{%
  \def\pst@par{style=Beam}
  \begin@OpenObj
    \addto@pscode{%
      [%]
      \pst@optexpdict
        (\oenode{}{}) true GetInternalBeamNodesCompat
        /N@\oenodeRefA{} @GetCenter 
      end
    }%
  \psline@ii
}%
\def\POE@conn@out@i{%
  \def\pst@par{style=Beam}
  \begin@OpenObj
    \addto@pscode{%
      [%]
      \pst@optexpdict
        /N@\oenodeRefB{} @GetCenter
        (\oenode{}{}) true GetInternalBeamNodesCompat
      end
    }%
  \psline@ii
}%
\def\POE@conn@in@a{%
  dup xcheck not {
    \POE@dict{1 GetInternalBeamNodeCompat}
  } if
  exec
}%
\def\POE@conn@in@A{%
  dup xcheck not {
    false \POE@dict{GetInternalBeamNodesCompat} %
  } if
  exec
}%
\def\POE@conn@in@b{%
  dup xcheck not {
    \POE@dict{(N) GetInternalBeamNodeCompat}
  } if
  exec
}%
\def\POE@conn@in@B{%
  dup xcheck not {
    true \POE@dict{GetInternalBeamNodesCompat} %
  } if
  exec
}%
\let\POE@conn@out@a\POE@conn@in@a
\let\POE@conn@out@A\POE@conn@in@B
\let\POE@conn@out@b\POE@conn@in@b
\let\POE@conn@out@B\POE@conn@in@A
\def\drawbeam@compat{%
  \ifPOE@connjoin
    \setkeys+[psset]{optexp}{linejoin=\POE@key@connjoin}%
  \fi
  \addto@pscode{[% ]
    \POE@tempd\space
    \@nameuse{\POE@connOut}
    \POE@tempc\space
    \@nameuse{\POE@connIn}}%
  \psline@ii
\ignorespaces}%
%
%    \end{macrocode}
%
% \section{General purpose macros}
%
% \begin{macro}{\defShiftedNode}
%   This is provided only for backward compatibility, and should be replaced by
%   \cs{nodexn}.
%    \begin{macrocode}
\def\defShiftedNode(#1)(#2)#3{%
  \PackageWarning{pst-optexp}{%
    \string\defShiftedNode\space is deprecated,\MessageBreak
    use \string\nodexn\space(pst-node) instead.}%
  \pst@getcoor{#1}\pst@tempa%
  \pst@getcoor{#2}\pst@tempb%
  \pnode(! \pst@tempb \pst@tempa \POE@dict{VecAdd} \tx@UserCoor){#3}%
}%
%    \end{macrocode}
% \end{macro}
%
% \section{Accessing component nodes} 
% \begin{macro}{\POE@checkcompname}
%    \begin{macrocode}
\def\POE@checkcompname#1{%
  \@expandtwoargs\in@{,#1,}{,\POE@complist,}%
  \ifin@\else
    \PackageError{pst-optexp}{^^Jcompname '#1' undefined!^^J}
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@getlastcompname}
%    \begin{macrocode}
\def\POE@getlastcompname{%
  \expandafter\POE@getlastcompname@i \POE@complist,\relax,\@nil
}%
\def\POE@getlastcompname@i#1,#2,#3\@nil{#1}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\oenode}
%    \begin{macrocode}
\def\oenode#1#2{%
  \POE@str@basicname@prefix%
  \ifx\\#2\\%
    \ifnum9<1\POE@getlastcompname%
      \POE@str@basicname@default%
      \POE@getlastcompname%
    \else%
      \POE@getlastcompname%
      \POE@str@basicname@sep%
    \fi%
  \else%
    \ifnum9<1#2%
      \POE@str@basicname@default%
      #2%
    \else%
      #2\POE@str@basicname@sep%
    \fi%
  \fi%
  #1%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\oenodeExt}
% The external node which is set with \opt{extnode}.
%    \begin{macrocode}
\def\oenodeExt#1{\oenode{\POE@str@extnode@postfix}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeIn}
% The first (input) node of the component.
%    \begin{macrocode}
\def\oenodeIn#1{\oenode{1}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeOut}
%    \begin{macrocode}
\def\oenodeOut#1{\oenode{N}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeCenter}
%    \begin{macrocode}
\def\oenodeCenter#1{\oenode{Center}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeLabel}
%    \begin{macrocode}
\def\oenodeLabel#1{\oenode{Label}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeRefA}
%    \begin{macrocode}
\def\oenodeRefA#1{\oenode{A}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeRefB}
%    \begin{macrocode}
\def\oenodeRefB#1{\oenode{B}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeRotref}
%    \begin{macrocode}
\def\oenodeRotref#1{\oenode{Rotref}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeTrefA}
%    \begin{macrocode}
\def\oenodeTrefA#1{\oenode{TrefA}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeTrefB}
%    \begin{macrocode}
\def\oenodeTrefB#1{\oenode{TrefB}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenode@RefA}
%    \begin{macrocode}
\def\oenode@RefA#1{\oenode{@A}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenode@RefB}
%    \begin{macrocode}
\def\oenode@RefB#1{\oenode{@B}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenode@TrefA}
%    \begin{macrocode}
\def\oenode@TrefA#1{\oenode{@TrefA}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenode@TrefB}
%    \begin{macrocode}
\def\oenode@TrefB#1{\oenode{@TrefB}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeIfc}
%    \begin{macrocode}
\def\oenodeIfc#1#2{%
  \ifnum9<1#1 %
    \oenode{#1}{#2}%
  \else\ifx#1N %
    \oenode{#1}{#2}%
  \else\ifx#1C %
    \oenode{#1}{#2}%
  \else
    \PackageWarning{pst-optexp}{%
      \string\oenodeIfc\space node argument must be\MessageBreak
      integer, 'N', or 'C'}
  \fi\fi\fi
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeBeam}
%    \begin{macrocode}
\def\oenodeBeam#1{%
  \POE@str@basicname@prefix\POE@str@basicname@default Beam%
  \ifx\\#1\\1\else#1\fi
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeBeamUp}
%    \begin{macrocode}
\def\oenodeBeamUp#1{%
  \POE@str@basicname@prefix\POE@str@basicname@default BeamUp%
  \ifx\\#1\\1\else#1\fi
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeBeamLow}
%    \begin{macrocode}
\def\oenodeBeamLow#1{%
  \POE@str@basicname@prefix\POE@str@basicname@default BeamLow%
  \ifx\\#1\\1\else#1\fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \section{Components}
%
% \begin{macro}{\newOptexpComp@}
%    \begin{macrocode}
\def\newOptexpComp@#1#2{%
  \POE@Verb{%
    \tx@NodeScale
    [ #1 #2 \ifPOE@allowbeaminside true \else false \fi
      (\oenode{}{}) {\tx@ScreenCoor} 
      NewOptexpComp
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\newOptexpComp}
%    \begin{macrocode}
\def\newOptexpComp#1{%
  \newOptexpComp@{#1}{false}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\newOptexpCompAmb}
%    \begin{macrocode}
\def\newOptexpCompAmb#1{%
  \newOptexpComp@{#1}{true}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\newOptexpComp@}
%    \begin{macrocode}
\def\newOptexpFiberComp#1{%
  \POE@Verb{%
    \tx@NodeScale
    [ #1 (\oenode{}{}) {\tx@ScreenCoor}
      NewOptexpFiberComp
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\POE@compalias}
%   Components which have a \opt{compname} assigned, must also be available by
%   their component number. Here, all necessary informations (nodes, component
%   dictionary) are referenced such that any information is accessible via
%   numeber or name.
%    \begin{macrocode}
\def\POE@compalias#1#2{%
  \POE@Verb{%
%    \end{macrocode}
% Copy the component dictionary
%    \begin{macrocode}
    /\oenode{}{#1} dup currentdict exch known { 
      load /#2 ED 
    } { 
      pop 
    } ifelse
    (#2) (\oenode{}{#1})
    tx@NodeDict begin
%    \end{macrocode}
% Copy all interface nodes of the component.
%    \begin{macrocode}
      1 {
        3 copy inttostr dup 
        3 1 roll 2 copy NodeName
        currentdict exch known {
          NodeName load 3 1 roll NodeName ED
          1 add
        } {
          pop (N) NodeName load 3 1 roll 
          pop (N) NodeName ED
          pop exit
        } ifelse
      } loop
%    \end{macrocode}
% Copy all other nodes associated with the component (reference nodes, center
% node, label node etc).
%    \begin{macrocode}
      [ (A) (B) (@A) (@B) (Center) (Label) (Rotref) 
        (TrefA) (TrefB) (@TrefA) (@TrefB) (Ext)
      counttomark {
        counttomark 3 add -2 roll 2 copy counttomark 1 add 2 roll
        3 -1 roll dup 4 1 roll NodeName dup 
        currentdict exch known { 
          load 3 1 roll exch NodeName ED 
        } { 
          pop pop pop 
        } ifelse
      } repeat pop pop pop
    end
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optplane}
%   Define an invisible plane which is used only for ray tracing. The first node
%   is the origin, the second one is the difference vector.
%    \begin{macrocode}
\def\optplane{%
  \@ifnextchar[%]
    {\optplane@i}{\optplane@i[]}%
}%
\def\optplane@i[#1](#2){%
  \pst@getcoor{#2}\POE@tempa
%    \end{macrocode}
% Set the height to 0 to circumvent problems with the NA beeing too low
%    \begin{macrocode}
  \optplate[#1, plateheight=0, linestyle=none]%
    (! \POE@tempa exch 1 sub exch \tx@UserCoor)%
    (! \POE@tempa exch 1 add exch \tx@UserCoor)%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\begin@OptexpObj}
%    \begin{macrocode}
\def\begin@OptexpObj{%
  \global\advance\POE@cnt by 1
  \addbefore@par{compname={}}%
  \pst@killglue
  \begingroup
    \POE@insideobjtrue
    \POE@Verb{InitOptexpComp }%
    \use@par
%    \end{macrocode}
% The \opt{compshift} refers to the $y$-direction, shifting in $x$-direction
% is done by \opt{abspos} or \opt{position}
%    \begin{macrocode}
    \let\POE@key@comp@Yshift\POE@key@compshift%
    \def\POE@key@comp@Xshift{0}%
    \edef\POE@refnodeA{\oenodeRefA{}}%
    \edef\POE@refnodeB{\oenodeRefB{}}%
    \edef\POE@trefnodeA{\oenodeTrefA{}}%
    \edef\POE@trefnodeB{\oenodeTrefB{}}%
    \def\POE@transformnodes{%
      \POE@transformnode{\oenodeRefA{}}{\oenodeTrefA{}}%
      \POE@transformnode{\oenodeRefB{}}{\oenodeTrefB{}}%
    }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\begin@OptexpFiberObj}
%    \begin{macrocode}
\def\begin@OptexpFiberObj{%
  \begin@OptexpObj
    \ifPOE@nofiber@\else
      \setkeys+[psset]{optexp}{fiber@}%
    \fi}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\begin@OptexpTripole}
%    \begin{macrocode}
\let\POE@disablepos\relax
\def\begin@OptexpTripole{%
  \begin@OptexpObj
%    \end{macrocode}
% for multipoles the default shifting is in $x$-direction
%    \begin{macrocode}
  \def\POE@key@comp@Xshift{\POE@key@compshift\space neg }%
  \def\POE@key@comp@Yshift{0}%
%    \end{macrocode}
% The positioning parameters are disabled, because \opt{compshift} does the job for tripoles.
%    \begin{macrocode}
  \def\POE@disablepos{%
    \let\POE@key@abspos\@empty
    \let\POE@key@position\@empty
  }%
  \POE@positionrefnodes
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\POE@positionrefnodes}
%    \begin{macrocode}
\def\POE@positionrefnodes{%
  \edef\POE@refnodeA{\oenode@RefA{}}%
  \edef\POE@refnodeB{\oenode@RefB{}}%
  \edef\POE@trefnodeA{\oenode@TrefA{}}%
  \edef\POE@trefnodeB{\oenode@TrefB{}}%
  \def\POE@transformnodes{%
    \POE@transformnode{\oenodeRefA{}}{\oenodeTrefA{}}%
    \POE@transformnode{\oenodeRefB{}}{\oenodeTrefB{}}%
    \POE@transformnode{\oenode@RefA{}}{\oenode@TrefA{}}%
    \POE@transformnode{\oenode@RefB{}}{\oenode@TrefB{}}%
  }%
}%
%
% \begin{macro}{\end@OptexpObj}
%    \begin{macrocode}
\def\end@OptexpObj{%
  \ifnum9<1\POE@key@compname\else
    \POE@compalias{\POE@key@compname}{\oenode{}{\the\POE@cnt}}%
  \fi
  \endgroup
  \ignorespaces%
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\end@OptexpDipole}
%    \begin{macrocode}
\let\end@OptexpDipole\end@OptexpObj
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\end@OptexpTripole}
%    \begin{macrocode}
\let\end@OptexpTripole\end@OptexpObj
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\addafter@par}
%   Analog to \cs{addbefore@par} from pstricks.tex, but inserts new options at
%   the end of the current token register.  This can be useful to preset options
%   that are not allowed to be changed by the user.
%    \begin{macrocode}
\def\addafter@par#1{%
  \ifx\pst@par\@empty
    \def\pst@par{#1}%
  \else
    \toks@{#1}%
    \pst@toks\expandafter{\pst@par}%
    \edef\pst@par{\the\pst@toks,\the\toks@}%
  \fi%
}%
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\def\getCLWH{CLW \pst@number\psxunit 2 mul div }%
\def\getCLW{CLW \pst@number\psxunit div }%
\let\POE@restorerefnodes\relax
%    \end{macrocode}
% 
% New high-level macros 
% 1) Allow a compressed notation of all provided elements, as most of the organizing code 
%    is mostly equal.
%
% 2) Provide a rather easy-to-use interface for the user to allow new user-defined elements
%
% \begin{macro}{\newOptexpDipole}
%    \begin{macrocode}
\def\newOptexpDipole{%
  \@ifnextchar[%]
    {\POE@newdipole}{\POE@newdipole[]}%
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\newOptexpDipoleNolabel}
%    \begin{macrocode}
\def\newOptexpDipoleNolabel{%
  \PackageWarning{pst-optexp}{%
    \string\newOptexpDipoleNolabel\space is deprecated,\MessageBreak
    use \string\newOptexpDipole\space instead.}%
  \newOptexpDipole
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\newOptexpTripole}
%    \begin{macrocode}
\def\newOptexpTripole{%
  \@ifnextchar[%]
    {\POE@newtripole}{\POE@newtripole[]}%
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\newOptexpFiberDipole}
%    \begin{macrocode}
\def\newOptexpFiberDipole{%
  \@ifnextchar[%]
    {\POE@newfiberdipole}{\POE@newfiberdipole[]}%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@newdipole}
%    \begin{macrocode}
\def\POE@newdipole[#1]#2#3{%
  \@ifundefined{#2@i}{%
    \@namedef{#2}{\pst@object{#2}}%
    \expandafter\def\csname #2@i\endcsname(##1)(##2){%
      \@ifnextchar\bgroup%
        {\@nameuse{#2@i@}(##1)(##2)}%
        {\@nameuse{#2@i@}(##1)(##2){}}%
    }%
    \expandafter\def\csname #2@i@\endcsname(##1)(##2)##3{%
      \addbefore@par{#3}%
      \addafter@par{#1}%
      \begin@OptexpObj
        \ifPOE@backlayer
          \POE@regNodes{##1}{##2}
          \POE@extnodealign
        \fi
        \POE@drawcomponent[#2]{##3}{\@nameuse{#2@ii}}
        \ifPOE@backlayer
          \POE@Verb{(1) (N) (\oenode{}{}) CorrectDipoleNodes }%
          \POE@drawInternalConnections
        \fi
      \end@OptexpDipole
    }%
    \dipole@iimacro{#2}%
  }{%
    \PackageError{pst-optexp}{%
      dipole component `#2' already defined
    }%
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@newfiberdipole}
%    \begin{macrocode}
\def\POE@newfiberdipole[#1]#2#3{%
  \@ifundefined{#2@i}{%
    \@namedef{#2}{\pst@object{#2}}%
    \expandafter\def\csname #2@i\endcsname(##1)(##2){%
      \@ifnextchar\bgroup%
        {\@nameuse{#2@i@}(##1)(##2)}%
        {\@nameuse{#2@i@}(##1)(##2){}}%
    }%
    \expandafter\def\csname #2@i@\endcsname(##1)(##2)##3{%
      \addbefore@par{#3}%
      \addafter@par{#1}%
      \begin@OptexpFiberObj
        \ifPOE@backlayer
          \POE@regNodes{##1}{##2}
          \POE@extnodealign
        \fi
        \POE@drawcomponent[#2]{##3}{\@nameuse{#2@ii}}
        \ifPOE@backlayer
          \POE@Verb{(1) (N) (\oenode{}{}) CorrectDipoleNodes }%
          \ifPOE@fiber@
            \POE@drawInternalFibers
          \fi
        \fi
        \end@OptexpDipole
      }%
      \fiberdipole@iimacro{#2}%
   }{%
     \PackageError{pst-optexp}{%
       fiber dipole object `#2' already defined
     }%
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@newtripole}
% Equivalent to \cs{POE@newdipole} for tripole objects.
%    \begin{macrocode}
\def\POE@newtripole[#1]#2#3{%
  \@ifundefined{#2@i}{%
    \@namedef{#2}{\pst@object{#2}}%
    \expandafter\def\csname #2@i\endcsname(##1)(##2)(##3){%
      \@ifnextchar\bgroup{\@nameuse{#2@i@}(##1)(##2)(##3)}%
                         {\@nameuse{#2@i@}(##1)(##2)(##3){}}%
    }%
    \expandafter\def\csname #2@i@\endcsname(##1)(##2)(##3)##4{%
      \addbefore@par{#3}%
      \addafter@par{ref@angle=180,#1}%
      \begin@OptexpTripole
        \ifPOE@backlayer
          \POE@calcNodes{##1}{##2}{##3}%
          \POE@regNodes{##1}{##3}%
        \fi
        \POE@drawcomponent[#2]{##4}{\@nameuse{#2@ii}}
        \ifPOE@backlayer
          \POE@drawInternalConnections
        \fi
      \end@OptexpTripole
    }%
    \tripole@iimacro{#2}%
  }{%
    \PackageError{pst-optexp}{%
      tripole object `#2' already defined
    }%
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\dipole@iimacro}
%    \begin{macrocode}
\def\dipole@iimacro#1{%
  \POE@iimacro{#1}{\dipole@nodes}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fiberdipole@iimacro}
%    \begin{macrocode}
\def\fiberdipole@iimacro#1{%
  \POE@iimacro{#1}{\fiberdipole@nodes}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tripole@iimacro}
%    \begin{macrocode}
\def\tripole@iimacro#1{%
  \POE@iimacro{#1}{\tripole@nodes}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\POE@iimacro}
%    \begin{macrocode}
\def\POE@iimacro#1#2{%
  \@namedef{#1@ii}{%
    \ifPOE@backlayer
      \pnode(0,0){\oenodeCenter{}}%
    \fi
    \@ifundefined{#1@iii}{%
      \ifPOE@backlayer
        \@ifundefined{#1@nodes}{#2}{\@nameuse{#1@nodes}}%
      \fi
      \ifPOE@frontlayer
        \@nameuse{#1@comp}%
      \fi
    }{%
      \ifPOE@backlayer
        \PackageWarning{pst-optexp}{%
          Using #1@iii, please switch to the new\MessageBreak
          interface system.}%
        \@nameuse{#1@iii}%
      \fi
    }%
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\POE@newfiberquadrupole}
%    \begin{macrocode}
\def\optcoupler{\pst@object{optcoupler}}%
\def\optcoupler@i(#1)(#2)(#3)(#4){%
  \@ifnextchar\bgroup%
    {\@nameuse{optcoupler@i@}(#1)(#2)(#3)(#4)}%
    {\@nameuse{optcoupler@i@}(#1)(#2)(#3)(#4){}}%
}%
\def\optcoupler@i@(#1)(#2)(#3)(#4)#5{%
  \begin@OptexpFiberObj
    \ifPOE@backlayer
      \ifx\POE@key@coupleralign\POE@str@top
        \pnode(#1){\oenodeRefA{}}
        \pnode(#3){\oenodeRefB{}}
      \else\ifx\POE@key@coupleralign\POE@str@bottom
        \pnode(#2){\oenodeRefA{}}
        \pnode(#4){\oenodeRefB{}}
      \else
        \pst@getcoor{#1}\POE@tempa%
        \pst@getcoor{#2}\POE@tempb%
        \pnode(!\POE@tempa \POE@tempb 
                \POE@dict{VecAdd 0.5 VecScale}
                \tx@UserCoor){\oenodeRefA{}}
        \pst@getcoor{#3}\POE@tempa%
        \pst@getcoor{#4}\POE@tempb%
        \pnode(!\POE@tempa \POE@tempb 
                \POE@dict{VecAdd 0.5 VecScale}
                \tx@UserCoor){\oenodeRefB{}}
      \fi\fi
    \fi
    \POE@drawcomponent[optcoupler]{#5}{\@nameuse{optcoupler@ii}}
    \ifPOE@backlayer
      \POE@Verb{%
        (1) (3) (\oenode{}{}) CorrectDipoleNodes 
        (2) (N) (\oenode{}{}) CorrectDipoleNodes 
      }%
      \ifPOE@fiber@
        \ifPOE@fiberin@
          \ifPOE@fiberin@top
            \drawfiber@{FiberIn1}[stopnode=1]{(#1)}%
                                             {\POE@key@compname}
          \fi
          \ifPOE@fiberin@bottom
            \drawfiber@{FiberIn2}[stopnode=2]{(#2)}%
                                             {\POE@key@compname}
          \fi
        \fi
        \ifPOE@fiberout@
          \ifPOE@fiberout@top
            \drawfiber@{FiberOut}[startnode=3]{\POE@key@compname}%
                                              {(#3)}
          \fi
          \ifPOE@fiberout@bottom
            \drawfiber@{FiberOut2}[startnode=N]{\POE@key@compname}%
                                               {(#4)}
          \fi
        \fi
      \fi
    \fi
  \end@OptexpObj
}%
\fiberdipole@iimacro{optcoupler}%
%    \end{macrocode}
% \end{macro}
% 
% 
% \begin{macro}{\wdmsplitter}
%    \begin{macrocode}
\def\wdmsplitter{\pst@object{wdmsplitter}}%
\def\wdmsplitter@i(#1)(#2)(#3){%
  \@ifnextchar\bgroup%
    {\wdmsplitter@i@(#1)(#2)(#3)}%
    {\wdmsplitter@i@(#1)(#2)(#3){}}%
}%
\def\wdmsplitter@i@(#1)(#2)(#3)#4{%
  \begin@OptexpFiberObj
    \ifPOE@backlayer
      \pnode(#1){\oenodeRefA{}}
      \ifx\POE@key@coupleralign\POE@str@top
         \pnode(#2){\oenodeRefB{}}
      \else\ifx\POE@key@coupleralign\POE@str@bottom
         \pnode(#3){\oenodeRefB{}}
      \else
         \pst@getcoor{#2}\POE@tempa%
         \pst@getcoor{#3}\POE@tempb%
         \pnode(!\POE@tempa \POE@tempb 
                 \POE@dict{VecAdd 0.5 VecScale}
                 \tx@UserCoor){\oenodeRefB{}}
      \fi\fi
    \fi
    \POE@drawcomponent[wdmsplitter]{#4}\wdmsplitter@ii
    \ifPOE@backlayer
      \POE@Verb{(1) (N) (\oenode{}{}) CorrectDipoleNodes }%
      \ifPOE@fiber@
        \ifPOE@fiberin@
          \drawfiber@{FiberIn}[stopnode=1]{(#1)}{\POE@key@compname}
        \fi
        \ifPOE@fiberout@
          \ifPOE@fiberout@top
            \drawfiber@{FiberOut1}[startnode=2]%
              {\POE@key@compname}{(#2)}
          \fi
          \ifPOE@fiberout@bottom
            \drawfiber@{FiberOut2}[startnode=N]%
              {\POE@key@compname}{(#3)}
          \fi
        \fi
      \fi
    \fi
  \end@OptexpObj
}%
\fiberdipole@iimacro{wdmsplitter}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmcoupler}
%    \begin{macrocode}
\def\wdmcoupler{\pst@object{wdmcoupler}}%
\def\wdmcoupler@i(#1)(#2)(#3){%
  \@ifnextchar\bgroup%
    {\wdmcoupler@i@(#1)(#2)(#3)}%
    {\wdmcoupler@i@(#1)(#2)(#3){}}%
}%
\def\wdmcoupler@i@(#1)(#2)(#3)#4{%
  \begin@OptexpFiberObj
    \ifPOE@backlayer
      \pnode(#3){\oenodeRefB{}}
      \ifx\POE@key@coupleralign\POE@str@top
         \pnode(#1){\oenodeRefA{}}
      \else\ifx\POE@key@coupleralign\POE@str@bottom
         \pnode(#2){\oenodeRefA{}}
      \else
         \pst@getcoor{#1}\POE@tempa%
         \pst@getcoor{#2}\POE@tempb%
         \pnode(!\POE@tempa \POE@tempb 
                 \POE@dict{VecAdd 0.5 VecScale}
                 \tx@UserCoor){\oenodeRefA{}}
      \fi\fi
    \fi
    \POE@drawcomponent[wdmcoupler]{#4}\wdmcoupler@ii
    \ifPOE@backlayer 
      \POE@Verb{(1) (N) (\oenode{}{}) CorrectDipoleNodes }%
      \ifPOE@fiber@
        \ifPOE@fiberout@
          \drawfiber@{FiberOut}[startnode=N]{\POE@key@compname}{(#3)}
        \fi
        \ifPOE@fiberin@
          \ifPOE@fiberin@top
            \drawfiber@{FiberIn1}[stopnode=1]{(#1)}{\POE@key@compname}
          \fi 
          \ifPOE@fiberin@bottom
            \drawfiber@{FiberIn2}[stopnode=2]{(#2)}{\POE@key@compname}
          \fi
        \fi
      \fi
    \fi
  \end@OptexpObj
}%
\fiberdipole@iimacro{wdmcoupler}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\optcirculator}
%    \begin{macrocode}
\def\optcirculator{\pst@object{optcirculator}}%
\def\optcirculator@i(#1)(#2)(#3){%
  \@ifnextchar\bgroup%
    {\optcirculator@i@(#1)(#2)(#3)}%
    {\optcirculator@i@(#1)(#2)(#3){}}%
}%
\def\optcirculator@i@(#1)(#2)(#3)#4{%
  \addafter@par{ref@angle=180}%
  \begin@OptexpFiberObj
    \ifPOE@backlayer
      \POE@regNodes{#1}{#3}
      \ifx\POE@key@position\@empty
        \ifx\POE@key@abspos\@empty
          \POE@positionrefnodes
          \pst@getcoor{#1}\POE@tempa%
          \pst@getcoor{#2}\POE@tempb%
          \pst@getcoor{#3}\POE@tempc%
          \pnode(! \POE@dict{%
            \POE@tempa \tx@UserCoor 2 copy 2 copy 
            \POE@tempc \tx@UserCoor 4 2 roll @ABVect
            2 copy 2 copy 10 4 roll
            \POE@tempb \tx@UserCoor 6 -2 roll @ABVect
            4 2 roll tx@EcldDict begin Project end VecAdd
            2 copy 6 -2 roll -0.5 VecScale VecAdd
          }){\oenode@RefA{}}%
          \pnode(! \POE@dict{4 2 roll 0.5 VecScale VecAdd})%
            {\oenode@RefB{}}%
        \fi
      \fi
    \fi
    \POE@drawcomponent[optcirculator]{#4}\optcirculator@ii
    \ifPOE@backlayer
      \ifPOE@fiber@
        \ifPOE@fiberin@
          \drawfiber@{FiberIn}[stopnode=1]{(#1)}{\POE@key@compname}
        \fi
        \ifPOE@fiberout@
          \ifPOE@fiberout@top
            \drawfiber@{FiberOut1}[startnode=N]%
              {\POE@key@compname}{(#3)}
          \fi
          \ifPOE@fiberout@bottom
            \drawfiber@{FiberOut2}[startnode=2, fiberalign=center]%
              {\POE@key@compname}{(#2)}
          \fi
        \fi
      \fi
    \fi
  \end@OptexpObj
}%
\fiberdipole@iimacro{optcirculator}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\POE@calcNodes}
%   Some of the components need three points to be positioned. 
%   These are:
%
% \begin{enumerate}
% \item starting point of the beam (in the PS-Code: (XA,YA)) 
% \item reflection point on the surface (XG, YG) 
% \item end point (XB,YB)
%  \end{enumerate}     
%
%  With these three points \cs{poe@calcNodes} calculates two new points 'tempNode@A' 
%  and 'tempNode@B', between which the component is placed by the macro 
%  \cs{poe@drawcomponent} in the way, that 'angle of incidence' == 'angle of deflection'
%  regarding the reflection surface (mirror, diagonal of the beamsplitter, 
%  grid etc.)
%    \begin{macrocode}
\def\POE@calcNodes#1#2#3{{%
  \pst@getcoor{#1}\POE@tempa%
  \pst@getcoor{#2}\POE@tempb%
  \pst@getcoor{#3}\POE@tempc%
  \pnode(! \POE@dict{%
    \POE@tempa \tx@UserCoor
    \POE@tempc \tx@UserCoor
    \POE@tempb \tx@UserCoor
    calcNodes
    X@A Y@A}){\oenode@RefA{}}%
  \pnode(! \POE@dict{X@B Y@B}){\oenode@RefB{}}%
}\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@regNodes}
% If a macro needs only two points, they are equivalent to 
% 'tempNode@A' and 'tempNode@B'. But for easier implementation of other 
% macros the given points are assigned to the temporary nodes.
%    \begin{macrocode}
\def\POE@regNodes#1#2{%
  \pnode(#1){\oenodeRefA{}}
  \pnode(#2){\oenodeRefB{}}
  \POE@Verb{%
    /@xref \POE@key@extnode@xref\space def 
    /@yref \POE@key@extnode@yref\space def
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@extnodealign}
%    \begin{macrocode}
\def\POE@extnodealign{%
  \ifx\POE@key@extnodealign\POE@str@absolute
    \POE@Verb{%
      /N@\oenodeRefA{} @GetCenter /N@\oenodeRefB{} @GetCenter
      @ABVect exch
      dup 0 gt 3 1 roll 0 eq exch 0 lt and or
      { /RefFac -1 def } if
    }%
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@pnode@shiftedrot}
% Define a new node \#3 shifted by (\#1) relative to existing node \#2.
% Aditionally rotate the new node by \#4 degree around existing node as origin.
%    \begin{macrocode}
\def\POE@pnode@shiftedrot(#1)#2#3#4{%
  \pst@getcoor{#1}\POE@temp%
  \pnode(!%
    \POE@temp /YDiff ED /XDiff ED %
    /N@#2 load GetCenter /YShifted ED /XShifted ED
    /rot@angle #4 \POE@key@labelrefangle\space add def
    /XDiff@Rot rot@angle cos XDiff mul rot@angle sin YDiff mul add def
    /YDiff@Rot rot@angle cos YDiff mul rot@angle sin XDiff mul sub def
    XShifted XDiff@Rot add YShifted YDiff@Rot add neg \tx@UserCoor
  ){#3}%
  \psset[optexp]{ref@angle=0}
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\POE@nlput}
%   We cannot use \cs{nlput} from \opt{pst-node}, because that does not work
%   correctly for negative distances together with \opt{nrot=:U}, which happens
%   for \opt{position=start}.
%    \begin{macrocode}
\def\POE@nlput{\pst@object{POE@nlput}}
\def\POE@nlput@i(#1)(#2)#3#4{%
  \begin@SpecialObj
  \POE@LDNode(#1)(#2){#3}
  \pcline[linestyle=none](temp@nlputA)(temp@nlputB)%
  \ncput[npos=0.5]{#4}%
  \end@SpecialObj}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\POE@LDNode}
%    \begin{macrocode}
\def\POE@LDNode(#1)(#2)#3{%
  \pst@getcoor{#1}\pst@tempA%
  \pst@getcoor{#2}\pst@tempB%
  \pnode(!
    \pst@tempA \tx@UserCoor /YA ED /XA ED
    \pst@tempB \tx@UserCoor /YB ED /XB ED
    /dx XB XA sub def
    /dy YB YA sub def
    /angle dy dx Atan def
    XA #3 1 sub angle cos mul add 
    YA #3 1 sub angle sin mul add ){temp@nlputA}%
  \pnode(!
    \pst@tempA \tx@UserCoor /YA ED /XA ED
    \pst@tempB \tx@UserCoor /YB ED /XB ED
    /dx XB XA sub def
    /dy YB YA sub def
    /angle dy dx Atan def
    XA #3 1 add angle cos mul add 
    YA #3 1 add angle sin mul add ){temp@nlputB}%
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@putlabelrelative}
% Used to put the label for labelref=relative
%    \begin{macrocode}
\def\POE@putlabelrelative#1{%
  \nput[labelsep=0]{\POE@key@labelangle}%
       {\oenodeLabel{}}%
       {\rput[\POE@key@labelalign](0,0){\POE@key@labelstyle #1}}%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@putcomp}
%   Place the component in argument \#1 and define a new node
%   \oenodeLabel{} for positioning of the label.
%    \begin{macrocode}
\def\POE@putcomp#1{%
   \rput(! \POE@key@comp@Xshift\space\POE@key@comp@Yshift){%
     \pnode(! \POE@dict{
       \POE@key@rotate@xref\space
       \POE@key@rotate@yref\space
       DefineExtNode}){\oenodeRotref{}}%
     \ifdim\POE@key@angle pt=0pt
        #1%
        \POE@pnode@shiftedrot(0,\POE@key@labeloffset)%
                             {\oenodeCenter{}}%
                             {\oenodeLabel{}}%
                             {\POE@key@labelangle}%
     \else
        \psrotate(\oenodeRotref{}){\POE@key@angle}{%
          #1%
          \POE@pnode@shiftedrot(0,\POE@key@labeloffset)%
                               {\oenodeCenter{}}%
                               {\oenodeLabel{}}%
                               {\POE@key@labelangle}%
        }%
     \fi%
   }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@putlabel}
% Positioning of the label depending on the reference coordinates.
% Needs possibly a previously defined node \cs{oenodeLabel} which
% marks exactly the position of the label relative to the component.
% This is defined by calling \cs{poe@putcomp}.
%    \begin{macrocode}  
\def\POE@putlabel#1{%
  \def\POE@temp{#1}%
%    \end{macrocode}
% Put the label only if it's not empty.
%    \begin{macrocode}
  \ifx\POE@temp\@empty\else
%    \end{macrocode}
% For \opt{global} positioning, the label is placed in global coordinate system
% with respect to the center node.
%    \begin{macrocode}
  \ifx\POE@key@labelref\POE@str@labelref@global
    \nput[labelsep=\POE@key@labeloffset]%
      {\POE@key@labelangle}%
      {\oenodeCenter{}}%
      {\pnode(0,0){\oenodeLabel{}}%
       \rput[\POE@key@labelalign](0,0){\POE@key@labelstyle #1}}%
%    \end{macrocode}
% Rotate the label node together with the component, but do not rotate the label
% text itself.
%    \begin{macrocode}
  \else\ifx\POE@key@labelref\POE@str@labelref@relgrav
    \rput[\POE@key@labelalign](\oenodeLabel{}){%
      \POE@key@labelstyle #1}%
%    \end{macrocode}
% Rotate label node and label text with the component.
%    \begin{macrocode}
  \else\ifx\POE@key@labelref\POE@str@relative
    \begingroup
%    \end{macrocode}
% Redefine InitNC only for positioning of the label with labelref=relative
%    \begin{macrocode}
    \pst@def{InitNC}< % kindly contributed by Herbert Voss
      /b ED /a ED
      /NodeSepTypeB ED /NodeSepTypeA ED
      /NodeSepB ED /NodeSepA ED
      /OffsetB ED /OffsetA ED
      tx@NodeDict a known tx@NodeDict b known and dup {
        /NodeA a load def /NodeB b load def
        NodeA GetCenter NodeB GetCenter
        4 copy exch 4 -1 roll 2 copy gt
          { pop pop pop pop /yB ED /xB ED /yA ED /xA ED }
          { eq 3 1 roll lt and 
              { /yB ED /xB ED /yA ED /xA ED} 
              { /yA ED /xA ED /yB ED /xB ED} ifelse
          } ifelse
      } if >%
      \ncline[linestyle=none,fillstyle=none, npos=]%
             {\POE@trefnodeA}{\POE@trefnodeB}%
      \ifx\POE@key@position\@empty
        \ifx\POE@key@abspos\@empty
          \ncput[nrot=:U,npos=]{\POE@putlabelrelative{#1}}%
        \else
          \POE@nlput[nrot=:U](\POE@trefnodeA)(\POE@trefnodeB)%
            {\POE@key@abspos}{\POE@putlabelrelative{#1}}%
        \fi
      \else
        \ncput[nrot=:U, npos=\POE@key@position]%
          {\POE@putlabelrelative{#1}}%
      \fi
    \endgroup
  \fi\fi\fi
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Free-ray components}
%
% Define all free-ray dipoles
%    \begin{macrocode}
\newOptexpDipole{lens}{}%
\newOptexpDipole{pinhole}{}%
\newOptexpDipole{crystal}{}%
\newOptexpDipole{polarization}{}%
\newOptexpDipole{optbox}{}%
\newOptexpDipole{optplate}{}%
\newOptexpDipole{optretplate}{}%
\newOptexpDipole[endbox]{optdetector}{}%
\newOptexpDipole{optdiode}{allowbeaminside=false}%
\newOptexpDipole{doveprism}{}%
%    \end{macrocode}
% 
% Define all free-ray tripoles
%    \begin{macrocode}
\newOptexpTripole{mirror}{}%
\newOptexpTripole[ref@angle=-135]{beamsplitter}{}%
\newOptexpTripole{optgrating}{}%
\def\optgrid{%
  \PackageWarning{pst-optexp}{%
    \string\optgrid\space is deprecated,\MessageBreak
    use \string\optgrating\space instead.}%
  \optgrating%
}%
\newOptexpTripole[ref@angle=-135]{pentaprism}{}%
\newOptexpTripole[ref@angle=-135]{rightangleprism}{}%
\newOptexpTripole[ref@angle=-135]{optprism}{}%
%    \end{macrocode}
%
% \begin{macro}{\optdipole}
%    \begin{macrocode}
\def\optdipole{\pst@object{optdipole}}
\def\optdipole@i(#1)(#2)#3#4{%
   \begin@OptexpObj
      \ifPOE@backlayer
        \POE@regNodes{#1}{#2}
        \POE@extnodealign
      \fi
      \POE@drawcomponent{#4}{%
        \ifPOE@backlayer
          \pnode(0,0){\oenodeCenter{}}%
          \newOptexpComp{{0 0} {0 1} 0 0 trans {PlainIfc} 1 }%
        \fi
        \ifPOE@frontlayer
          #3
        \fi
      }%
      \ifPOE@backlayer
        \POE@drawInternalConnections
      \fi
   \end@OptexpObj
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\opttripole}
%    \begin{macrocode}
\def\opttripole{\pst@object{opttripole}}
\def\opttripole@i(#1)(#2)(#3)#4#5{%
  \begin@OptexpTripole
    \ifPOE@backlayer   
      \POE@regNodes{#1}{#3}%
      \POE@calcNodes{#1}{#2}{#3}%
    \fi
    \POE@drawcomponent{#5}{%
      \pnode(0,0){\oenodeCenter{}}% 
      \newOptexpComp{{0 0} {1 0} 0 0 refl {PlainIfc} 1 }%
      #4
    }%
    \POE@drawInternalConnections
  \end@OptexpTripole
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\fibercollimator}
%    \begin{macrocode}
\def\fibercollimator{\pst@object{fibercollimator}}
\def\fibercollimator@i(#1)(#2){%
   \def\POE@tempa{#1}%
   \def\POE@tempb{#2}%
   \def\POE@tempc{}%
   \def\POE@tempd{}%
   \@ifnextchar(%)
     {\fibercollimator@ii}{\fibercollimator@iv}%
}%
\def\fibercollimator@ii(#1){%
   \def\POE@tempc{#1}%
   \@ifnextchar(%)
     {\fibercollimator@iii}{\fibercollimator@iv}%
}%
\def\fibercollimator@iii(#1){%
   \def\POE@tempd{#1}%
   \fibercollimator@iv
}%
\def\fibercollimator@iv{%
  \@ifnextchar\bgroup{\fibercollimator@v}{\fibercollimator@v{}}%
}%
\def\fibercollimator@v#1{%
  \begin@OptexpFiberObj
    \ifPOE@backlayer
      \POE@regNodes{\POE@tempa}{\POE@tempb}%
      \POE@extnodealign
    \fi
    \POE@drawcomponent[fibercollimator]{#1}{%
       \pnode(0,0){\oenodeCenter{}}%
       \ifPOE@backlayer
         \fibercollimator@nodes
       \fi
       \ifPOE@frontlayer
         \fibercollimator@comp
       \fi
    }%
    \ifPOE@backlayer
      \ifPOE@beam
        \drawbeam{(\oenodeRefA{})}{\POE@key@compname}
      \fi
      \ifPOE@fiber@
        \ifPOE@fiberout@
          \ifx\@empty\POE@tempc
            \drawfiber{\POE@key@compname}{(\oenodeRefB{})}
          \else\ifx\@empty\POE@tempd
            \psbezier[style=FiberOut](\oenodeOut{})(\POE@tempb)%
                                     (\POE@tempb)(\POE@tempc)%
          \else
            \psbezier[style=FiberOut](\oenodeOut{})(\POE@tempb)%
                                     (\POE@tempc)(\POE@tempd)%
          \fi\fi
        \fi
      \fi
    \fi
  \end@OptexpObj
}%
%    \end{macrocode}
% \end{macro}
% 
% Define all fiber dipoles
%    \begin{macrocode}
\newOptexpFiberDipole{optfiber}{newOptComp={}}
\newOptexpFiberDipole{optamp}{}
\newOptexpFiberDipole{optmzm}{}
\newOptexpFiberDipole{optfilter}{allowbeaminside=false}
\newOptexpFiberDipole{polcontrol}{}
\newOptexpFiberDipole{optisolator}{}
\newOptexpFiberDipole{optfiberpolarizer}{}
\newOptexpFiberDipole{optswitch}{}
\newOptexpFiberDipole{fiberdelayline}{}
%    \end{macrocode}
%
% \begin{macro}{\POE@drawcomponent}
% This macro is called by every unit
% The first parameter contains the label, the second one the drawing code
%    \begin{macrocode}
\def\POE@drawcomponent{%
  \@ifnextchar[%]
    {\POE@drawcomponent@i}{\POE@drawcomponent@i[]}%
}%
\def\POE@drawcomponent@i[#1]#2#3{%
  \def\@@comp{%
    #3%
    \ifx\POE@key@extnode\@empty\else
      \ifPOE@backlayer
        \pnode(! \POE@dict{
          \POE@key@extnode@xref\space
          \POE@key@extnode@yref\space
          DefineExtNode}){\oenodeExt{}}%
        \POE@Verb{%
          tx@NodeDict begin /N@\oenodeExt{} load
          \ifnum9<1\POE@key@compname
            /N@ExtNode 
          \else
            /N@\POE@key@compname ExtNode 
          \fi
          ED end 
        }%
      \fi
    \fi
  }%
  \@ifundefined{#1@ref}{}{\@nameuse{#1@ref}}%
  \ifPOE@endbox
    \psset[optexp]{abspos={%
      \POE@dict{%
        /N@\POE@refnodeA\space @GetCenter \tx@UserCoor 
        /N@\POE@refnodeB\space @GetCenter \tx@UserCoor 
        @ABDist @@x0 @@x add add 
      }%
    }}%
  \else\ifPOE@startbox
    \psset[optexp]{abspos={\POE@dict{ @@x0 neg @@x sub }}}%
  \fi\fi
  \POE@disablepos
  \ncline[linestyle=none,fillstyle=none,npos=]%
    {\POE@refnodeA}{\POE@refnodeB}%
%    \end{macrocode}
% Positioning of the component
%    \begin{macrocode}
  \begingroup
    \psset{style=OptComp}%
%    \end{macrocode}
% linestyle to use, if component should be marked as optional
%    \begin{macrocode}
    \ifPOE@component@optional
      \psset{style=OptionalStyle}%
    \fi
%    \end{macrocode}
% If parameter \opt{position} is given, use it for \opt{npos}.
%    \begin{macrocode}
    \ifx\POE@key@abspos\@empty
%    \end{macrocode}
% Then check if absolute positioning with \opt{abspos} is wanted.
%    \begin{macrocode}
      \ifx\POE@key@position\@empty
        \ncput[nrot=:U,npos=]{\POE@putcomp{\@@comp}}%
      \else
        \ncput[nrot=:U,npos=\POE@key@position]{\POE@putcomp{\@@comp}}%
      \fi
    \else
      \POE@nlput[nrot=:U](\POE@refnodeA)(\POE@refnodeB)%
        {\POE@key@abspos}{\POE@putcomp{\@@comp}}%
    \fi
  \endgroup
  \ifPOE@backlayer
    \POE@transformnodes
  \fi
  \ifPOE@frontlayer
    \POE@putlabel{#2}%
  \fi
%    \end{macrocode}
% Show some special dots for debugging
%    \begin{macrocode}
  \ifPOE@debug@showoptdots
    \ifPOE@backlayer
      \psdot[linecolor=red](\oenodeCenter{})
      \psdot[linecolor=red, dotstyle=x, dotscale=1.5](\oenodeLabel{})
      \psdot[linecolor=black](\oenodeRefA{})
      \psdot[linecolor=black](\oenodeRefB{})
      \psdot[linecolor=black, dotstyle=x, 
             dotscale=1.5](\oenodeTrefA{})
      \psdot[linecolor=black, dotstyle=x, 
             dotscale=1.5](\oenodeTrefB{})
    \fi
  \fi
  \ifPOE@debug@showifcnodes
    \ifPOE@backlayer
      \POE@ifcnodes[style=IfcNodeStyle]
    \fi
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{POE@transformnode}
%   Transform node \opt{\#1} according to the positioning parameters
%   (\opt{compshift}, \opt{position}, and \opt{abspos}) with respect to the
%   rotation reference node and define it as \opt{\#2}.
%    \begin{macrocode}
\def\POE@transformnode#1#2{%
  \pnode(!
    \POE@dict{%
      /N@\oenodeRotref{} @GetCenter 2 copy
      /N@#1 @GetCenter 
      \POE@key@comp@Xshift\space\POE@key@comp@Yshift\space
      \tx@ScreenCoor VecAdd 4 2 roll @ABVect 
      \POE@key@angle\space matrix rotate dtransform VecAdd
      \tx@UserCoor
    }){#2}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\POE@ifcnodes}
%    \begin{macrocode}
\def\POE@ifcnodes{\pst@object{POE@ifcnodes}}
\def\POE@ifcnodes@i{%
  \begin@SpecialObj%
  \solid@star%
  \addto@pscode{
    \psk@dotsize
    \@nameuse{psds@\psk@dotstyle}
    \POE@dict{[ (\oenode{}{}) false GetInternalBeamNodes %]
      counttomark 2 idiv { Dot } repeat
      pop}
    }%
  \end@SpecialObj
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\tripole@nodes}
%    \begin{macrocode}
\def\tripole@nodes{%
  \newOptexpComp{{0 0} {1 0} @@x neg @@x refl {PlainIfc} 1}%
  \pnode(! \POE@dict{@@y0 @@x0}){\oenodeCenter{}}
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\dipole@nodes}
%    \begin{macrocode}
\def\dipole@nodes{%
  \newOptexpComp{%
    {@@x0 @@x sub 0} {0 1} @@y0 @@y sub @@y0 @@y add trans {PlainIfc} 
    @@x 0 eq not {
      {@@x0 @@x add 0} {0 1} @@y0 @@y sub @@y0 @@y add trans {PlainIfc}
    } if \POE@key@n }%
  \pnode(! \POE@dict{@@x0 @@y0}){\oenodeCenter{}}
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{fiberdipole@nodes}
%    \begin{macrocode}
\def\fiberdipole@nodes{%
  \newOptexpFiberComp{%
    {@@x0 @@x sub 0}
    @@x 0 eq not {
      {@@x0 @@x add 0}
    } if }%
  \pnode(! \POE@dict{@@x0 @@y0}){\oenodeCenter{}}
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Free-ray components}
%
% \subsubsection{mirror}
%
% \begin{macro}{\mirror@ref}
%    \begin{macrocode}
\def\mirror@ref{%
  \ifx\POE@key@mirrortype\POE@str@mirrortype@piezo
    \POE@Verb{/@@y0 \pst@number\psyunit def}%
    \bgroup
      \psset{style=PiezoMirror}
      \POE@Verb{%
        \pst@number\psyunit @@y0 div 
        \POE@key@mirrorwidth\space 0.5 mul mul 2.5 div /@@y0 ED
      }%
    \egroup
  \else\ifdim\POE@key@mirrorradius pt=0pt
    \POE@Verb{/@@x \POE@key@mirrorwidth\space 0.5 mul def}%
  \fi\fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\mirror@nodes}
%    \begin{macrocode}
\def\mirror@nodes{%
   \newOptexpComp{%
     {0 0} 
     \ifdim\POE@key@mirrorradius pt=0pt
       {1 0} \POE@key@mirrorwidth\space -0.5 mul dup neg refl {PlainIfc}
     \else
       {0 \POE@key@mirrorradius\space neg} 
       \POE@key@mirrorwidth\space -0.5 mul dup neg 
       refl {CurvedIfc}
     \fi
     1 %
   }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\mirror@comp}
%    \begin{macrocode}
\def\mirror@comp{%
  \edef\@ht{%
    \POE@key@mirrorwidth\space\pst@number\psyunit mul 0.5 mul %
  }%
  \edef\@dp{\POE@key@mirrordepth\space\pst@number\psxunit mul }%
  \edef\@r{\POE@key@mirrorradius\space\pst@number\psxunit mul }%
  \edef\@postcode{%
    neg 5 -1 roll exch 5 2 roll 90 add exch 90 add exch ArcR %
  }%
  \edef\@extpostcode{%
    neg \@dp add 5 -1 roll exch 5 2 roll 90 add exch 90 add %
  }%
%    \end{macrocode}
% concave mirrors
%    \begin{macrocode}
  \ifdim\POE@key@mirrorradius pt<0pt
    \ifx\POE@key@mirrortype\POE@str@mirrortype@extended
%    \end{macrocode}
% extended concave mirror
%    \begin{macrocode}
      \bgroup
        \psset{style=ExtendedMirror}
        \begin@ClosedObj
          \addto@pscode{%
            \pst@optexpdict \@ht \@r rightCurvedIfc \@postcode  
            \@ht \@r rightCurvedIfc \@extpostcode arc
            closepath end}%
        \end@ClosedObj
      \egroup
    \fi
    \begin@OpenObj
      \addto@pscode{\POE@dict{ \@ht \@r rightCurvedIfc \@postcode }}%
    \end@OpenObj
%    \end{macrocode}
% convex mirrors
%    \begin{macrocode}
  \else\ifdim\POE@key@mirrorradius pt>0pt
    \ifx\POE@key@mirrortype\POE@str@mirrortype@extended
%    \end{macrocode}
% extended convex mirror
%    \begin{macrocode}
      \bgroup
        \psset{style=ExtendedMirror}
        \begin@ClosedObj
          \addto@pscode{%
            \pst@optexpdict \@ht \@r rightCurvedIfc \@postcode
            \@ht \@r rightCurvedIfc \@extpostcode arcn
            closepath end}%
        \end@ClosedObj
      \egroup
    \fi
   \begin@OpenObj
     \addto@pscode{\POE@dict{ \@ht \@r rightCurvedIfc \@postcode }}%
   \end@OpenObj
  \else
%    \end{macrocode}
% plain mirror 
%    \begin{macrocode}
    \edef\@ht{\POE@key@mirrorwidth\space 0.5 mul }%
    \ifPOE@variable
      \psarc[style=VariableMirror](! \@ht 0.4 sub 0){0.6}{-20}{20}
      \psarc[style=VariableMirror](! 0.4 \@ht sub 0){0.6}{160}{200}
     \fi%
     \ifx\POE@key@mirrortype\POE@str@mirrortype@piezo%
       \psframe[style=PiezoMirror,
                dimen=outer](! \@ht 4 div 0)%
                            (! \@ht -4 div \@ht 2.5 div)
       \ifx\POE@key@extnode\@empty
         \psbezier(! 0 \@ht 2.5 div)%
                  (! 0 \@ht 1.5 div)%
                  (! \@ht 2 div \@ht 2 div)%
                  (! \@ht 4 div \@ht)%
       \fi
    \else\ifx\POE@key@mirrortype\POE@str@mirrortype@extended%
      \psframe[style=ExtendedMirror]%
         (! \@ht neg \POE@key@mirrordepth\space )%
         (! \@ht 0)%
    \fi\fi
    \psline[linewidth=\POE@key@mirrorlinewidth]%
      (! \@ht neg \getCLWH)%
      (! \@ht \getCLWH)
  \fi\fi
}%
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{lens}
%
% \begin{macro}{\lens@ref}
%    \begin{macrocode}
\def\lens@ref{%
  \ifdim\POE@key@lensradiusleft pt=0pt
    \edef\@th{0 }%
  \else
    \edef\@th{%
      \ifPOE@thicklens 
        \POE@key@lenswidth\space 0.5 mul
      \else
        \ifdim\POE@key@lensradiusleft pt<0pt
          \POE@key@lensheight\space 0.075 mul
        \else
          \POE@key@lensradiusleft
          \POE@key@lensheight\space 0.5 mul capHeight
        \fi
      \fi
    \space}%     
  \fi
  \ifdim\POE@key@lensradiusright pt=0pt\else
    \edef\@th{%
      \@th\space
      \ifPOE@thicklens 
        \POE@key@lenswidth\space 0.5 mul
      \else
        \ifdim\POE@key@lensradiusright pt<0pt
          \POE@key@lensheight\space 0.075 mul
        \else
          \POE@key@lensradiusright
          \POE@key@lensheight\space 0.5 mul capHeight
        \fi
      \fi
      \space add
    \space}%
  \fi
  \POE@Verb{%
    /@@y \POE@key@lensheight\space 0.5 mul def
    /@@x \@th 0.5 mul def
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\lens@nodes}
%    \begin{macrocode}
\def\lens@nodes{%
  \newOptexpComp{%
    {@@x neg 0} 
    \ifdim\POE@key@lensradiusleft pt=0pt 
      {0 1} 
      \POE@key@lensheight\space -0.5 mul dup neg
      trans {PlainIfc}
    \else 
      {\POE@key@lensradiusleft\space 0} 
      \POE@key@lensheight\space -0.5 mul dup neg
      trans {CurvedIfc}
    \fi
    {@@x 0} 
    \ifdim\POE@key@lensradiusright pt=0pt
      {0 1} 
      \POE@key@lensheight\space -0.5 mul dup neg
      trans {PlainIfc}
    \else
      {\POE@key@lensradiusright\space neg 0} 
      \POE@key@lensheight\space -0.5 mul dup neg
      trans {CurvedIfc} 
    \fi
    \POE@key@n
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\lens@comp}
%    \begin{macrocode}
\def\lens@comp{%
  \addbefore@par{linejoin=1}%
  \begin@ClosedObj
  \addto@pscode{\pst@optexpdict }%
  \def\@th{0}%
  \def\@wd{\POE@key@lenswidth\space\pst@number\psxunit mul 2 div }%
  \def\@ht{\POE@key@lensheight\space\pst@number\psyunit mul 2 div }%
  \def\@rL{\POE@key@lensradiusleft\space\pst@number\psrunit mul }%
  \def\@rR{\POE@key@lensradiusright\space\pst@number\psrunit mul }%
  \ifdim\POE@key@lensradiusleft pt=0pt\else
    \addto@pscode{ \@ht \@rL leftCurvedIfc }%
  \fi
  \ifdim\POE@key@lensradiusright pt=0pt\else
    \addto@pscode{ \@ht \@rR rightCurvedIfc }%
  \fi
  \def\@@x{@@x \pst@number\psxunit mul }%
%    \end{macrocode}
% Check some special cases:
%
% 1) Left is plain - right concave / convex
%    \begin{macrocode}
  \ifdim\POE@key@lensradiusleft pt=0pt
    \ifdim\POE@key@lensradiusright pt=0pt\else
      \addto@pscode{%
        \@@x sub neg 5 1 roll
        \@@x neg \@ht neg moveto ArcR
        \@@x neg \@ht lineto
      }%
    \fi
  \fi
%    \end{macrocode}
% 2) Right is plain - left concave / convex
%    \begin{macrocode}
  \ifdim\POE@key@lensradiusright pt=0pt
    \ifdim\POE@key@lensradiusleft pt=0pt\else
      \addto@pscode{%
        \@@x sub 5 1 roll
        \@@x \@ht moveto ArcL
        \@@x \@ht neg lineto
      }%
    \fi
  \fi
%    \end{macrocode}
% 3) right and left are both curved
%    \begin{macrocode}
  \ifdim\POE@key@lensradiusright pt=0pt\else
    \ifdim\POE@key@lensradiusleft pt=0pt\else
      \addto@pscode{%
        \@@x dup
        7 1 roll sub neg 5 1 roll
        ArcR sub 5 1 roll ArcL
      }%
    \fi
  \fi
  \addto@pscode{closepath 1 setlinejoin end }%
  \end@ClosedObj
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{pinhole}
%
% \begin{macro}{\pinhole@ref}
%    \begin{macrocode}
\def\pinhole@ref{%
  \POE@Verb{/@@y \POE@key@outerheight\space 0.5 mul def}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\pinhole@nodes}
%    \begin{macrocode}
\def\pinhole@nodes{%
  \newOptexpComp{%
    {-1e-4 0} {0 1} @@y0 @@y sub @@y0 @@y add trans {PlainIfc}
    {0 0} {0 1} \POE@key@innerheight\space -0.5 mul dup neg 
    trans {PlainIfc}  
    {1e-4 0} {0 1} @@y0 @@y sub @@y0 @@y add trans {PlainIfc}
    \POE@key@n }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\pinhole@comp}
%    \begin{macrocode}
\def\pinhole@comp{%
  \ifdim\POE@key@phwidth pt=0pt
    \psline[linewidth=\POE@key@phlinewidth]%
      (! 0 \POE@key@outerheight\space 2 div)%
      (! 0 \POE@key@innerheight\space 2 div)%
    \psline[linewidth=\POE@key@phlinewidth]%
      (! 0 \POE@key@outerheight\space -2 div)%
      (! 0 \POE@key@innerheight\space -2 div)%
  \else
    \pspolygon*[linestyle=none]%
      (! 0 \POE@key@innerheight\space 2 div)%
      (! 0 \POE@key@outerheight\space 2 div)%
      (! \POE@key@phwidth\space\POE@key@outerheight\space 2 div)%
      (! \POE@key@phwidth\space\POE@key@innerheight\space dup neg
         \POE@key@outerheight\space add 2 div add 2 div)%
    \pspolygon*[linestyle=none]%
      (! 0 \POE@key@innerheight\space -2 div)%
      (! 0 \POE@key@outerheight\space -2 div)%
      (! \POE@key@phwidth\space\POE@key@outerheight\space -2 div)%
      (! \POE@key@phwidth\space\POE@key@innerheight\space dup neg 
         \POE@key@outerheight\space add 2 div add -2 div)%
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{beamsplitter}
%
% \begin{macro}{\beamsplitter@nodes}
%    \begin{macrocode}
\def\beamsplitter@nodes{%
  \edef\@bs@wd{\POE@key@bssize\space 0.5 mul }%
  \ifx\POE@key@bsstyle\POE@str@bsstyle@cube
    \newOptexpCompAmb{%
      {\@bs@wd 2 sqrt div neg dup} {-1 1} \@bs@wd neg \@bs@wd 
      trans {PlainIfc}
      {\@bs@wd 2 sqrt div dup neg} {1 1} \@bs@wd neg \@bs@wd
      trans {PlainIfc}
      {0 0} {1 0} \@bs@wd 2 sqrt mul dup neg exch 
      trans {PlainIfc}
      {\@bs@wd 2 sqrt div dup} {-1 1} \@bs@wd neg \@bs@wd 
      trans {PlainIfc}
      {\@bs@wd 2 sqrt div neg dup neg} {1 1} \@bs@wd neg \@bs@wd 
      trans {PlainIfc} 
      3 \POE@key@n
    }%
  \else\ifx\POE@key@bsstyle\POE@str@bsstyle@plate
    \newOptexpCompAmb{%
      {0 0} {1 0} \@bs@wd neg \@bs@wd trans {PlainIfc} 1 1 }%
  \fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\beamsplitter@comp}
%    \begin{macrocode}
\def\beamsplitter@comp{%
  \edef\@bs@wd{\POE@key@bssize\space 2.0 div }%
  \ifx\POE@key@bsstyle\POE@str@bsstyle@cube
    \psline[arrows=cc-cc](! \@bs@wd neg 2 sqrt mul 0)
                  (! \@bs@wd 2 sqrt mul 0)
    \rput[c]{45}(0,0){%
      \psframe(! \@bs@wd neg \@bs@wd neg)(! \@bs@wd \@bs@wd)
    }
  \else\ifx\POE@key@bsstyle\POE@str@bsstyle@plate
    \psline(! \@bs@wd neg 2 sqrt mul 0)(! \@bs@wd 2 sqrt mul 0)
  \fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{crystal}
%
% \begin{macro}{\crystal@ref}
%    \begin{macrocode}
\def\crystal@ref{%
  \let\POE@key@optboxwidth\POE@key@crystalwidth
  \let\POE@key@optboxheight\POE@key@crystalheight
  \optbox@ref
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\crystal@comp}
%    \begin{macrocode}
\def\crystal@comp{%
  \edef\@wd{\POE@key@crystalwidth\space 0.5 mul }
  \edef\@ht{\POE@key@crystalheight\space 0.5 mul }
  \psframe(! \@wd neg \@ht neg)(! \@wd \@ht)
  \ifPOE@voltage%
    \psline(!\@wd 4 div 3 mul neg \@ht)%
           (! \@wd 4 div 3 mul neg \@ht 0.2 add)
    \pscircle[fillstyle=solid, fillcolor=white]%
      (! \@wd 4 div 3 mul neg \@ht 0.2 add){0.04}
    \psline(! \@wd 4 div 3 mul neg \@ht neg)%
           (! \@wd 4 div 3 mul neg \@ht neg 0.2 sub)%
    \psline(! \@wd 4 div 3 mul neg 0.15 sub \@ht neg 0.2 sub)%
           (! \@wd 4 div 3 mul neg 0.15 add \@ht neg 0.2 sub)%
  \fi
  \ifPOE@lamp
    \rput(! \@wd \@ht){%
      \psset{style=CrystalLamp}%
      \rput(0, 0.4){\crystal@lamp}%
    }%
  \fi
  \ifdim\POE@key@caxislength pt=0pt\else
    \def\@cl{%
      \POE@key@caxislength\space 
      \ifPOE@caxisinv -1 mul\space\fi
    }%
    \psline[style=CrystalCaxis](! 0 \@cl \POE@dict{sign} \@ht mul)%
                               (! 0 \@cl \POE@dict{sign} neg \@ht mul \@cl sub)%
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\crystal@lamp}
%    \begin{macrocode}
\def\crystal@lamp{%
  \pscurve[fillstyle=none](-0.015, 0)(-0.03, -0.045)(-0.06, -0.075)%
          (-0.075, -0.15)(0, -0.21)(0.075, -0.15)(0.06, -0.075)%
          (0.03, -0.045)(0.015, 0)
  \multido{\i=-30+40}{7}{%
    \rput{\i}(0, -0.135){%
      \psline(-0.105, 0)(-0.18, 0)
    }%
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{polarization}
%
% \begin{macro}{\polarization@comp}
%    \begin{macrocode}
\def\polarization@comp{%
  \edef\@sz{\POE@key@polsize\space 0.5 mul }%
  \psset{style=Polarization}%
  \ifx\POE@key@poltype\POE@str@pol@polparallel
    \psline[arrows=<->](! 0 \@sz neg)(! 0 \@sz)
  \fi
  \ifx\POE@key@poltype\POE@str@pol@polperp
    \psdot(0,0)
    \pscircle[fillstyle=none](0,0){0.12}
  \fi
  \ifx\POE@key@poltype\POE@str@pol@polmisc
    \psline[arrows=<->](! 0 \@sz neg)(! 0 \@sz)
    \psdot(0,0)
    \pscircle[fillstyle=none](0,0){0.12}
  \fi
  \ifx\POE@key@poltype\POE@str@pol@polrcirc
    \psellipticarc[arrows=->]%
      (0,0)(! \@sz 2 div \@sz){20}{-20}
  \fi
  \ifx\POE@key@poltype\POE@str@pol@pollcirc
    \psellipticarc[arrows=<-]%
      (0,0)(! \@sz 2 div \@sz){20}{-20}
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{optgrating}
%
% \begin{macro}{\optgrating@ref}
%    \begin{macrocode}
\def\optgrating@ref{%
  \POE@Verb{/@@x \POE@key@gratingwidth\space 0.5 mul def}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optgrating@comp}
%    \begin{macrocode}
\def\optgrating@comp{%
  \edef\@cnt{\POE@key@gratingcount\space}%
  \edef\@wd{\POE@key@gratingwidth\space 2 div }%
  \edef\@ht{\POE@key@gratingheight\space}%
  \edef\@dp{\POE@key@gratingdepth\space}%
  \edef\@step{\POE@key@gratingwidth\space\@cnt div }%
  \ifx\POE@key@gratingtype\POE@str@gratingtype@blazed
    \pscustom[linewidth=\POE@key@gratinglinewidth, linejoin=1]{%
      \psline[liftpen=1](! \@wd \@dp)(! \@wd \@ht)%
                        (! \@wd neg \@ht)(! \@wd neg \@dp)%
      \multido{\i=0+1}{\POE@key@gratingcount}{%
        \psline[liftpen=1]%
          (! \@wd neg \i\space \@step mul add \@dp)%
          (! \@wd neg \i\space 
             \ifPOE@reverse\else 1 add \fi \@step mul add 0)%
          (! \@wd neg \i\space 1 add \@step mul add \@dp)%
      }%
      \closepath
    }%
  \else\ifx\POE@key@gratingtype\POE@str@gratingtype@binary
    \pscustom[linewidth=\POE@key@gratinglinewidth]{%
      \psline[liftpen=1](! \@wd \@dp)(! \@wd \@ht)%
                        (! \@wd neg \@ht)(! \@wd neg \@dp)%
      \multido{\i=0+1}{\POE@key@gratingcount}{%
        \psline[liftpen=1]%
          (! \@wd neg \i\space \@step mul add \@dp)%
          (! \@wd neg \i\space \@step mul add 0)%
          (! \@wd neg \i\space 0.5 add \@step mul add 0)%
          (! \@wd neg \i\space 0.5 add \@step mul add \@dp)%
          (! \@wd neg \i\space 1 add \@step mul add \@dp)%
      }%
    }%
  \fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{optbox}
%
% \begin{macro}{\optbox@ref}
%    \begin{macrocode}
\def\optbox@ref{%
  \POE@Verb{%
    /@@x \POE@key@optboxwidth\space 0.5 mul def
    /@@y \POE@key@optboxheight\space 0.5 mul def
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optbox@comp}
%    \begin{macrocode}
\def\optbox@comp{%
  \edef\@wd{\POE@key@optboxwidth\space 0.5 mul }
  \edef\@ht{\POE@key@optboxheight\space 0.5 mul }
  \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{optplate}
%
% \begin{macro}{\optplate@ref}
%    \begin{macrocode}
\def\optplate@ref{%
  \POE@Verb{/@@y \POE@key@plateheight\space 0.5 mul def }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optplate@comp}
%    \begin{macrocode}
\def\optplate@comp{%
   \psline[linewidth=\POE@key@platelinewidth]%
     (! \POE@dict{0 @@y neg})(! \POE@dict{0 @@y})
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{optdetector}
%
% \begin{macro}{\optdetector@ref}
%    \begin{macrocode}
\def\optdetector@ref{%
  \ifx\POE@key@detsize\@empty
    \POE@Verb{%
      /@@y \POE@key@detheight\space 0.5 mul def
      /@@x \POE@key@detwidth\space 0.5 mul def
    }%
  \else
    \POE@Verb{%
      /@@y \POE@key@detsize\space 0.5 mul def
      /@@x \POE@key@detsize\space 0.5 mul
      \ifx\POE@key@dettype\POE@str@dettype@round 0.5 mul\fi
      \space def
    }%
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optdetector@nodes}
%    \begin{macrocode}
\def\optdetector@nodes{%
  \dipole@nodes
  \ifx\POE@key@dettype\POE@str@dettype@round
    \pnode(! \POE@dict{@@x0 @@x -0.2 mul add} 0){\oenodeCenter{}}%
  \fi
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optdetector@comp}
%    \begin{macrocode}
\def\optdetector@comp{%
  \ifx\POE@key@dettype\POE@str@dettype@round
    \psellipticwedge(!\POE@dict{@@x0 @@x sub @@y0})%
      (!\POE@dict{@@x 2 mul @@y}){-90}{90}%
  \else\ifx\POE@key@dettype\POE@str@dettype@diode
    \ifx\POE@key@detsize\@empty
      \ifdim\POE@key@detwidth pt<\POE@key@detheight pt
        \def\@sz{\POE@key@detwidth\space 0.5 mul }%
      \else
        \def\@sz{\POE@key@detheight\space 0.5 mul }%
      \fi
    \else
      \def\@sz{\POE@key@detsize\space 0.5 mul }%
    \fi
    \psframe[dimen=outer](! \POE@dict{@@x neg @@y neg})%
                         (! \POE@dict{@@x @@y})%
    \bgroup
      \psset{style=DetectorStyle}
      \pspolygon(! \@sz -0.2 mul \@sz -0.4 mul)%
                (! \@sz 0.6 mul \@sz -0.4 mul)%
                (! \@sz 0.2 mul \@sz 0.4 mul)%
      \psline(! \@sz -0.2 mul \@sz 0.4 mul \getCLWH add)%
             (! \@sz 0.6 mul \@sz 0.4 mul \getCLWH add)
      \psset{arrows=->, arrowinset=0, arrowscale=0.8}%
      \psline(! \@sz -0.8 mul \@sz 0.3 mul)%
             (! \@sz -0.3 mul \@sz 0.15 mul)%
      \psline(! \@sz -0.8 mul 0)(! \@sz -0.3 mul \@sz -0.15 mul)%
    \egroup
  \fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{optretplate}
%
% \begin{macro}{\optretplate@ref}
%    \begin{macrocode}
\def\optretplate@ref{%
   \POE@Verb{%
     /@@y \POE@key@plateheight\space 0.5 mul def
     /@@x \POE@key@platewidth\space 0.5 mul def
   }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optretplate@comp}
%    \begin{macrocode}
\def\optretplate@comp{%
   \edef\@ht{\POE@key@plateheight\space 0.5 mul }%
   \edef\@wd{\POE@key@platewidth\space 0.5 mul }%
   \psframe(! \@wd neg \@ht neg)(! \@wd \@ht)
   \psline{cc-cc}(! \@wd neg \@ht)(! \@wd \@ht neg)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{optdiode}
%
% \begin{macro}{\optdiode@ref}
%    \begin{macrocode}
\def\optdiode@ref{%
  \POE@Verb{%
    \POE@key@optdiodesize\space 0.5 mul dup /@@y ED /@@x ED 
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optdiode@comp}
%    \begin{macrocode}
\def\optdiode@comp{%
   \edef\@sz{\POE@key@optdiodesize\space}%
   \psframe[dimen=outer](! \@sz -0.5 mul dup)(!\@sz 0.5 mul dup)
   \pspolygon(! \@sz -0.2 mul \@sz -0.2 mul)
             (! \@sz -0.2 mul \@sz 0.2 mul)
             (! \@sz 0.2 mul 0)
   \psline(! \@sz 0.2 mul \getCLWH add \@sz 0.2 mul)%
          (! \@sz 0.2 mul \getCLWH add \@sz -0.2 mul)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{doveprism}
%
% \begin{macro}{\doveprism@nodes}
%    \begin{macrocode}
\def\doveprism@nodes{%
  \newOptexpComp{%
    /@wd \POE@key@doveprismwidth\space 0.5 mul def
    /@htsq \POE@key@doveprismheight\space 2 sqrt div def
    {@wd neg \POE@key@doveprismheight\space 0.5 mul add 0} {1 1} 
    @htsq neg @htsq trans {PlainIfc}
    {0 \POE@key@doveprismheight\space -0.5 mul} {1 0} 
    \POE@key@doveprismwidth\space -0.5 mul dup neg
    refl {PlainIfc}
    {@wd \POE@key@doveprismheight\space 0.5 mul sub 0} {-1 1} 
    @htsq neg @htsq trans {PlainIfc} 
    \POE@key@n true 
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\doveprism@comp}
%    \begin{macrocode}
\def\doveprism@comp{%
   \edef\@ht{\POE@key@doveprismheight\space 0.5 mul }%
   \edef\@wd{\POE@key@doveprismwidth\space 0.5 mul }%
   \pspolygon(! \@wd neg \@ht neg)%
             (! \@wd \@ht neg)%
             (! \@wd \@ht 2 mul sub \@ht)%
             (! \@ht 2 mul \@wd sub \@ht)%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{pentaprism}
%
% \begin{macro}{\pentaprism@nodes}
%    \begin{macrocode}
\def\pentaprism@nodes{%
  \edef\@sz{\POE@key@pentaprismsize\space}%
  \newOptexpComp{%
    {\@sz 2 sqrt -2 mul div dup } {-1 1} 
    \@sz -0.5 mul dup neg trans {PlainIfc}
    {\@sz 2 sqrt div 67.5 cos \@sz mul 
      67.5 sin 2 mul div sub \@sz 2 div}
    {67.5 cos \@sz mul 67.5 sin div neg \@sz} 
     \@sz 22.5 cos div -0.5 mul dup neg refl {PlainIfc}
    {\@sz 2 sqrt div neg 67.5 cos \@sz mul 
      67.5 sin 2 mul div add \@sz 2 div}
    {67.5 cos \@sz mul 67.5 sin div \@sz}
     \@sz 22.5 cos div -0.5 mul dup neg refl {PlainIfc}
    {\@sz 2 sqrt 2 mul div dup neg} {1 1} 
    \@sz -0.5 mul dup neg trans {PlainIfc} 
    \POE@key@n
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\pentaprism@comp}
%    \begin{macrocode}
\def\pentaprism@comp{%
  \edef\@sz{\POE@key@pentaprismsize\space}%
  \pscustom{%
    \psline(! \@sz 2 sqrt div 0)%
           (! \@sz 2 sqrt div 67.5 cos \@sz mul 
              67.5 sin div sub \@sz)%
           (! 67.5 cos \@sz mul 67.5 sin div \@sz 
              2 sqrt div sub \@sz)%
           (! \@sz 2 sqrt div neg 0)%
           (! 0 \@sz 2 sqrt div neg)%
    \closepath
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{optprism}
%
% \begin{macro}{\optprism@nodes}
%    \begin{macrocode}
\def\optprism@nodes{%
  \edef\@sz{\POE@key@prismsize\space}%
  \edef\@ang{\POE@key@prismangle\space 0.5 mul\space}%
  \edef\@hshift{%
    \ifx\POE@key@prismalign\POE@str@auto
      \@sz 0.6 mul \@ang tan mul \POE@dict{OEangle} 0.5 mul tan div 
    \else
      0
    \fi
  }%
  \newOptexpComp{%
    {\@sz -0.6 mul \@ang tan mul \@hshift neg} 
    {90 \@ang sub dup cos exch sin} 
    \@sz \@ang cos div dup -0.4 mul exch 0.6 mul trans {PlainIfc}
    {\@sz 0.6 mul \@ang tan mul \@hshift neg} 
    {90 \@ang add dup cos exch sin} 
    \@sz \@ang cos div dup -0.4 mul exch 0.6 mul trans {PlainIfc} 
    \POE@key@n true }%
  \pnode(! 0 \@hshift neg){\oenodeCenter{}}
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optprism@comp}
%    \begin{macrocode}
\def\optprism@comp{%
  \edef\@sz{\POE@key@prismsize\space}%
  \edef\@altan{\POE@key@prismangle\space 0.5 mul tan }%
  \edef\@hshift{%
    \ifx\POE@key@prismalign\POE@str@auto
      \@sz 0.6 mul \@altan mul \POE@dict{OEangle} 0.5 mul tan div 
    \else
      0
    \fi
  }%
  \pspolygon(! \@sz neg \@altan mul \@sz -0.4 mul \@hshift sub)
            (! \@sz \@altan mul \@sz -0.4 mul \@hshift sub)
            (! 0 \@sz 0.6 mul \@hshift sub)
}%
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{rightangleprism}
%
% \begin{macro}{\rightangleprism@nodes}
%    \begin{macrocode}
\def\rightangleprism@nodes{%
  \edef\@sz{\POE@key@raprismsize\space}%
  \edef\@ht{\POE@dict{OEangle 0.5 mul sin modA mul} }%
  \newOptexpComp{%
    {\@ht neg \@ht \@sz 0.5 mul sub} {1 0} 
    \@ht \@sz 0.5 mul sub \@ht trans {PlainIfc}
    {\@ht neg 0} {1 1} 
    \@ht 2 sqrt mul dup \@sz 2 sqrt div sub exch refl {PlainIfc}
    {\@ht 0} {-1 1} 
    \@ht 2 sqrt mul dup \@sz 2 sqrt div sub exch refl {PlainIfc}
    {\@ht dup \@sz 0.5 mul sub } {1 0} 
    \@ht neg \@sz 0.5 mul \@ht sub trans {PlainIfc} 
    \POE@key@n 
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rightangleprism@comp}
%    \begin{macrocode}
\def\rightangleprism@comp{%
  \edef\@sz{\POE@key@raprismsize\space 0.5 mul }%
  \edef\@ht{\POE@dict{OEangle 0.5 mul sin modA mul} }%
  \pspolygon(! \@sz neg \@ht \@sz sub)
            (! \@sz \@ht \@sz sub)
            (! 0 \@ht)%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Fiber components}
%
% \subsubsection{optfiber}
%
% \begin{macro}{\optfiber@nodes}
%    \begin{macrocode}
\def\optfiber@nodes{%
  \newOptexpFiberComp{%
    {\POE@key@fiberloopsep\space\POE@key@fiberloops\space
      1 sub mul -0.5 mul 0}
    {\POE@key@fiberloopsep\space\POE@key@fiberloops\space
      1 sub mul 0.5 mul 0}}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optfiber@comp}
%    \begin{macrocode}
\def\optfiber@comp{%
  \edef\@f@cnt{\POE@key@fiberloops\space}%
  \edef\@f@r{\POE@key@fiberloopradius\space}%
  \edef\@f@sep{\POE@key@fiberloopsep\space}%
  \parametricplot[plotpoints=200, style=Fiber]{0}{1}{%
    t 360 mul \@f@cnt mul sin \@f@r mul \@f@sep 
    \@f@cnt 1 sub mul t 0.5 sub mul add
     1 t 360 mul \@f@cnt mul cos sub \@f@r mul
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{optmzm}
%
% \begin{macro}{\optmzm@ref}
%    \begin{macrocode}
\def\optmzm@ref{%
  \POE@Verb{%
    /@@x \POE@key@optmzmwidth\space 0.5 mul def
    /@@y \POE@key@optmzmheight\space 0.5 mul def
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optmzm@comp}
%    \begin{macrocode}
\def\optmzm@comp{%
  \bgroup
    \ifPOE@usefiberstyle
      \psset{style=Fiber}
    \fi
    \psline(! \POE@dict{@@x} neg 0)(! \POE@dict{@@x} -0.7 mul 0)%
           (! \POE@dict{@@x} -0.4 mul \POE@dict{@@y} 0.6 mul)%
           (! \POE@dict{@@x 0.4 mul @@y 0.6 mul})%
           (! \POE@dict{@@x} 0.7 mul 0)(! \POE@dict{@@x} 0)%
           (! \POE@dict{@@x} 0.7 mul 0)%
           (! \POE@dict{@@x 0.4 mul @@y -0.6 mul})%
           (! \POE@dict{@@x -0.4 mul @@y -0.6 mul})%
           (! \POE@dict{@@x} -0.7 mul 0)%
  \egroup
  \psframe[dimen=outer](! \POE@dict{@@x neg @@y neg})%
                       (!\POE@dict{@@x @@y})
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{optfilter} 
%
% \begin{macro}{\optfilter@ref}
%    \begin{macrocode}
\def\optfilter@ref{%
  \POE@Verb{\POE@key@filtersize\space 0.5 mul dup /@@y ED /@@x ED }%
}%
\let\optfilter@nodes\dipole@nodes
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optfilter@comp}
%    \begin{macrocode}
\def\optfilter@comp{%
  \edef\@sz{\POE@key@filtersize\space 0.5 mul }%
  \def\filter@curve{%
    \parametricplot[plotstyle=curve,arrows=-]{-1}{1}{%
      t \@sz mul 0.7 mul t Pi mul RadtoDeg 
      90 add cos 0.2 \@sz mul mul}%
  }%
  \psframe[dimen=outer](! \@sz neg dup)(! \@sz dup)
  \bgroup
  \psset{style=FilterStyle}%
    \ifx\POE@key@filtertype\POE@str@filtertype@bandpass
      \psline(! -0.3 \@sz mul -0.65 \@sz mul)%
             (! 0.3 \@sz mul -0.35 \@sz mul)%
      \psline(! -0.3 \@sz mul 0.35 \@sz mul)%
             (! 0.3 \@sz mul 0.65 \@sz mul)%
      \rput(! 0 -0.5 \@sz mul){\filter@curve}
      \rput(0, 0){%
        \ifPOE@usefiberstyle
          \psset{style=Fiber}
        \fi
        \filter@curve}
      \rput(! 0 0.5 \@sz mul){\filter@curve}
    \else\ifx\POE@key@filtertype\POE@str@filtertype@bandstop
      \psline(! -0.3 \@sz mul -0.15 \@sz mul)%
             (! 0.3 \@sz mul 0.15 \@sz mul)%
      \rput(! 0 -0.5 \@sz mul){%
        \ifPOE@usefiberstyle
          \psset{style=Fiber}
        \fi
        \filter@curve}
        \rput(0, 0){\filter@curve}
        \rput(! 0 0.5 \@sz mul){%
          \ifPOE@usefiberstyle
            \psset{style=Fiber}
          \fi
          \filter@curve}
    \else\ifx\POE@key@filtertype\POE@str@filtertype@lowpass
      \psline(! -0.3 \@sz mul -0.15 \@sz mul)%
             (! 0.3 \@sz mul 0.15 \@sz mul)%
      \psline(! -0.3 \@sz mul 0.35 \@sz mul)%
             (! 0.3 \@sz mul 0.65 \@sz mul)%
      \rput(! 0 -0.5 \@sz mul){%
        \ifPOE@usefiberstyle
          \psset{style=Fiber}
        \fi
        \filter@curve}
        \rput(0, 0){\filter@curve}
        \rput(! 0 0.5 \@sz mul){\filter@curve}
    \else\ifx\POE@key@filtertype\POE@str@filtertype@highpass
      \psline(! -0.3 \@sz mul -0.15 \@sz mul)%
             (! 0.3 \@sz mul 0.15 \@sz mul)%
      \psline(! -0.3 \@sz mul -0.65 \@sz mul)%
             (! 0.3 \@sz mul -0.35 \@sz mul)%
      \rput(! 0 0.5 \@sz mul){%
        \ifPOE@usefiberstyle
          \psset{style=Fiber}
        \fi
        \filter@curve}
        \rput(0, 0){\filter@curve}
        \rput(! 0 -0.5 \@sz mul){\filter@curve}
  \fi\fi\fi\fi
  \egroup
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
%\subsubsection{optamp}
%
% \begin{macro}{\optamp@nodes}
%    \begin{macrocode}
\def\optamp@nodes{%
  \edef\@sz{\POE@key@optampsize\space 0.5 mul }%
  \edef\@xl{0.75 sqrt \@sz mul }%
  \newOptexpFiberComp{{\@xl neg 0} {\@xl 0}}  
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optamp@comp}
%    \begin{macrocode}
\def\optamp@comp{%
  \edef\@sz{\POE@key@optampsize\space 0.5 mul }%
  \edef\@xl{0.75 sqrt \@sz mul }%
  \pspolygon(! \@xl 0)(! \@xl neg \@sz)(! \@xl neg \@sz neg)
\ignorespaces}%
%    \end{macrocode}
% \end{macro} 
%
%\subsubsection{polcontrol}
%
% \begin{macro}{\polcontrol@nodes}
%    \begin{macrocode}
\def\polcontrol@nodes{%
  \ifx\POE@key@polcontroltype\POE@str@polcontroltype@linear
    \def\@sz{\POE@key@polcontrolsize\space 2 mul\space}%
  \else
    \def\@sz{\POE@key@polcontrolsize\space 1.5 mul\space}%
  \fi
  \newOptexpFiberComp{{\@sz neg 0} {\@sz 0}}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\polcontrol@comp}
%    \begin{macrocode}
\def\polcontrol@comp{%
  \edef\@sz{\POE@key@polcontrolsize\space}%
  \ifPOE@optexpenv
    \psline[style=Fiber](\oenodeIn{})(\oenodeOut{})
  \fi
  \bgroup
    \ifPOE@usefiberstyle
      \psset{style=Fiber}%
    \fi
    \ifx\POE@key@polcontroltype\POE@str@polcontroltype@linear
      \multips(! -2 \@sz mul \@sz)(! 2 \@sz mul 0){3}{%
        \pscircle(0,0){\POE@key@polcontrolsize}%
      }%
    \else
      \pscircle(! -1.5 \@sz mul \@sz neg){\POE@key@polcontrolsize}
      \pscircle(! 0 \@sz){\POE@key@polcontrolsize}%
      \pscircle(! 1.5 \@sz mul \@sz neg){\POE@key@polcontrolsize}
    \fi
  \egroup
  \ifPOE@optexpenv\else
    \psline[style=Fiber](\oenodeIn{})(\oenodeOut{})
  \fi  
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{optisolator}
%
% \begin{macro}{\optisolator@ref}
%    \begin{macrocode}
\def\optisolator@ref{%
  \POE@Verb{%
    /@@x \POE@key@isolatorwidth\space 0.5 mul def
    /@@y \POE@key@isolatorheight\space 0.5 mul def
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optisolator@comp}
%    \begin{macrocode}
\def\optisolator@comp{%
  \edef\@ht{\POE@key@isolatorheight\space 0.5 mul }%
  \edef\@wd{\POE@key@isolatorwidth\space 0.5 mul }%
  \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
  \psline[style=IsolatorArrow,
          arrows=->](! \@wd neg 0.6 mul 0)(!\@wd 0.6 mul 0)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{optfiberpolarizer}
% \begin{macro}{\optfiberpolarizer@ref}
%    \begin{macrocode}
\def\optfiberpolarizer@ref{%
  \POE@Verb{%
    \POE@key@fiberpolsize\space dup 0.8 mul /@@x ED 0.5 mul /@@y ED 
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optfiberpolarizer@comp}
%    \begin{macrocode}
\def\optfiberpolarizer@comp{%
  \edef\@ht{\POE@key@fiberpolsize\space 0.5 mul }%
  \edef\@wd{\POE@key@fiberpolsize\space 0.8 mul }%
  \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
  \psline(! \@wd neg 0.2 mul \@ht neg)(!\@wd 0.2 mul \@ht)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{optswitch}
%
% \begin{macro}{\optswitch@ref}
%    \begin{macrocode}
\def\optswitch@ref{%
  \POE@Verb{\POE@key@switchsize\space 0.5 mul dup /@@y ED /@@x ED }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optswitch@comp}
%    \begin{macrocode}
\def\optswitch@comp{%
%    \end{macrocode}
% storing the linewidth of the object allows for some aesthetic fine tuning 
%    \begin{macrocode}
  \pstVerb{tx@Dict begin /@lw \getCLW def end}%
  \bgroup
    \ifPOE@usefiberstyle
      \psset{style=Fiber}
    \fi
    \psline[arrows=-](! \POE@dict{@@x} neg 0)%
                     (! \POE@dict{@@x} -0.6 mul @lw sub 0)%
    \psline[arrows=-](! \POE@dict{@@x} 0.6 mul 0)(! \POE@dict{@@x} 0)%
  \egroup
  \ifx\POE@key@switchstyle\POE@str@closed%
    \bgroup
      \ifPOE@usefiberstyle
        \psset{style=Fiber}
      \fi
      \psdot[dotsize=3\pslinewidth](! \POE@dict{@@x} 0.6 mul 0)%
      \psdot[dotsize=3\pslinewidth](! \POE@dict{@@x} -0.6 mul 0)%
      \psline[arrows=-, linewidth=1.5\pslinewidth]%
        (! \POE@dict{@@x} -0.6 mul @lw)(! \POE@dict{@@x} 0.6 mul @lw)%      
    \egroup
  \else
    \psline[arrows=-, linewidth=1.5\pslinewidth]%
      (! \POE@dict{@@x} -0.6 mul @lw add @lw)%
      (! \POE@dict{@@x 0.6 mul @@y 0.6 mul})%
    \pscircle(! \POE@dict{@@x} -0.6 mul 0){\pslinewidth}%
    \psdot[dotsize=3\pslinewidth](! \POE@dict{@@x} 0.6 mul 0)%
  \fi
  \psframe[dimen=outer](! \POE@dict{@@x neg @@y neg})%
                       (! \POE@dict{@@x @@y})%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{fiberdelayline}
%
% \begin{macro}{\fiberdelayline@ref}
%    \begin{macrocode}
\def\fiberdelayline@ref{%
  \POE@Verb{%
    /@@y \POE@key@fdlheight\space 0.5 mul def
    /@@x \POE@key@fdlwidth\space 0.5 mul def
  }%
}%
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\def\POE@get@yarrowscale#1 #2 #3 #4\@nil{%
  \def\POE@tempA{#3\space}%
}%
%    \end{macrocode}
% \begin{macro}{\fiberdelayline@comp}
%    \begin{macrocode}
\def\fiberdelayline@comp{%
  \psframe[dimen=outer](! \POE@dict{@@x neg @@y neg})%
                       (! \POE@dict{@@x @@y})
  \begingroup
    \psset{style=FdlArrow}
    \use@par
    \pst@expandafter\POE@get@yarrowscale{\psk@arrowscale}\@nil
    \def\@arrowshift{%
      \psk@arrowlength\space \psk@arrowsize\space
      \pst@number\pslinewidth\space mul add mul 
      \POE@tempA mul 
      @@y 2.9 mul @@x 0.6 mul atan 2 copy cos mul 3 1 roll sin mul 
      \tx@UserCoor abs exch abs exch\space
    }%
    \psline(! \POE@dict{@@x -0.4 mul @@y -1.6 mul})%
           (! \POE@dict{@@x 0.2 mul @@y 1.3 mul \@arrowshift VecAdd})
  \endgroup
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{optcoupler}
% \begin{macro}{\optcoupler@nodes}
%    \begin{macrocode}
\def\optcoupler@nodes{%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \newOptexpFiberComp{%
    {@@x neg @@y0 \@sep add}
    {@@x neg @@y0 \@sep sub}
    {@@x @@y0 \@sep add}
    {@@x @@y0 \@sep sub} }%
  \pnode(! 0 \POE@dict{@@y0}){\oenodeCenter{}}
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\POE@coupler@ref}
%    \begin{macrocode}
\def\POE@coupler@ref{%
  \POE@Verb{%
    /@@y0
    \ifx\POE@key@coupleralign\POE@str@top
      \POE@key@couplersep\space -0.5 mul
    \else\ifx\POE@key@coupleralign\POE@str@bottom
      \POE@key@couplersep\space 0.5 mul
    \else
      0
    \fi\fi
    def
    \ifx\POE@key@couplersize\@empty
      \POE@key@couplersize
    \else
      \POE@key@couplerwidth
    \fi
    \space 0.5 mul /@@x ED
    \ifx\POE@key@couplertype\POE@str@couplertype@none
      \POE@key@couplersep
    \else
      \ifx\POE@key@couplersize\@empty
        \POE@key@couplersize\space 0.2 mul
      \else
        \POE@key@couplerheight\space 0.5 mul
    \fi\fi
    \space /@@y ED
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
%    \begin{macrocode}
\let\optcoupler@ref\POE@coupler@ref
%    \end{macrocode}
%
% \begin{macro}{\wdmcoupler@ref}
% The \cs{wdmcoupler} and \cs{wdmsplitter} need a little correction for centered alignment and \opt{couplertype} set to \opt{none}.
%    \begin{macrocode}
\def\wdmcoupler@ref{%
  \POE@coupler@ref
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@coupleralign\POE@str@center
      \POE@Verb{/@@y 0 def }%
    \fi
  \fi
}%
\let\wdmsplitter@ref\wdmcoupler@ref
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optcoupler@comp}
%    \begin{macrocode}
\def\optcoupler@comp{%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \psline[style=Fiber](\oenode{1}{})(\oenode{3}{})
    \psline[style=Fiber](\oenode{2}{})(\oenode{N}{})
  \fi
  \POE@coupler@comp
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@coupler@comp}
%    \begin{macrocode}
\def\POE@coupler@comp{%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
  \else\ifx\POE@key@couplertype\POE@str@couplertype@ellipse
    \psellipse(! 0 \POE@dict{@@y0})(! \POE@dict{@@x @@y})
  \else
    \psframe[dimen=outer](!\POE@dict{@@x neg @@y0 @@y sub})%
                         (!\POE@dict{@@x @@y0 @@y add})%
    \ifx\POE@key@couplertype\POE@str@couplertype@crossswitch
      \psline(! \POE@dict{@@x -0.5 mul @@y0 @@y 0.5 mul sub})%
             (! \POE@dict{@@x 0.5 mul @@y0 @@y 0.5 mul add})%
      \psline(! \POE@dict{@@x -0.5 mul @@y0 @@y 0.5 mul add})%
             (! \POE@dict{@@x 0.5 mul @@y0 @@y 0.5 mul sub})%
    \fi
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@crossswitch\else
    \ifPOE@variable
      \begingroup
        \psset{style=VariableCoupler}
        \use@par
        \pst@expandafter\POE@get@yarrowscale{\psk@arrowscale}\@nil
        \def\@arrowshift{%
          \psk@arrowlength\space\psk@arrowsize\space
          \pst@number\pslinewidth\space mul add mul 
          \POE@tempA mul 
          1.6 0.8 atan 2 copy cos mul 3 1 roll sin mul
          \tx@UserCoor abs exch abs exch\space
        }%
        \psline(!\POE@dict{@@x -0.4 mul @@y0 @@x sub})%
               (!\POE@dict{@@x 0.4 mul @@x 0.6 mul @@y0 add 
                 \@arrowshift VecAdd})
      \endgroup
    \fi
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{wdmcoupler}
% \begin{macro}{\wdmcoupler@nodes}
%    \begin{macrocode}
\def\wdmcoupler@nodes{%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@coupleralign\POE@str@center
      \edef\@sep{0 }%
    \fi
  \fi
  \newOptexpFiberComp{%
    {@@x neg @@y0 \@sep add}
    {@@x neg  @@y0 \@sep sub}
    {@@x 0}}%
  \pnode(! 0 \POE@dict{@@y0}){\oenodeCenter{}}
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\wdmcoupler@comp}
%    \begin{macrocode}
\def\wdmcoupler@comp{%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@coupleralign\POE@str@top
      \psline[style=Fiber](\oenode{1}{})(\oenodeOut{})
      \psline[style=Fiber]%
        (!/N@\oenodeOut{} \POE@dict{@GetCenter} 
          \tx@UserCoor \POE@key@couplersep\space sub)(\oenode{2}{})
    \else
      \psline[style=Fiber](\oenode{2}{})(\oenodeOut{})
      \ifx\POE@key@coupleralign\POE@str@bottom
        \psline[style=Fiber]%
          (!/N@\oenodeOut{} \POE@dict{@GetCenter} 
            \tx@UserCoor \POE@key@couplersep\space add)(\oenode{1}{})
      \fi
    \fi
  \fi
  \POE@coupler@comp
}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{wdmsplitter}
% \begin{macro}{\wdmsplitter@nodes}
%    \begin{macrocode}
\def\wdmsplitter@nodes{%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@coupleralign\POE@str@center
      \edef\@sep{0 }%
    \fi
  \fi
  \newOptexpFiberComp{%
    {@@x neg 0}
    {@@x @@y0 \@sep add}
    {@@x @@y0 \@sep sub}}
  \pnode(! 0 \POE@dict{@@y0}){\oenodeCenter{}}
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmsplitter@comp}
%    \begin{macrocode}
\def\wdmsplitter@comp{%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@coupleralign\POE@str@top
      \psline[style=Fiber](\oenodeIn{})(\oenode{2}{})
      \psline[style=Fiber](! \POE@dict{/N@\oenodeIn{} @GetCenter}
        \tx@UserCoor \POE@key@couplersep\space sub)(\oenode{N}{})
    \else
      \psline[style=Fiber](\oenodeIn{})(\oenode{N}{})
      \ifx\POE@key@coupleralign\POE@str@bottom
        \psline[style=Fiber](! \POE@dict{/N@\oenodeIn{} @GetCenter}
          \tx@UserCoor \POE@key@couplersep\space sub)(\oenode{2}{})
      \fi
    \fi
  \fi
  \POE@coupler@comp
}%
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{optcirculator}
% \begin{macro}{\optcirculator@nodes}
%    \begin{macrocode}
\def\optcirculator@nodes{%
  \edef\@sz{\POE@key@optcircsize\space 0.5 mul }%
  \newOptexpFiberComp{{\@sz neg 0} {0 \@sz neg}{\@sz 0}}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optcirculator@comp}
%    \begin{macrocode}
\def\optcirculator@comp{%
  \edef\@sz{\POE@key@optcircsize\space 0.5 mul }%
  \pscircle(0,0){! \@sz}
  \psarc[style=OptCircArrow](0,0)%
    {! \POE@key@optcircsize\space 0.5 mul}%
    {\POE@key@optcircangleA}%
    {\POE@key@optcircangleB}
}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{fibercollimator}
% \begin{macro}{\fibercollimator@nodes}
%    \begin{macrocode}
\def\fibercollimator@nodes{%
   \def\@sz{\POE@key@fibercolsize\space 0.5 mul }%
   \pnode(!\@sz neg 0){\oenodeIn{}}
   \newOptexpComp{{\@sz neg 0} {0 1} \@sz neg \@sz trans {PlainIfc} 
                  {\@sz 0} {0 1} 0 0 trans {PlainIfc} 1 }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\fibercollimator@comp}
%    \begin{macrocode}
\def\fibercollimator@comp{%
   \def\@sz{\POE@key@fibercolsize\space 0.5 mul }%
   \pspolygon(!\@sz neg \getCLWH add \@sz neg)%
             (!\@sz 0)(!\@sz neg \getCLWH add \@sz)
}%
%    \end{macrocode}
% \end{macro}
%
%</stylefile> 
%
% \chapter{The Postscript header file}
% \makeatletter
%^^A Copied this definition from doc.sty and changed it not to add a
%^^A backslash to the Postscript procedure name in the index.
% \def\SpecialIndex@#1#2{%
%    \@SpecialIndexHelper@#1\@nil
%    \def\@tempb{ }%
%    \ifcat \@tempb\@gtempa
%       \special@index{\quotechar\space\actualchar
%                      \string\verb\quotechar*\verbatimchar
%                      \quotechar\space\verbatimchar#2}%
%    \else
%      \def\@tempb##1##2\relax{\ifx\relax##2\relax
%           \def\@tempc{\special@index{\quotechar##1\actualchar
%                       \string\verb\quotechar*\verbatimchar
%                       \quotechar##1\verbatimchar#2}}%
%         \else
%           \def\@tempc{\special@index{##1##2\actualchar
%                        \string\verb\quotechar*\verbatimchar##1##2\verbatimchar#2}}%
%         \fi}%
%      \expandafter\@tempb\@gtempa\relax
%      \@tempc
%    \fi}
% \makeatother
%
%<*prolog>
%
% This is the dictionary where all components are stored in.
%    \begin{macrocode}
/tx@OptexpDict 200 dict def
tx@OptexpDict begin
/Debug false def
/DebugDepth 0 def
/DebugBegin { 
  Debug {
    /DebugProcName ED
    DebugDepth 2 mul string
    0 1 DebugDepth 2 mul 1 sub {
      dup 2 mod 0 eq { (|) }{( )} ifelse
      3 -1 roll dup 4 2 roll
      putinterval
    } for
    DebugProcName strcat ==
    /DebugDepth DebugDepth 1 add def
  }{
    pop
  } ifelse
} bind def
/DebugEnd {
  Debug {
    /DebugDepth DebugDepth 1 sub def
    DebugDepth 2 mul 2 add string
    0 1 DebugDepth 2 mul 1 sub {
      dup 2 mod 0 eq { (|) }{ ( ) } ifelse
      3 -1 roll dup 4 2 roll
      putinterval
    } for
    dup DebugDepth 2 mul (+-) putinterval
    ( done) strcat ==
  } if
} bind def
/DebugMsg { 
  Debug {
    DebugDepth 1 add 2 mul string
    0 1 DebugDepth 2 mul 1 add {
      dup 2 mod 0 eq { (|) }{( )} ifelse
      3 -1 roll dup 4 2 roll
      putinterval
    } for
    exch strcat ==
  }{
    pop
  } ifelse
} bind def
%    \end{macrocode}
% \begin{macro}{strcat}
% Concatenate two strings and leave the result on the stack
% \begin{pssyntax}
%   \PSstring{str1} \PSstring{str2} \PSop{strcat} \PSstring{str1str2}
% \end{pssyntax}
%    \begin{macrocode}
/strcat {
    exch 2 copy
    length exch length add
    string dup dup 5 2 roll
    copy length exch
    putinterval
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{nametostr}
%   Convert a literal name to string. This is required, because some PSTricks
%   parameter like \opt{angleA} do not allow round braces in the argument, so
%   some string must be passed as name and then converted to a string.
% \begin{pssyntax}
%   \PSname{name} \PSop{nametostr} \PSstring{name}
% \end{pssyntax}
%    \begin{macrocode}
/nametostr {
    dup length string cvs
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PrintWarning}
%   Print a warning about the raytracing. This is enabled or disabled via option
%   \opt{pswarning}.
%    \begin{macrocode}
/PrintWarning {
  (Warning: ) exch strcat ==
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{inttostr}
%    Convert an integer to a string.
% \begin{pssyntax}
%   \PSvar{int} \PSop{inttostr} \PSstring{int}
% \end{pssyntax}
%    \begin{macrocode}
/inttostr {
  dup type /integertype eq {
    dup log 1 add floor cvi string cvs
  } if
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{calcNodes}
%   Calculate the reference node coordinates for reflective components and
%   stores them as \PSvar{X@A}, \PSvar{Y@A}, \PSvar{X@B} and \PSvar{Y@B}. Some
%   other values (\PSvar{modA} and \PSvar{OEangle}) are also stored for some
%   special components
% \begin{pssyntax}
%   \PSvar{XB} \PSvar{YB} \PSvar{XA} \PSvar{YA} \PSvar{XG} \PSvar{YG} \PSop{calcNodes}
% \end{pssyntax}
%    \begin{macrocode}
/calcNodes {
  (calcNode) DebugBegin
  /YG exch def /XG exch def
  /ay YG 3 -1 roll sub def
  /ax XG 3 -1 roll sub def
  /by exch YG sub def
  /bx exch XG sub def
  /a ax ay Pyth def
%    \end{macrocode}
% Used by \cs{rightangleprism}.
%    \begin{macrocode}
  /modA a def
  /b bx by Pyth def
  /cx ax a div bx b div add def
  /cy ay a div by b div add def
  /c@tmp cx cy Pyth def
  /c ax bx add ay by add Pyth def
%    \end{macrocode}
% Used by \cs{rightangleprism} and \cs{optprism}.
%    \begin{macrocode}
  /OEangle c dup mul a dup mul sub b dup mul sub 
             -2 a b mul mul div Acos def
%    \end{macrocode}
% If $c=0$, then set the coordinates of the vector manually depending whether
% \PSvar{a} and \PSvar{b} are parallel or antiparallel.
%    \begin{macrocode}
  c 0 eq {
    ax ay bx by DotProd 0 gt {
%    \end{macrocode}
% $\text{dotprod} > 0$, i.e. \PSvar{a} and \PSvar{b} are parallel.
%    \begin{macrocode}
      /cx ax def
      /cy ay def
    }{
      /cx ay def
      /cy ax neg def
    } ifelse
    /c@tmp a def
  } if
  /X@A XG cx c@tmp div add def
  /Y@A YG cy c@tmp div add def
  /X@B XG cx c@tmp div sub def
  /Y@B YG cy c@tmp div sub def
%    \end{macrocode}
% Test the chirality (the order) of the input points. Input angles $> 90$\textdegree
% don't make sense, in this case we exhange the calculated reference nodes.
%    \begin{macrocode}
  ax by mul ay bx mul sub 0 le {
    Y@A X@A 
    /X@A X@B def
    /Y@A Y@B def
    /X@B exch def
    /Y@B exch def
  } if
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{capHeight}
% Calculate the height \PSvar{a} of a pole cap, used for curved interfaces.
% \begin{pssyntax}
%   \PSvar{R} \PSvar{h} \PSop{capHeight} \PSvar{a}
% \end{pssyntax}
% \PSvar{R} is the circle radius and \PSvar{h} the width of the pole cap.
%    \begin{macrocode}
/capHeight {
    dup mul neg exch abs dup 3 1 roll dup mul add sqrt sub
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{leftCurvedIfc}
%   Calculate some parameters for the «left» interface of a lens. Defines and
%   \PSname{ArcL} which is used later in the code to actually draw the interface
%   curve.
% \begin{pssyntax}
%   \PSvar{h R1} \PSop{leftCurvedIfc} \PSvar{y |R1| alpha\textunderscore b
%     alpha\textunderscore t R1}
% \end{pssyntax}
%    \begin{macrocode}
/leftCurvedIfc {
  /R1 exch def /h exch def
  0 R1 abs dup R1 h capHeight exch sub R1 sign mul dup
  h exch atan exch
  h neg exch atan
  R1 0 lt {
    /ArcL /arcn load def
  } {
    /ArcL /arc load def
  } ifelse
  R1
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{rightCurvedIfc}
%   Analogous to \PSname{leftCurvedIfc} for «right» interfaces, defines
%   \PSname{ArcR} for later use.
% \begin{pssyntax}
%   \PSvar{h R2} \PSop{leftCurvedIfc} \PSvar{y |R2| alpha\textunderscore b
%     alpha\textunderscore t R2}
% \end{pssyntax}
%    \begin{macrocode}
/rightCurvedIfc {
  /R2 exch def /h exch def
  0 R2 abs dup R2 h capHeight sub R2 sign mul dup
  h neg exch atan exch
  h exch atan
  R2 0 lt {
    /ArcR /arcn load def
  } {
    /ArcR /arc load def
  } ifelse
  R2
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{SlopeAngle}
%   Calculate slope angle of a line from \PSname{nodeA} to \PSname{nodeB}.
%   \begin{pssyntax}
%     \PSname{nodeB} \PSname{nodeA} \PSop{SlopeAngle} \PSvar{angle}
%   \end{pssyntax}
%    \begin{macrocode}
/SlopeAngle {
  (SlopeAngle) DebugBegin
  @GetCenter 3 -1 roll @GetCenter @ABVect exch atan
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{DefineExtNode}
%   Constructs the coordinates of an external node based on values that have
%   been set beforehand. \PSvar{xref} and \PSvar{yref} are the values which are
%   defined by \opt{extnode} parameter. \PSvar{RefFac} is defined by parameter
%   \opt{extnodealign}, which determines it the reference of the external node
%   position should be the global coordinate system, or the line between the
%   reference nodes.
% \begin{pssyntax}
%   \PSvar{xref yref} \PSop{DefineExtNode} \PSvar{X Y}  
% \end{pssyntax}
%    \begin{macrocode}
/DefineExtNode {%
  (DefineExtNode) DebugBegin
  @@y mul RefFac mul @@y0 add 
  exch @@x mul RefFac mul @@x0 add exch
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetInternalNodeNames}
%   Push all internal node names of \PSstring{basicname} on the
%   stack. If \PSvar{reverse} is \PSvar{true}, the names are pushed in
%   reverse order.
%   \begin{pssyntax}
%     \PSstring{basicname} \PSvar{reverse} \PSop{GetInternalNodeNames}
%     \PSname{N@basicnameN} \ldots{} \PSname{N@basicname1} (if
%     \PSvar{reverse = false})
%   \end{pssyntax}
%    \begin{macrocode}
/GetInternalNodeNames {
  (GetInternalNodeNames) DebugBegin
  /reverse ED
  dup cvn load /N get dup
  reverse { -1 1 } { 1 1 3 -1 roll } ifelse
  { 2 copy eq { pop (N) } { inttostr } ifelse
    3 -1 roll dup 4 1 roll exch NodeName 3 1 roll
  } for
  pop pop
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetInternalBeamNodes}
%   This is like \PSvar{GetInternalNodeNames}, but leaves the node
%   coordinates on the stack
% \begin{pssyntax}
%   \PSstring{basicnodename} \PSvar{reverse} \PSop{GetInternalBeamNodes}
%   \PSvar{XN YN \ldots\ X1 Y1} (if \PSvar{reverse = false})
% \end{pssyntax}
%    \begin{macrocode}
/GetInternalBeamNodes {
  (GetInternalBeamNodes) DebugBegin
  [ 3 1 roll GetInternalNodeNames ]
  { @GetCenter } forall
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{GetInternalBeamNodesCompat}
%   Equivalent to \PSvar{GetInternalBeamNodes} only that it checks if the
%   component is ambiguous (i.e. it is a beamsplitter), in which case it returns
%   only the center node. Used only for the deprecated \opt{conn} parameter.
%    \begin{macrocode}
/GetInternalBeamNodesCompat {
  exch dup 3 1 roll (C) NodeName dup tx@NodeDict exch known {
    @GetCenter ToVec 
    3 1 roll pop pop
  } {
    pop GetInternalBeamNodes
  } ifelse
} bind def
/GetInternalBeamNodeCompat {
  exch dup 3 1 roll (C) NodeName dup tx@NodeDict exch known {
    @GetCenter ToVec
    3 1 roll pop pop
  } {
    pop NodeName @GetCenter ToVec
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{InitOptexpComp}
%   Initialize some global variables for positioning of external
%   nodes. This is called at the beginning of every component.
%    \begin{macrocode}
/InitOptexpComp {%
  /@@x 0 def
  /@@y 0 def
  /@@x0 0 def
  /@@y0 0 def
  /@xref 0 def
  /@yref 0 def
  /RefFac 1 def
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{NewTempNodeComp}
%   If \cs{draw*beam} is invoked with a node as parameter, a
%   temporary \cs{optplane} is defined. The plane vector of this temporary plane
%   is set such that it is perpendicular to the connection between the node and the following
%   interface node. 
%
%   This is the only procedure which sets the \PSname{adjustRel} flag
%   which indicates adjustment of the plane vector rotation depending on
%   the incoming or outgoing connection direction.
% 
%   For an explanation of all other dictionary members, please see
%   \PSvar{NewOptexpComp}.
%   \begin{pssyntax}
%     \PSproc{x y} \PSproc{dx dy} \PSstring{name} \PSproc{scaling}
%     \PSop{NewTempNodeComp}
%   \end{pssyntax}
%    \begin{macrocode}
/NewTempNodeComp {
  (NewTempNodeComp) DebugBegin
  /sc ED
  dup cvn
  6 dict dup 3 1 roll def begin
    /ambiguous false def
    /allowbeaminside false def
    /name ED
    /correct false def
%    \end{macrocode}
% This definition does not work like for \PSvar{NewOptexpComp}, because
% a current point may not be available. Therefore, we translate to the
% $(X, Y)$ node and define $X = Y = 0$.
%    \begin{macrocode}
    {0 0} exch 3 -1 roll exec
    gsave
      translate
      /CompMtrx CM def
    grestore
    /N 1 def
    /n bgRefIndex def
    5 dict dup dup /P@1 ED /P@N ED
    begin
      /mode trans def
      {} 0 0 PlainIfc
    end
  /adjustRel true def
  end
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{CurvedIfc}
% Defines a curved interface.
% \begin{pssyntax}
%   \PSproc{X Y} \PSproc{DX DY} \PSproc{scl} \PSvar{NAlow NAup} \PSop{CurvedIfc}
% \end{pssyntax}
%    \begin{macrocode}
/CurvedIfc {
  5 2 roll
  2 copy 5 3 roll exec 3 -1 roll exec VecAdd 
  5 -1 roll exec /Y ED /X ED
  exch exec 3 -1 roll 3 copy exec /RY ED /RX ED
  3 1 roll NormalizeVec 3 -1 roll exec
  tx@Dict begin Pyth end dup
  3 1 roll mul 1.00001 mul /NAup ED
  mul 1.00001 mul /NAlow ED
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PlainIfc}
%   \begin{pssyntax}
%     \PSproc{X Y} \PSproc{DX DY} \PSproc{scl} \PSvar{NAlow NAup} \PSop{PlainIfc}
%   \end{pssyntax}
%    \begin{macrocode}
/PlainIfc {
  5 2 roll
  dup 3 -1 roll exec NormalizeVec 3 -1 roll exec 2 copy /DY ED /DX ED
  tx@Dict begin Pyth end dup 4 2 roll
  exch exec 3 -1 roll exec /Y ED /X ED
  3 1 roll mul 1.00001 mul /NAup ED
  mul 1.00001 mul /NAlow ED
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NewCompIfc}
% Defines a new interface of a component, must be called within \PSvar{NewOptexpComp}.
% \begin{pssyntax}
%   \PSproc{x y} \PSproc{dx dy|rx ry} \PSvar{NAlow NAup mode} 
%   \PSstring{CompName} \PSstring{Name} \PSproc{New\ldots Ifc} \PSproc{scaling} 
%   \PSop{NewCompIfc}
% \end{pssyntax}
% \begin{psarglist}
% \psargitem{\PSproc{x y}} The coordinates of the interface node which lies on the optical axis.??
% \psargitem{\PSproc{dx dy | rx ry}} For a plane interface, this is the vector that describes the plane, for a curved interface this is the
% \psargitem{\PSvar{NAlow NAup}}
% \psargitem{\PSvar{mode}} An integer which characterizes if an interface is
%   reflective or transmittive. You should use the predefined variable
%   \PSname{refl} and \PSname{trans} for this.
% \psargitem{\PSstring{CompName}} The name of the component we are in.
% \psargitem{\PSstring{Name}} The name of the new interface. It is prefixed by «P@».
% \psargitem{\PSproc{\ldots Ifc}} Contain the actual procedure to define the
%   concrete interface type, can be \PSproc{PlainIfc} or
%   \PSproc{CurvedIfc}.
% \end{psarglist}
%    \begin{macrocode}
/NewCompIfc {
  /scl ED
  /next ED
  dup (P@) exch strcat cvn
  6 dict dup
  3 1 roll def
  begin
    3 -1 roll
    /mode ED
    6 -1 roll dup 7 -1 roll
    {scl} 8 -2 roll next
  end
%    \end{macrocode}
% store a new node \PSname{N@NameX}, with X=1..N this node always
% represents the intersection of an untilted and unshifted incoming beam
% on the optical axis with the respective interface
%    \begin{macrocode}
  exec scl ToVec 3 1 roll NodeName @NewNode
} bind def
%    \end{macrocode}
% \end{macro}
% 
% Define some constants.
%    \begin{macrocode}
/relative 0 def /absolute 1 def /center 2 def
/refl 0 def /trans 1 def /absorb 2 def
/desc 0 def /asc 1 def /amb 2 def
/ok 0 def /tir 1 def /missed 2 def
/bgRefIndex 0 def
%    \end{macrocode}
% 
% \begin{macro}{NewOptexpComp}
% \PSvar{NewOptexpComp} creates a new dictionary that contains everything needed
% for an optical component. It contains the following variables:
% \begin{psarglist} 
%   \psargitem{\PSvar{n}} The basic refractive index which was set for the
%   component. This may be overwritten with the \opt{n} option of the
%   \nxLcs{drawbeam} macros.
%
%   \psargitem{\PSvar{CompMtrx}} The transformation matrix at time of
%   the component definition. The method is the same as for the
%   \nxLPack{pst-node} nodes.
%
%   \psargitem{\PSvar{name}} The name of the component. This is build of
%   several components which are put together in the \TeX\ code.
%
%   \psargitem{\PSvar{N}} The number of interfaces of the component.
%
%   \psargitem{\PSvar{P@1\ldots P@N}} The actual
%   interfaces. \PSvar{P@1} and \PSvar{P@N} are always defined, even if
%   \PSvar{N = 1}. In that case the two names link to the same
%   dictionary, so that changes in one of them are automatically present
%   also in the second one.
%
%   \psargitem{\PSproc{sc}} The scaling procedure for the coordinates to convert
%   from \TeX{} to Postscript scaling. In should always be defined as
%   \PSproc{\textbackslash psxunit, \textbackslash psyunit}.
%
%   \psargitem{\PSvar{ambiguous}} There is a class of components (at the
%   moment only \nxLcs{beamsplitter}), which have a central interface
%   \PSvar{P@C} which can be either transmittive or reflective,
%   depending on the previous and following component positions. The
%   mode of the \PSvar{P@C} is determined at the time of the beam
%   drawing and requires special attention.
%
%   \psargitem{\PSvar{correct}} If \opt{true}, the input vectors after
%   the transmittive interfaces are corrected when using
%   \opt{connectifc}.
% \end{psarglist}
%
% \begin{pssyntax}
%   \PSvar{[} \PSproc{x y} \PSproc{dx dy | rx ry} \PSvar{NAlow NAup} \PSvar{type}
%   \PSproc{\ldots Ifc} \PSvar{\ldots{} [n] correct? amb? allowbeaminside?} 
%   \PSstring{CompName} \PSproc{scaling} \PSop{NewOptexpComp}
% \end{pssyntax}
%    \begin{macrocode}
/NewOptexpComp {
  (NewOptexpComp) DebugBegin
  /sc ED dup cvn
  gsave
  12 dict dup 3 1 roll def begin
  /name ED
  /allowbeaminside ED
  /ambiguous ED
  dup type /booleantype eq not { false } if /correct ED
  tx@Dict begin
    STV {CP T} stopped pop
  end
  /CompMtrx CM def
  grestore
  counttomark dup 6 idiv dup /N ED 6 mul eq { 1 } if 
  cvx 1 EvalRefIndex /n ED
%    \end{macrocode}
% This defines for ambiguous components, which interface coincides with the
% ambiguous interface. 0 indicates that there is no ambiguous interface.
%    \begin{macrocode}
  ambiguous { 
    /ambIfc ED 
  }{ 
    /ambIfc 0 def 
  } ifelse
  1 N eq {
%    \end{macrocode}
% only a single plane is specified, create the aliases.
%    \begin{macrocode}
      name (1) 3 -1 roll {sc} NewCompIfc 
      (1) (N) IfcAlias
  }{
    N -1 1 { %
      dup N eq { pop (N) }{inttostr} ifelse
      exch name 3 1 roll {sc} NewCompIfc
    } for
  } ifelse
  ambiguous ambIfc 0 gt and { 
    ambIfc N eq { (N) }{ ambIfc inttostr } ifelse (C) IfcAlias
  } if
  end
  pop
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{NewOptexpFiberComp}
% \begin{pssyntax}
%   \PSvar{[} \PSvar{x y} \ldots
%   \PSstring{CompName} \PSproc{scaling} \PSop{NewOptexpFiberComp}
% \end{pssyntax}
%    \begin{macrocode}
/NewOptexpFiberComp {
  (NewOptexpFiberComp) DebugBegin
  /sc ED dup cvn
  gsave
  12 dict dup 3 1 roll def begin
  /name ED
  tx@Dict begin
    STV {CP T} stopped pop
  end
  /CompMtrx CM def
  grestore
  counttomark /N ED
  1 N eq {
%    \end{macrocode}
% only a single plane is specified, create the aliases.
%    \begin{macrocode}
    {0 1} 0 0 trans name (1) {PlainIfc} {sc} NewCompIfc 
    (1) (N) IfcAlias
  }{
    N -1 1 {
      dup N eq { pop (N) }{inttostr} ifelse
      {0 1} 0 0 absorb name 6 -1 roll {PlainIfc} {sc} NewCompIfc
    } for
  } ifelse
  end
  pop
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{IfcAlias}
%   Create an alias of an interface. This involves creating also an
%   alias for the associated node.  Must be called withing
%   \PSvar{NewOptexpComp}.
%
% \PSstring{OrigPN} \PSstring{AliasPN} \PSop{IfcAlias}
%    \begin{macrocode}
/IfcAlias {
  2 copy IfcName exch IfcName load def
  tx@NodeDict begin 
    name exch NodeName name 3 -1 roll NodeName load def
  end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetPlaneVec}
%   Push the coordinates of the plane vector on the stack, for curved interfaces
%   this is the tangent at the interface node.
%   \begin{pssyntax}
%     \PSvar{IfcNum} \PSstring{CompName} \PSop{GetPlaneVec} \PSvar{dX dY}
%   \end{pssyntax}
%    \begin{macrocode}
/GetPlaneVec {
  (GetPlaneVec) DebugBegin
  cvn load begin
    IfcName load begin
      currentdict /RX known {
        RX RY CompMtrx dtransform CM idtransform
        neg exch
      } {
        DX DY CompMtrx dtransform CM idtransform
      } ifelse
    end
  end
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetIfcCenter}
% Get the center node of a interface, either by specifying the name of the component and the interface number
%   \begin{pssyntax}
%     \PSvar{IfcNum} \PSstring{CompName} \PSop{GetIfcCenter} \PSvar{X Y}
%   \end{pssyntax}
% or by passing an interface procedure generated by \PSvar{PushAllPlanesOnStack}.
%   \begin{pssyntax}
%     \PSproc{Ifc} \PSop{GetIfcCenter} \PSvar{X Y}
%   \end{pssyntax}
%    \begin{macrocode}
/GetIfcCenter {
  (GetIfcCenter) DebugBegin
  dup type /stringtype eq not {
    dup xcheck not {
%    \end{macrocode}
% ambiguous
%    \begin{macrocode}
      0 get (C) exch
    } {
      exec pop pop pop
    } ifelse
  } if
  cvn load begin
    IfcName load begin
      currentdict /RX known {
        X RX sub Y RY sub
      } {
        X Y
      } ifelse
      CompMtrx transform CM itransform
    end
  end
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TransformInVec}
%   Transform the input vector as specified with \opt{beamangle} and
%   \opt{beamdiv} from coordinates relative to the connection between first and
%   second components to absolute coordinates.
%   \begin{pssyntax}
%     \PSproc{Ifc2} \PSproc{Ifc1} \PSproc{InVec} \PSop{TransformInVec} \PSproc{InVec'}
%   \end{pssyntax}
%    \begin{macrocode}
/TransformInVec {
  (TransformInVec) DebugBegin
  3 1 roll
  GetIfcCenter 4 2 roll
  GetIfcCenter 5 -2 roll
  @ABVect
  3 -1 roll exec 2 copy 6 2 roll
  0 eq exch 0 eq and not {
%    \end{macrocode}
% invec != (0,0)
%    \begin{macrocode}
    exch atan matrix rotate dtransform
  } {
    4 2 roll pop pop
  } ifelse
  ToVec
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TransformStartPos}
% Startpos is relative to the connection between first and second components
% transform to absolute coordinates and shift by first plane center
% Plane2 Plane1 \PSproc{StartPos} -> \PSproc{StartPos'+Plane1Center}
%    \begin{macrocode}
/TransformStartPos {
  (TransformStartPos) DebugBegin
  exec 2 copy 6 2 roll 0 eq exch 0 eq and not
  3 1 roll GetIfcCenter 4 2 roll
  GetIfcCenter 5 2 roll {
    2 copy 8 2 roll
    @ABVect exch atan matrix rotate dtransform
    VecAdd
  } {
    6 2 roll pop pop pop pop
  } ifelse
  ToVec
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetNearestPlane}
%   \begin{pssyntax}
%     \PSvar{X Y} \PSstring{CompName} \PSop{GetNearestPlane} \PSvar{PlaneNumber}
%   \end{pssyntax}
%    \begin{macrocode}
/GetNearestPlane {
  (GetNearestPlane) DebugBegin
  3 copy 1 exch GetIfcCenter @ABDist /dist ED /nearestPlane 1 def
  dup cvn load /N get 2 1 3 -1 roll {
%    \end{macrocode}
% iterate through plane 2 to plane N of CompName 
%    \begin{macrocode}
    4 copy exch GetIfcCenter @ABDist dup dist lt {
      /dist ED /nearestPlane ED
    } {
      pop pop
    } ifelse
  } for
  pop pop pop nearestPlane
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PushAmbCompPlanesOnStack}
% Components which do not have an unambiguous behaviour (beamslitter, can
% transmit and reflect) like lenses (transmission only) or mirrors (reflection
% only), must be evaluated to see which mode should be used.  Argument is
% [(name) draw], draw is a boolean which is true if the inner beams should be
% drawn.
%    \begin{macrocode}
/PushAmbCompPlanesOnStack {
 (PushAmbCompPlanesOnStack) DebugBegin 
  currentdict /outToPlane undef
  PN IfcCnt eq not {
%    \end{macrocode}
% not the last component, there should be another one on the stack
%    \begin{macrocode}
    exch dup 3 1 roll % nextifc ambcomp nextifc
    dup xcheck not {
%    \end{macrocode}
% the next component is also ambiguos, use its center point as reference.
%    \begin{macrocode}
      0 get (C) exch
    } {
%    \end{macrocode}
% otherwise use the interface on the stack
%    \begin{macrocode}
      exec pop pop pop
    } ifelse
    [ 3 1 roll ] cvx /outToPlane ED
%    \end{macrocode}
% outToPlane is \PSproc{(PN) (compName)}
%    \begin{macrocode}
  } if
%    \end{macrocode}
% the old plane number, without counting the additional planes of the current ambcomp
%    \begin{macrocode}
  /IfcCntTmp IfcCnt def
%    \end{macrocode}
% Load some parameters from \opt{ambcomp}
%    \begin{macrocode}
  aload pop /draw ED /name ED
  name cvn load /N get /N ED
  currentdict /Curr known {
    /CurrTmp /Curr load def
    /CurrVecTmp /CurrVec load def
  } {
    /CurrTmp /CurrLow load def
    /CurrVecTmp /CurrVecLow load def
  } ifelse
%    \end{macrocode}
% \PSvar{CurrTmp} is the current point of the beam on the interface prior to the
% ambiguos component, \PSvar{CurrVecTmp} its outgoing vector. For wide beams,
% the lower ray is used.
%    \begin{macrocode}
  PN 1 eq {
%    \end{macrocode}
% If it is the first interface, the starting point is always the (C) plane
%    \begin{macrocode}
    [ (C) name name GetRefIndex trans draw] cvx
%    \end{macrocode}
% Now check which is the outgoing plane
%    \begin{macrocode}
    name /outToPlane load GetNextPlane
    dup 0 eq not {
%    \end{macrocode}
% If there is one, i.e. if \PSvar{GetNextPlane} leaves something not equal to \PSvar{0} on the stack, this is the plane.
%    \begin{macrocode}
      [ exch name bgRefIndex trans draw ] cvx exch
      /IfcCntTmp IfcCntTmp 1 add def
    } {
      pop
    } ifelse
  }{
    CurrTmp name GetNearestPlane dup /firstPlane ED
    name isAmbiguousIfc not {
%    \end{macrocode}
% The first interface is not the ambiguous one.
%
% check if mode is trans or refl
%    \begin{macrocode}
      CurrVecTmp firstPlane name GetPlaneVec NormalVec
      (C) name GetIfcCenter firstPlane name GetIfcCenter 
      @ABVect 2 copy 6 2 roll DotProd 
      0 lt { trans }{ refl } ifelse
      3 1 roll ToVec /CurrVecTmp ED
      [ firstPlane name
      connectifc {
        bgRefIndex
      }{
        name GetRefIndex
      } ifelse
%    \end{macrocode}
% always draw to first interface
%    \begin{macrocode}
      5 -1 roll true ] cvx
      /IfcCntTmp IfcCntTmp 1 add def
    } if
    PN IfcCnt eq {
%    \end{macrocode}
% its the last comp, just put the center plane on the stack
%    \begin{macrocode}
      [ (C) name
      name GetRefIndex
      trans draw ] cvx
      IfcCntTmp IfcCnt gt { exch } if
    } {
%    \end{macrocode}
% check the mode of the ambiguous interface
%    \begin{macrocode}
      [ (C) name
      name GetRefIndex
      CurrVecTmp (C) name GetPlaneVec NormalVec outToPlane 
      GetIfcCenter (C) name GetIfcCenter @ABVect DotProd
      0 lt { trans } { refl } ifelse % mode
      draw ] cvx 
%    \end{macrocode}
% now check which is the outgoing plane
%    \begin{macrocode}
      name /outToPlane load GetNextPlane
      dup dup name isAmbiguousIfc exch 0 eq or not {
        [ exch name bgRefIndex trans draw ] cvx exch
        firstPlane name isAmbiguousIfc not { 3 -1 roll } if
        /IfcCntTmp IfcCntTmp 1 add def
      } {
        pop
%    \end{macrocode}
% The ambiguous interface is the last one, correct it to have the bgRefIndex.
%    \begin{macrocode}
        exec 3 -1 roll pop bgRefIndex 3 1 roll [ 6 1 roll ] cvx
        firstPlane name isAmbiguousIfc not { exch } if
      } ifelse
    } ifelse
  } ifelse
  /IfcCnt IfcCntTmp def
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetNextPlane}
% \PSstring{comp} \PSproc{outToPlane} \PSop{GetNextPlane} \PSvar{PlaneNumber}
%    \begin{macrocode}
/GetNextPlane {
  (GetNextPlane) DebugBegin
  2 copy (C) 3 -1 roll
  GetIfcCenter 3 -1 roll exec GetIfcCenter 
  4 2 roll 4 copy @ABVect /VecY ED /VecX ED 
  @ABDist /centerDist ED
  /sprod 1 def
  /nextPlane 0 def
  exch dup 3 1 roll
  cvn load dup /ambIfc get /ambIfc ED /N get 1 1 3 -1 roll {
%    \end{macrocode}
% iterate through all interfaces of CompName which do not coincide with the ambiguous interface
%    \begin{macrocode}
   dup ambIfc eq not {
      3 copy 3 -1 roll 2 copy
      GetPlaneVec VecX VecY 4 2 roll NormalVec 
      VecX VecY DotProd dup sprod lt 5 2 roll
      GetIfcCenter 3 -1 roll exec GetIfcCenter @ABDist 
      centerDist lt and
      { /sprod ED /nextPlane ED } { pop pop } ifelse
    } {
      pop
    } ifelse
  } for
  pop pop nextPlane
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TraceBeam}
% [ CompN ... Comp1 \PSproc{options} \PSproc{start point} \PSvar{beamangle}
% -> Yn Xn drawToN? ... Y1 X1 drawTo1? Y0 X0
%    \begin{macrocode}
/TraceBeam {
  (Tracebeam) DebugBegin
  AngToVec /InVec ED /StartPoint ED
  /oldbeaminsidelast currentdict /beaminsidelast known { 
    beaminsidelast 
  } { 
    false 
  } ifelse def
%    \end{macrocode}
% execute options
%    \begin{macrocode}
  exec
  connectifc {
    /nbeam bgRefIndex def
  } if
  /startinside startinside beaminsidefirst or def
  /stopinside stopinside beaminsidelast or def
  /PrevCorrect false def
  PrearrangePlanes
  PushAllPlanesOnStack
  currentdict /lastVecTmp known {
    /lastVecTmp load
  } {
    beamalign relative eq counttomark 2 ge and {
      2 copy /InVec load TransformInVec
    } {
      /InVec load
    } ifelse
  } ifelse
  /CurrVec ED
  currentdict /lastBeamPointTmp known {
    /lastBeamPointTmp load /Curr ED
  }{
    counttomark 2 ge {
      2 copy /StartPoint load  TransformStartPos 
    } {
      /StartPoint load 
    } ifelse
    /Curr ED
  } ifelse
  counttomark /IfcCnt ED 
%    \end{macrocode}
% Init the refractive index
%    \begin{macrocode}
  /n1 bgRefIndex def
  /PN 1 def
  (start looping) DebugMsg
  {
    PN IfcCnt gt {
      exit
    } if
    (checked) DebugMsg
%    \end{macrocode}
% iterate over all planes
%    \begin{macrocode}
    dup xcheck not {
%    \end{macrocode}
% array, not executable
%    \begin{macrocode}
      PushAmbCompPlanesOnStack
    } if
    exec
    /draw ED /Mode ED /n2 ED 2 copy /CompName ED /IfcNum ED
    GetIfcCenter ToVec /CurrCenter ED
    Curr CurrVec 
    connectifc PrevCorrect PN 2 gt and PN 2 eq or and {
      CurrVec CurrCenter PrevCenter PrevMode 
      currentdict /relAngle known 
      { relAngle } { 0 } ifelse connectInterfaces
      /relAngle ED
    } if
    IfcNum CompName Mode n2 8 4 roll HandleInterface
    missed eq {
      counttomark PN 1 sub 3 mul sub {pop} repeat
      (The beam missed an interface) Warning exit
      exit
    } if
    PN 1 eq {
      pop pop
      /draw beaminsidefirst oldbeaminsidelast xor def
    } {
      ToVec /CurrVec ED
    } ifelse
    2 copy
    ToVec /Curr ED 
    draw PN skipconn 1 add gt and
    counttomark 3 roll
    /PrevCenter /CurrCenter load def
    /lastBeamPointTmp /Curr load def
    /lastVecTmp /CurrVec load def
    /PrevMode Mode def
    CompName cvn load /correct get /PrevCorrect ED
    PN IfcCnt eq {
      exit
    } {
      CurrVec 0 eq exch 0 eq and {
        IfcCnt PN sub {pop} repeat
        (Total internal reflection occured, this is not supported)
        Warning
        exit
      } if
      /PN PN 1 add def
    } ifelse
  } loop
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{Drawbeam}
% [ CompN ... Comp1 \PSproc{options} \PSproc{start point} \PSproc{input vector}
%    \begin{macrocode}
/Drawbeam {
  counttomark 3 le {
%    \end{macrocode}
% first ray misses the next interface or is even parallel to the input interface.
%    \begin{macrocode}
    cleartomark
  }{
%    \end{macrocode}
% Go to start point
%    \begin{macrocode}
    pop 5 copy 3 -1 roll pop ArrowA pop pop pop pop
    counttomark 3 idiv -1 2 {
      pop {
        lineto
      }{
        moveto
      } ifelse
    } for
    {CP 4 2 roll ArrowB lineto pop pop } {moveto} ifelse
%    \end{macrocode}
% remove the mark
%    \begin{macrocode}
    pop
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{sign}
%    \begin{macrocode}
/sign {
    0 ge { 1 } { -1 } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TraceAndFillWideBeam}
% Fill a wide beam. This has an own procedure, because each segment
% of the beam must be filled separately.
% \begin{pssyntax}
%   \PSvar{[} \PSstring{CompN} \PSvar{\ldots{}} \PSstring{Comp1}
%   \PSproc{options} \PSproc{start point up} \PSvar{beamangle\_up}
%   \PSproc{start point low} \PSvar{beamangle\_low} \PSop{FillWideBeam}
% \end{pssyntax}
%    \begin{macrocode}
/TraceAndFillWideBeam {
  (TraceAndFillWideBeam) DebugBegin
  AngToVec /InvecLow ED /StartLow ED 
  AngToVec /InvecUp ED /StartUp ED 
%    \end{macrocode}
% execute user options
%    \begin{macrocode}
  exec
  connectifc {
    /nbeam bgRefIndex def
  } if
  /startinside startinside beaminsidefirst or def
  /stopinside stopinside beaminsidelast or def
%    \end{macrocode}
% Number of segments already drawn
%    \begin{macrocode}
  /DrawnSegm 0 def
%    \end{macrocode}
% whether the previous plane required correction of the input vector (used only with \opt{connectifc})
%    \begin{macrocode}
  /PrevCorrect false def
  PrearrangePlanes
  PushAllPlanesOnStack
  currentdict /lastVecTmpUp known 
  currentdict /lastVecTmpLow known and {
    /CurrVecLow /lastVecTmpLow load def
    /CurrVecUp /lastVecTmpUp load def
  }{
%    \end{macrocode}
% If the \opt{beamangle} is not absolute, use the connection between the first
% two planes as reference and transform the input vectors accordingly.
%    \begin{macrocode}
    beamalign relative eq counttomark 2 ge and {
      2 copy /InvecLow load TransformInVec /CurrVecLow ED
      2 copy /InvecUp load TransformInVec /CurrVecUp ED
    } {
      /CurrVecLow /InvecLow load def
      /CurrVecUp /InvecUp load def
    } ifelse
  } ifelse
%    \end{macrocode}
% If \opt{loadbeampoints} is set, the nodes \PSname{lastBeamPointTmpLow} and
% \PSname{lastBeamPointTmpUp} are defined and used as starting points.
%    \begin{macrocode}
  currentdict /lastBeamPointTmpLow known 
  currentdict /lastBeamPointTmpUp known and {
    /lastBeamPointTmpLow load /CurrLow ED
    /lastBeamPointTmpUp load /CurrUp ED
  } {
    counttomark 2 ge {
      2 copy /StartLow load TransformStartPos /CurrLow ED
      2 copy /StartUp load TransformStartPos /CurrUp ED
    } {
      /StartLow load /CurrLow ED
      /StartUp load /CurrUp ED
    } ifelse
  } ifelse
%    \end{macrocode}
% \PSvar{IfcCnt} is the number of interfaces pushed on the stack by
% \PSvar{PushAllPlanesOnStack}. This number may be corrected later if an
% ambiguous components is among them.
%    \begin{macrocode}
  counttomark /IfcCnt ED 
  /n1 bgRefIndex def
  /CurrR false def
  /ret missed def
  /PN 1 def
  {
    PN IfcCnt gt {
      exit
    } if
    dup xcheck not {
%    \end{macrocode}
% Found an array (not executable) instead of a procedure. This is an ambiguous
% component, resolve the interfaces depending on the input vector and
% surrounding interfaces. This can change \PSvar{IfcCnt}.
%    \begin{macrocode}
      PushAmbCompPlanesOnStack
    } if
%    \end{macrocode}
% push the interface on the stack
%    \begin{macrocode}
    exec
%    \end{macrocode}
% \PSvar{draw} indicates if the beam to the current interface should be drawn.
%    \begin{macrocode}
    PN skipconn 1 add gt and /draw ED
%    \end{macrocode}
% \PSvar{Mode} stores the mode (transmittive or reflective) of the current interface.
%    \begin{macrocode}
    /Mode ED /n2 ED 2 copy /CompName ED /IfcNum ED
%    \end{macrocode}
% \PSvar{CurrPCenter} holds the coordinates of the current interface center.
%    \begin{macrocode}
    GetIfcCenter ToVec /CurrPCenter ED
    /oldn1 n1 def
%    \end{macrocode}
% Calculate new upper vector and intersection point
%    \begin{macrocode}
    CurrUp CurrVecUp
    connectifc PrevCorrect PN 2 gt and PN 2 eq or and {
      CurrVecUp CurrPCenter PrevPCenter PrevMode 
      currentdict /relAngleUp known { relAngleUp } { 0 } ifelse 
      connectInterfaces /relAngleUp ED
    } if
    /CurrVecUp load /PrevVecUp ED
    /CurrUp load /PrevUp ED
    IfcNum CompName Mode n2 8 4 roll HandleInterface
    dup /ret ED
    missed eq {
      counttomark {pop} repeat 
      (The upper beam missed an interface) Warning exit
    } if
    ToVec /CurrVecUp ED
    ToVec /CurrUp ED
    /n1 oldn1 def
%    \end{macrocode}
% Calculate new lower vector and intersection point
%    \begin{macrocode}
    /CurrVecLow load /PrevVecLow ED
    /CurrLow load /PrevLow ED
    CurrLow CurrVecLow
    connectifc PrevCorrect PN 2 gt and PN 2 eq or and  {
      CurrVecLow CurrPCenter PrevPCenter PrevMode 
      currentdict /relAngleLow known { relAngleLow } { 0 } ifelse 
      connectInterfaces /relAngleLow ED
    } if
    IfcNum CompName Mode n2 8 4 roll HandleInterface
    dup missed eq {
      /ret ED
      (The lower beam missed an interface) Warning
      counttomark {pop} repeat exit
    } if
    tir eq ret tir eq or {
      /ret tir def
    } {
      /ret ok def
    } ifelse
    ToVec /CurrVecLow ED
    ToVec /CurrLow ED
%    \end{macrocode}
% lower done
%    \begin{macrocode}
    /PrevR CurrR def
    PrevR type /realtype eq {
      /CurrCenter load /PrevCenter ED
    } if
    IfcNum CompName isCurved {
      IfcNum CompName LoadIfc
      tx@Dict begin Pyth end /CurrR ED
      ToVec /CurrCenter ED
    } {
      /CurrR false def
      /CurrCenter false def
    } ifelse
    PN 1 gt currentdict /fillBeam known and {
      draw {
        /DrawnSegm DrawnSegm 1 add def
        PrevUp moveto CurrUp lineto
        IfcNum CompName isCurved {
          CurrCenter CurrUp CurrLow 
          4 copy 3 -1 roll eq 3 1 roll eq and {
            6 {pop} repeat
          } {
            TangentCrosspoint
            CurrLow CurrR arct
          } ifelse
        } {
          CurrLow lineto
        } ifelse
        PrevLow lineto
        PrevR type /booleantype eq not {
%    \end{macrocode}
% previous interface was also curved
%    \begin{macrocode}
          PrevCenter PrevLow PrevUp
          4 copy 3 -1 roll eq 3 1 roll eq and {
            6 {pop} repeat
          } {
            TangentCrosspoint
            PrevUp PrevR arct
          } ifelse
        } {
          PrevUp lineto
        } ifelse
      } if
      Mode refl eq draw and
      draw not DrawnSegm 0 gt and or {
        fillBeam newpath
        /DrawnSegm 0 def
      } if
    } if
    PN 1 eq {
%    \end{macrocode}
% PN == 1
%    \begin{macrocode}
      /CurrVecUp /PrevVecUp load def
      /CurrVecLow /PrevVecLow load def
    } if
%    \end{macrocode}
% If the beam should also be stroked, push the coordinates and the 'draw' information on the stack
%    \begin{macrocode}
    strokeBeam {
      CurrUp draw CurrLow draw counttomark 1 add 6 roll
    } if
    PN IfcCnt eq ret tir eq or {
      DrawnSegm 0 gt currentdict /fillBeam known and { 
        fillBeam newpath 
        /DrawnSegm 0 def
      } if
      ret tir eq {
        IfcCnt PN sub {pop} repeat
        (Total internal reflection occured, this is not supported) 
        Warning
      } if
      exit
    } if
    /PN PN 1 add def
    /PrevPCenter /CurrPCenter load def
    /PrevMode Mode def
    CompName cvn load /correct get /PrevCorrect ED
  } loop
  DrawnSegm 0 gt currentdict /fillBeam known and {
    fillBeam newpath
    /DrawnSegm 0 def
  } if
  ret missed eq not {
    CurrUp CurrLow @ABVect 
    CurrVecUp CurrVecLow 3 -1 roll add 3 1 roll add exch
    4 -1 roll mul 3 1 roll mul sub 0 gt {
%    \end{macrocode}
% swap upper and lower beam points for next beam
%    \begin{macrocode}
      /lastBeamPointTmpUp /CurrLow load def
      /lastBeamPointTmpLow /CurrUp load def
      /lastVecTmpUp /CurrVecLow load def
      /lastVecTmpLow /CurrVecUp load def
    } {
      /lastBeamPointTmpLow /CurrLow load def
      /lastBeamPointTmpUp /CurrUp load def
      /lastVecTmpUp /CurrVecUp load def
      /lastVecTmpLow /CurrVecLow load def
    } ifelse
  } if
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{isAmbiguous}
%   Check if \PSvar{compname} is ambiguous, i.e. if it can have alternating beam
%   paths depending on the input and output plane (e.g. beamsplitter can either
%   transmit or reflect a beam).
%   \begin{pssyntax}
%     \PSstring{compname} \PSop{isAmbiguous} \PSvar{boolean}
%   \end{pssyntax}
%    \begin{macrocode}
/isAmbiguous { 
  cvn load dup /ambiguous known {
    /ambiguous get
  } { 
    pop false
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{isAmbiguousIfc}
%   Check if interface \PSvar{IfcNum} is the ambiguous interface of \PSvar{compname}.
%   \begin{pssyntax}
%     \PSvar{IfcNum} \PSstring{compname} \PSop{isAmbiguousIfc} \PSvar{boolean}
%   \end{pssyntax}
%    \begin{macrocode}
/isAmbiguousIfc { 
  cvn load dup /ambiguous known {
    /ambIfc get eq
  } { 
    pop pop false
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{isCurved}
%  Check if interface \PSvar{IfcNum} of componente \PSvar{compname} is curved.
%   \begin{pssyntax}
%     \PSvar{IfcNum} \PSstring{compname} \PSop{isCurved} \PSvar{bool}
%   \end{pssyntax}
%    \begin{macrocode}
/isCurved {
  cvn load begin
    IfcName load /RX known
  end
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{HandleInterface}
% \begin{pssyntax}
% \PSvar{IfcNum} \PSstring{CompName} \PSvar{mode n2 X0 Y0 Xin Yin} 
% \PSop{HandleInterface} 
% \PSvar{X0' Y0' Xout Yout status}
% \end{pssyntax}
%    \begin{macrocode}
/HandleInterface {
  (HandleInterface) DebugBegin
  /Yin ED /Xin ED /Y0 ED /X0 ED /n2 ED /mode ED
  2 copy 2 copy LoadIfc
  6 -2 roll isCurved { CurvedInterface }{ PlainInterface } ifelse
%    \end{macrocode}
% IfcNum CompName X0' Y0' Xout Yout status
%
% Check if X0' Y0' are within the numerical aperture of the interface
%    \begin{macrocode}
  dup missed eq not {
    7 3 roll 2 copy 9 2 roll
    4 2 roll 2 copy
    %% X0' Y0' Xout Yout status X0' Y0' IfcNum CompName IfcNum CompName
    cvn load begin IfcName load dup /NAlow get exch /NAup get end
    2 copy lt {
      4 2 roll 2 copy LoadIfc NormalizeVec
      6 -2 roll isCurved {
        neg exch
      } if
      %% ... X0' Y0' NAlow NAup X Y dXp dYp
      8 -2 roll 6 -2 roll
      %% ... NAlow NAup dXp dYp X0' Y0' X Y
      @ABVect DotProd
      dup 4 -1 roll ge 3 1 roll ge and not 
      {
        pop missed
      } if
    }{
      6 {pop} repeat
    } ifelse
  } {
    7 -2 roll pop pop
  } ifelse
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{LoadIfc}
% \begin{pssyntax}
% \PSvar{IfcNum} \PSstring{CompName} \PSop{LoadIfc} \PSvar{X Y} \PSvar{dX|RY dY|RY}
% \end{pssyntax}
%    \begin{macrocode}
/LoadIfc {
  (LoadIfc) DebugBegin
  cvn load begin
    IfcName load begin
      X Y
      CompMtrx transform CM itransform
      currentdict /RX known { RX RY }{ DX DY } ifelse
      CompMtrx dtransform CM idtransform
    end
  end
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{isFreeray}
%   Check if \PSvar{compname} is a free-ray componente by checking if there is a
%   refractive index associated with it.
%   \begin{pssyntax}
%     \PSstring{compname} \PSop{isFreeray} \PSvar{boolean}
%   \end{pssyntax}
%    \begin{macrocode}
/isFreeray { 
  cvn load /n known 
  dup not {
    (Encountered fiber component in beam path) Warning
  } if
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{PrearrangePlanes}
%   \begin{pssyntax}
%     \PSvar{[} \PSstring{CompN} \PSvar{\ldots} \PSvar{Comp1} \PSop{PrearrangePlanes}\\
%     \PSvar{[} \PSvar{desc|asc} \PSstring{CompN} \PSvar{\ldots} \PSvar{desc|asc} \PSstring{Comp1}
%   \end{pssyntax}
%    \begin{macrocode}
/PrearrangePlanes {
  (PrearrangePlanes) DebugBegin
  counttomark /N ED
  /CompA ED dup /CompB ED
  CompA isFreeray {
    CompA isAmbiguous {
      amb dup CompA
    } {
      CompB isAmbiguous {
        1 CompA GetIfcCenter (C) CompB GetIfcCenter @ABDist
        (N) CompA GetIfcCenter (C) CompB GetIfcCenter @ABDist
      } {
        1 CompA GetIfcCenter 
        1 CompB GetIfcCenter 
        (N) CompB GetIfcCenter 
        true OrderNodes exch pop
        (N) CompA GetIfcCenter 
        1 CompB GetIfcCenter 
        (N) CompB GetIfcCenter 
        true OrderNodes exch pop
      } ifelse
      le { desc } { asc } ifelse dup CompA
    } ifelse
    counttomark 2 roll
  } {
    counttomark 1 sub { pop } repeat
    /N 0 def
  } ifelse
  2 1 N {
    /i ED exch /CompB ED
    CompB isFreeray not {
      counttomark i 1 sub 2 mul 1 add sub { pop } repeat
      exit
    } if
    CompB isAmbiguous not {
      dup desc eq { 1 } { dup amb eq { (C) }{ (N) } ifelse } ifelse 
      CompA GetIfcCenter
      1 CompB GetIfcCenter
      (N) CompB GetIfcCenter false OrderNodes dup dup
%    \end{macrocode}
% check if we have a NodeIfc
%    \begin{macrocode}
      4 -1 roll CompA exch 5 -1 roll CompB exch
      i 2 eq {
%    \end{macrocode}
% check also the first plane
%    \begin{macrocode}
        4 copy 4 2 roll AdjustRelRot
      } if
      AdjustRelRot
    } {
      pop amb dup
    } ifelse
    CompB /CompA CompB def
    counttomark 2 roll
  } for pop
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{AdjustRelRot}
%   Adjusts the relative orientation of \PSstring{CompB} based on the
%   relative connection between \PSstring{CompA} and \PSstring{CompB}.
%   \begin{pssyntax}
%     \PSstring{CompA} \PSvar{desc|asc} \PSstring{CompB} \PSvar{desc|asc} \PSop{AdjustRelRot}
%   \end{pssyntax}
%    \begin{macrocode}
/AdjustRelRot {
  (AdjustRelRot) DebugBegin
  exch dup cvn load /adjustRel known {
    dup dup 4 2 roll isAmbiguous { 
      exch pop (C)
    }{ 
      desc eq { (N) }{ 1 } ifelse 
    } ifelse 
    exch GetIfcCenter 5 3 roll
    exch dup 3 1 roll isAmbiguous { 
      pop (C)
    }{ 
      desc eq { 1 }{ (N) } ifelse 
    } ifelse 
    exch GetIfcCenter
    @ABVect exch atan exch
    cvn load begin
      adjustRel {
        matrix rotate CompMtrx matrix concatmatrix /CompMtrx ED
        /adjustRel false def
      } {
        pop
      } ifelse
    end
  } {
    pop pop pop pop
  } ifelse
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PushAllPlanesOnStack}
%   \begin{pssyntax}
%     \PSvar{[} \PSvar{desc|asc} \PSstring{CompN} \PSvar{\ldots} \PSvar{desc|asc} \PSstring{Comp1} \PSop{PushAllPlanesOnStack}
%     \PSvar{[} \PSproc{PN \PSstring{CompName} n mode draw?} \PSvar{\ldots{}}
%   \end{pssyntax}
%   \begin{psarglist}
%     \psargitem{PN} The number of the plane of the component \PSstring{CompNameN}, can be an integer or a string.
%     \psargitem{CompName} The name of the component which the interface \PSvar{PN} belongs to.
%     \psargitem{n} The refractive index after the respective interface.
%     \psargitem{mode} Specifies if the interface is transmittive (\PSvar{trans}) or reflective (\PSvar{refl}).
%     \psargitem{draw?} Specifies if the connection to this interface should be drawn or if the current point is only moved.
%   \end{psarglist}
%    \begin{macrocode}
/PushAllPlanesOnStack {
  (PushAllPlanesOnStack) DebugBegin
  counttomark 2 div cvi /@N ED
  1 1 @N {
%    \end{macrocode}
% iterate over all components
%    \begin{macrocode}
    /last false def
    /first false def
    dup 1 eq {
      /first true def pop beaminsidefirst
    } {
      @N eq {
        beaminsidelast
        /last true def
      } {
        beaminside
      } ifelse
    } ifelse 
    exch load dup dup /allowbeaminside get 4 -1 roll and 
    /drawinside ED
    /ambiguous get {
      /name get drawinside [ 3 1 roll ]
      counttomark 1 roll pop
    } {
      begin
%    \end{macrocode}
% Start of the component dict.
%    \begin{macrocode}
        desc eq {
          N N -1 1 1
        } {
          1 1 1 N N
        } ifelse
        first startinside not and {
%    \end{macrocode}
% first comp and we do not start inside
%    \begin{macrocode}
          5 -2 roll
          pop pop
          2 copy 5 2 roll
        } if
        5 1 roll
        {
%    \end{macrocode}
% iterate over all planes
%    \begin{macrocode}
          3 1 roll 2 copy 5 -1 roll
          dup 3 1 roll
          eq first not and {
%    \end{macrocode}
% always draw the line to the first plane of a component
%    \begin{macrocode}
            true
          } {
%    \end{macrocode}
% the other beams depend on some options
%    \begin{macrocode}
            drawinside
          } ifelse
          exch dup 4 -1 roll eq {
%    \end{macrocode}
% after the last component plane we have always air
%    \begin{macrocode}
            bgRefIndex
          }{
%    \end{macrocode}
% otherwise the respective refractive index of the component
%    \begin{macrocode}
            name GetRefIndex
          } ifelse
          exch dup N eq {
            pop (N)
          } {
            inttostr
          } ifelse exch
          3 1 roll name
          4 1 roll
          dup IfcName load /mode get
          3 1 roll 5 1 roll
          [ 6 1 roll ] cvx counttomark 1 roll
          last {
            savebeampoints 1 ge stopinside not and
            savebeampoints 1 lt beaminsidelast not and or {
              exit
            } if
          } if
        } for pop pop
      end
    } ifelse
  } for
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{IfcName}
% Construct the interface name from \PSvar{num}. This must be called within a dict of a
% optexpcomp, because the last node ends with (N) instead of the number and we must
% know the number of component interfaces.
% \begin{pssyntax}
% \PSvar{num} \PSop{IfcName} \PSname{P@num}
% \end{pssyntax}
%    \begin{macrocode}
/IfcName {
  dup N eq {
    pop (N)
  } {
    inttostr
  } ifelse
  (P@) exch strcat cvn
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NodeName}
% Construct the plane name from IfcNum. This must be called within a dict of a
% optexpcomp, because the last node ends with (N) instead of the number and we must
% know the plane count of the component.
% \begin{pssyntax}
% \PSstring{name} \PSvar{num} \PSop{NodeName} \PSname{N@namenum}
% \end{pssyntax}
%    \begin{macrocode}
/NodeName {
  dup /stringtype eq not { inttostr } if
  strcat (N@) exch strcat cvn
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{OrderNodes}
%   Check if node (\PSvar{XB1}, \PSvar{YB1}) or (\PSvar{XBN}, \PSvar{YBN}) is nearer to node (\PSvar{XA}, \PSvar{YA}). If it
%   \PSvar{B1} is nearer, push \PSvar{asc} on the stack, otherwise
%   \PSvar{desc}. If \PSvar{calcDist} is \opt{true} it leaves also the actual
%   smallest distance on the stack.
%   \begin{pssyntax}
%     \PSvar{XA YA XB1 YB1 XBN YBN calcDist} \PSop{OrderNodes} \PSvar{desc|asc} \PSvar{distance}
%   \end{pssyntax}
%    \begin{macrocode}
/OrderNodes {
   7 1 roll 6 -2 roll 2 copy 8 2 roll
   @ABDist 5 1 roll @ABDist 2 copy gt {
       pop asc exch
   } {
       exch pop desc exch
   } ifelse
   3 -1 roll not {
       pop
   } if
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{NormalVec}
%   Construct a normal vector $\vec{n}$ to the plane such that its
%   scalar product with the incomping wave vector $\vec{v}_\text{in}$ is
%   negative: $\vec{n}\cdot (-\vec{v}_\text{in}) > 0$.
%   \begin{pssyntax}
%     \PSvar{Xin Yin Xplane Yplane} \PSop{NormalVec} \PSvar{Xnorm Ynorm}
%   \end{pssyntax}
%    \begin{macrocode}
/NormalVec {
  neg exch 2 copy 6 2 roll DotProd 0 gt {
    -1 mul exch -1 mul exch
  } if
  NormalizeVec
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{DotProd}
% Scalar product between two vectors.
% \begin{pssyntax}
%   \PSvar{Xa Ya Xb Yb} \PSop{DotProd} \PSvar{val}
% \end{pssyntax}
%    \begin{macrocode}
/DotProd {
    3 -1 roll mul 3 1 roll mul add
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{VecAngle}
% Angle between two vectors $\cos(\alpha) = \frac{ab}{|a||b|}$
% \begin{pssyntax}
%   \PSvar{Xa Ya Xb Yb} \PSop{VecAngle} \PSvar{angle}
% \end{pssyntax}
%    \begin{macrocode}
/VecAngle {
  4 copy 4 copy DotProd 5 1 roll 
  tx@Dict begin 
    Pyth 3 1 roll Pyth 
  end mul 
  div Acos
  5 2 roll mul 4 1 roll 3 -1 roll mul 3 -1 roll sub 
  0 le { -1 }{ 1 } ifelse mul
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{VecAdd}
% Addition of two vectors.
% \begin{pssyntax}
%   \PSvar{Xa Ya Xb Yb} \PSop{VecAdd} \PSvar{Xa+Xb Ya+Yb}
% \end{pssyntax}
%    \begin{macrocode}
/VecAdd {
    3 -1 roll add 3 1 roll add exch
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{VecScale}
% Scale a vector by a factor \PSvar{fac}.
% \begin{pssyntax}
%   \PSvar{Xa Ya fac} \PSop{VecScale} \PSvar{fac}$\cdot$\PSvar{Xa} \PSvar{fac}$\cdot$\PSvar{Ya}
% \end{pssyntax}
%    \begin{macrocode}
/VecScale {
  dup 4 -1 roll mul 3 1 roll mul
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ToVec}
%   Convert two numbers to a procedure holding the two values. This
%   representation is used to save coordinate values of nodes and vectors.
%   \begin{pssyntax}
%     \PSvar{X Y} \PSop{ToVec} \PSproc{X Y}
%   \end{pssyntax}
%    \begin{macrocode}
/ToVec {
    [ 3 1 roll ] cvx
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{AngToVec}
%   Convert an angle to the related vector representation (normalized). The
%   angle is with respect to the positive $x$-axis.
% \begin{pssyntax}
%   \PSvar{angle} \PSop{AngToVec} \PSproc{X Y}
%   \end{pssyntax}
%    \begin{macrocode}
/AngToVec {
    dup cos exch sin ToVec
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NormalizeVec}
% Normalize a vector ($X'^2 + Y'^2 = 1$)
% \begin{pssyntax}
%   \PSvar{X Y} \PSop{NormalizeVec} \PSvar{X' Y'}
% \end{pssyntax}
%    \begin{macrocode}
/NormalizeVec {
  2 copy
  tx@Dict begin
    Pyth
  end
  dup 3 1 roll div 3 1 roll div exch
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{@ABVect}
% Shorthand definition for \PSvar{ABVect} procedure of the \nxLPack{pst-eucl} package.
% \begin{pssyntax}
%   \PSvar{Xa Ya Xb Yb} \PSop{@ABVect} \PSvar{dX dY}
% \end{pssyntax}
%    \begin{macrocode}
/@ABVect { 
  tx@EcldDict begin ABVect end 
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{@ABDist}
% Shorthand definition for \PSvar{ABDist} procedure of the \nxLPack{pst-eucl} package.
% \begin{pssyntax}
%   \PSvar{Xa Ya Xb Yb} \PSop{@ABDist} \PSvar{dist}
% \end{pssyntax}
%    \begin{macrocode}
/@ABDist { 
  tx@EcldDict begin ABDist end 
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{@InterLines}
%   Shorthand definition for \PSvar{InterLines} procedure of the
%   \nxLPack{pst-eucl} package. Takes care of a bug in the
%   \nxLPack{pst-eucl} package, that too many items are popped off the
%   stack if no intersection point exists.
% \begin{pssyntax}
%   \PSvar{X1 Y1 X2 Y2 X3 Y3 X4 Y4} \PSop{@InterLines} \PSvar{X Y ret}
% \end{pssyntax}
%    \begin{macrocode}
/@InterLines {
  tx@EcldDict begin
    EqDr /D1c exch def /D1b exch def /D1a exch def
    EqDr /D2c exch def /D2b exch def /D2a exch def
    D1a D2b mul D1b D2a mul sub dup 
    ZeroEq { % parallel lines
      pop 0 0 missed 
    }{
      /Det exch def
      D1b D2c mul D1c D2b mul sub Det div
      D1a D2c mul D2a D1c mul sub Det div
      ok
    } ifelse  
  end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{@GetCenter}
%   Shorthand definition for the \PSvar{GetCenter} procedure of the
%   \nxLPack{pst-node} package. Takes either a string or a literal name
%   for the node name \PSvar{name}.
%   \begin{pssyntax}
%     \PSname{name} \PSop{@GetCenter} \PSvar{X Y}
%   \end{pssyntax}
%    \begin{macrocode}
/@GetCenter { 
  tx@NodeDict begin load GetCenter end 
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{@NewNode}
% Shorthand definition for creating a new pnode.
%    \begin{macrocode}
/@NewNode {
  tx@NodeDict begin 
    false exch 10 {InitPnode } NewNode 
  end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{RefractVec}
%   Calculate the refracted vector, the normal plane vector must be
%   constructed with \PSvar{NormVec}, see
%   \url{http://en.wikipedia.org/wiki/Snell%27s_law#Vector_form} for the
%     formulas.
%     \begin{pssyntax}
%       \PSvar{Xin Yin Xnorm Ynorm n1 n2} \PSop{RefractVec} \PSvar{Xout Yout}
%     \end{pssyntax}
%  If it would be total internal reflection, the output vector is (0, 0).
%    \begin{macrocode}
/RefractVec {
  (RefractVec) DebugBegin
  TransformRefIndex exch TransformRefIndex exch div /n ED 
  /Ynorm ED /Xnorm ED
  NormalizeVec /Yin ED /Xin ED 
  n abs 1 eq {
    Xin Yin
  }{
    /costheta1 Xnorm Ynorm Xin neg Yin neg DotProd def
    1 n dup mul 1 costheta1 dup mul sub mul sub
    dup 0 lt {
%    \end{macrocode}
% would be total internal reflection, stop
%    \begin{macrocode}
      pop 0 0
    } {
      sqrt /costheta2 ED
      n Xin mul n Yin mul 
      n costheta1 mul costheta2 sub dup 
      Xnorm mul exch Ynorm mul VecAdd
    } ifelse
  } ifelse
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{ReflectVec}
%   Calculate the reflected vector, the normal plane vector must be
%   constructed with \PSvar{NormVec}.
%   \begin{pssyntax}
%     \PSvar{Xin Yin Xnorm Ynorm} \PSop{ReflectVec} \PSvar{Xout Yout}
%   \end{pssyntax}
%    \begin{macrocode}
/ReflectVec {
  (ReflectVec) DebugBegin
  /Ynorm ED /Xnorm ED NormalizeVec /Yin ED /Xin ED
  /costheta1 Xnorm Ynorm Xin neg Yin neg DotProd def
  Xin Yin 2 costheta1 mul dup Xnorm mul exch Ynorm mul VecAdd
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{CurvedInterface}
%   \begin{pssyntax}
%     \PSvar{Xp Yp Xr Yr} \PSop{CurvedInterface} \PSvar{X0' Y0' Xout Yout status}
%   \end{pssyntax}
%    \begin{macrocode}
/CurvedInterface {
  (CurvedInterface) DebugBegin
  2 copy /Yr ED /Xr ED 
  tx@Dict begin Pyth end /radius ED /Yp ED /Xp ED
  /X0n X0 Xp sub def /Y0n Y0 Yp sub def
  tx@EcldDict begin
    X0n Y0n 2 copy 2 copy Xin 3 -1 roll add Yin 3 -1 roll add
    2 copy 6 2 roll EqDr radius InterLineCircle
  end
  4 copy
  0 eq 3 {exch 0 eq and} repeat {
%    \end{macrocode}
% if all coordinates are zero we missed the circle, stop
%    \begin{macrocode}
    missed
  } {
    4 copy
%    \end{macrocode}
% Chose which of the two intersection points to take.
%    \begin{macrocode}
    Xr neg Yr neg 2 copy
    8 -2 roll @ABDist
    5 1 roll @ABDist
    gt {
%    \end{macrocode}
% «dist from first point» $>$ «dist from second point», take second point.
%    \begin{macrocode}
      4 2 roll
    } if pop pop
    Xp Yp VecAdd
    2 copy Xp Yp 4 2 roll @ABVect exch neg Xin Yin 4 2 roll NormalVec 
    Xin Yin 4 2 roll
%    \end{macrocode}
% on stack: crossing point, in vector, and normal vector
%    \begin{macrocode}
    mode trans eq {
      n1 n2 RefractVec
      2 copy 0 eq exch 0 eq and { tir } { ok } ifelse
    } {
      ReflectVec ok
    } ifelse /n1 n2 def
    5 -2 roll 2 copy 7 2 roll X0 Y0 @ABVect Xin Yin DotProd 0 lt 
    PN 1 gt and {
      pop missed
    } if
  } ifelse
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PlainInterface}
%   \begin{pssyntax}
%     \PSvar{Xp Yp dXp dYp} \PSop{PlainInterface} \PSvar{X0' Y0' Xout Yout status}
%   \end{pssyntax}
%    \begin{macrocode}
/PlainInterface {%
  (PlainInterface) DebugBegin
  /dYp ED /dXp ED /Yp ED /Xp ED
  Xp Yp Xp dXp add Yp dYp add X0 Y0 X0 Xin add Y0 Yin add 
  @InterLines missed eq {
    0 0 missed
  } {
    Xin Yin Xin Yin dXp dYp NormalVec
    mode trans eq {
      n1 n2 RefractVec
      2 copy 0 eq exch 0 eq and { tir } { ok } ifelse
    } {
      ReflectVec ok
    } ifelse /n1 n2 def
    5 -2 roll 2 copy 7 2 roll X0 Y0 @ABVect Xin Yin DotProd 0 lt 
    PN 1 gt and {
      pop missed
    } if
  } ifelse
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% 
% \begin{macro}{TransformRefIndex}
%   If the refractive index on the stack is for the background (has value
%   \opt{bgRefIndex}, which is \opt{0}), we replace it here with its actual
%   value (\opt{1}). This is necessary to distinguish between background index
%   and components having an index of \opt{1}, which can be changed with option
%   \opt{n}.
%   \begin{pssyntax}
%     \PSvar{n} \PSop{TransformRefIndex} \PSvar{n|1}
%   \end{pssyntax}
%    \begin{macrocode}
/TransformRefIndex {
  dup bgRefIndex eq { pop 1 } if
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{GetRefIndex}
% Evaluate the refractive index of component \opt{name}.
% \begin{pssyntax}
%   \PSstring{name} \PSop{GetRefIndex} \PSvar{neval}
% \end{pssyntax}
%    \begin{macrocode}
/GetRefIndex {
  cvn load /n get /nbeam load exch
  EvalRefIndex
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{EvalRefIndex}
%   Evaluate the expression in \opt{nbeam} after setting refractive index to
%   \opt{n}.
%   \begin{pssyntax}
%     \PSproc{nbeam} \PSvar{n} \PSop{GetRefIndex} \PSvar{neval}
%   \end{pssyntax}
%    \begin{macrocode}
/EvalRefIndex {
  dup bgRefIndex eq not {
    1 dict begin 
%    \end{macrocode}
% Store \opt{n} locally for evaluation of the mathematical expression in
% \opt{nbeam}.
%    \begin{macrocode}
      /n ED
      exec
    end
  } if
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{Sellmaier}
%   Calculate the refractive index for BK7 glass with the Sellmaier
%   equation. The wavelength must be given in nanometre. The coefficients are
%   taken from \href{http://en.wikipedia.org/wiki/Sellmeier_equation}.
%   \begin{pssyntax}
%     \PSvar{lambda} \PSop{Sellmaier} \PSvar{n}
%   \end{pssyntax}
%    \begin{macrocode}
/Sellmaier {
  dup mul
  dup dup 1.03961212 mul exch 6000.69867 sub div
  exch dup dup 0.231792344 mul exch 20017.9144 sub div
  exch dup 1.01046945 mul exch 103.560653e6 sub div
  add add 1 add sqrt
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TangentCrosspoint}
% Xp Yp Xt1 Yt1 Xt2 Yt2
%    \begin{macrocode}
/TangentCrosspoint {
    4 copy 4 copy 14 -2 roll 2 copy
    6 2 roll @ABVect neg exch
    6 2 roll @ABVect neg exch
    8 -2 roll VecAdd 10 2 roll VecAdd
    @InterLines pop
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NearestNodeTmp}
% {NodeB} CompA -> shortest distance, planenum
%    \begin{macrocode}
/NearestNodeTmp {
  exch /NodeB ED
  /dist -1 def
  dup cvn load /N get 1 1 3 -1 roll {
    2 copy pop 
    GetIfcCenter 2 copy
    NodeB @ABDist
    dist 0 lt {
      /dist ED
      ToVec /node ED
    } {
      dup dist lt {
        /dist ED
        ToVec /node ED
      } {
        pop pop pop
      } ifelse
    } ifelse
  } for
  pop dist /node load
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NearestNode}
% CompA/NodeA CombB/NodeB -> Coordinates of nodeA or the node of CompA which is nearest to nodeB
%    \begin{macrocode}
/NearestNode {
  (NearestNode) DebugBegin
  dup xcheck not { nametostr } if /CompB ED
  dup xcheck not {
%    \end{macrocode}
% CompA is a component
%    \begin{macrocode}
    nametostr /CompA ED
    /CompB load dup xcheck not {
%    \end{macrocode}
% CompB is a component
%    \begin{macrocode}
      /mindist -1 def
      [ exch false GetInternalNodeNames ] 
      { @GetCenter ToVec
        CompA NearestNodeTmp 
        exch dup mindist ge mindist 0 ge and { 
          pop pop 
        }{ 
          /mindist ED /minnodeA ED 
        } ifelse
      } forall
      minnodeA
    } {
      CompA NearestNodeTmp exch pop exec
    } ifelse
  } {
%    \end{macrocode}
% else, it is a node and we already have the appropriate coordinates on the
% stack
%    \begin{macrocode}
    exec
  } ifelse
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{RelFiberAngle}
% Calculate start angle of \cs{nccurve} from CompA to CompB
%
% \begin{pssyntax}
%   \PSvar{Xb Yb Xa Ya A B} \PSvar{fiberalign} \PSop{RelFiberAngle} \PSvar{angle}
% \end{pssyntax}
%    \begin{macrocode}
/RelFiberAngle {
  (RelFiberAngle) DebugBegin
  /fiberalign ED
  dup xcheck not { nametostr } if /CompB ED
  dup xcheck not { nametostr } if /CompA ED
  /CompA load xcheck {
    /CompB load xcheck {
%    \end{macrocode}
%  both parameters are nodes, so the angle is that of the direct connection line.
%    \begin{macrocode}
      @ABVect exch atan
    } {
%    \end{macrocode}
% B is a component, and A is a node: the angle at node A is calculated through component B
%    \begin{macrocode}
      4 copy @ABVect 6 2 roll pop pop 2 copy
%    \end{macrocode}
% on stack: Xb-Xa Yb-Ya Xb Yb Xb Yb
%    \begin{macrocode}
      CompB (Center) NodeName @GetCenter 
%    \end{macrocode}
% on stack: Xb-Xa Yb-Ya Xb Yb Xb Yb Xbc Ybc
%    \begin{macrocode}
      4 2 roll @ABVect 4 2 roll
      CompB 
      fiberalign center eq {
        RelFiberAngle@center
      }{
        RelFiberAngle@ref
      } ifelse
      2 copy exch atan
      7 3 roll 2 copy 9 -2 roll
      DotProd 0 gt 5 1 roll DotProd 0 gt xor { 180 add } if
    } ifelse
  } {
%    \end{macrocode}
% A is a component, B is insignificant
%
% discard coordinates of B
%    \begin{macrocode}
    4 2 roll pop pop 2 copy
    CompA (Center) NodeName @GetCenter
    4 2 roll @ABVect 4 2 roll
%    \end{macrocode}
% on stack: Xac-Xa Yac-Xa Xa Ya
%    \begin{macrocode}
    CompA fiberalign center eq {
      RelFiberAngle@center
    }{
      RelFiberAngle@tref
    } ifelse
    2 copy exch atan
%    \end{macrocode}
% Xac-Xa Yac-Ya XaB-XaA YaB-YaA angleTrefline
%    \begin{macrocode}
    5 1 roll DotProd 0 gt { 180 add } if
  } ifelse
  DebugEnd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{/RelFiberAngle@ref}
% \begin{pssyntax}
%   \PSvar{Xa Ya CompA} \PSop{RelFiberAngle@ref} \PSvar{dX dY}
% \end{pssyntax}
%    \begin{macrocode}
/RelFiberAngle@ref {
  3 1 roll pop pop
  dup (A) NodeName exch (B) NodeName
  @GetCenter 3 -1 roll @GetCenter @ABVect 
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{/RelFiberAngle@tref}
% Same as \PSname{RelFiberAngle@ref} but uses the transformed reference nodes.
% \begin{pssyntax}
%   \PSvar{Xa Ya CompA} \PSop{RelFiberAngle@ref} \PSvar{dX dY}
% \end{pssyntax}
%    \begin{macrocode}
/RelFiberAngle@tref {
  3 1 roll pop pop
  dup (TrefA) NodeName exch (TrefB) NodeName
  @GetCenter 3 -1 roll @GetCenter @ABVect 
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{/RelFiberAngle@center}
%    \begin{macrocode}
/RelFiberAngle@center {
  (Center) NodeName @GetCenter 4 2 roll @ABVect
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{getsubnode}
% subname node/name  -> coordinates
%    \begin{macrocode}
/getsubnode {
  dup xcheck {
    exch pop exec
  } {
    nametostr exch nametostr NodeName
    @GetCenter
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{connectInterfaces}
%   \begin{pssyntax}
%     \PSproc{vec}
%   \end{pssyntax}
% InVec Center CenterTmp PrevMode relangle
%    \begin{macrocode}
/connectInterfaces {
  /relAngleTmp ED
  PN 2 eq {
%    \end{macrocode}
% initialize relAngle, the angle between plane connection and input vector
%    \begin{macrocode}
    pop @ABVect NormalizeVec 4 2 roll VecAngle /relAngleTmp ED
  } if
  PN 3 ge {
    trans eq {
%    \end{macrocode}
% previous plane was transmittive, recalculate the input vector
%    \begin{macrocode}
      @ABVect NormalizeVec 4 2 roll pop pop % remove Vec from stack
      relAngleTmp matrix rotate dtransform
      4 2 roll pop pop
    } {
%    \end{macrocode}
% else, the previous plane was reflective, recalculate relAngle
%    \begin{macrocode}
      @ABVect NormalizeVec 4 2 roll VecAngle /relAngleTmp ED
    } ifelse
  } if
  relAngleTmp
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{GetCompRange}
% \PSstring{basename} \PSvar{start stop} 
% \PSop{GetCompRange} \PSstring{basenamestart} \ldots\ \PSstring{basenamestop}
%    \begin{macrocode}
/GetCompRange {
  2 copy gt { 1 }{ -1 } ifelse 3 -1 roll
  { exch dup 3 -1 roll inttostr strcat exch} for
  pop
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{CorrectDipoleNodes}
%   For a dipole which has two interface nodes (1) and (N) which are
%   very close together ($\text{dist} < 10^{-7}$) or which coincide, the
%   automatic angle estimation of the fiber connections does not work
%   properly. So these nodes are separated as less as possible so that
%   the NearestNode procedure estimates two different distances.
%   \begin{pssyntax}
%     \PSstring{node1} \PSstring{node2} \PSstring{basename} \PSop{CorrectDipoleNodes}
%   \end{pssyntax}
%    \begin{macrocode}
/CorrectDipoleNodes {
  dup dup dup
  6 -1 roll NodeName exch 5 -1 roll NodeName 2 copy 6 2 roll
  gsave
    tx@Dict begin 
      STV CP T
      exch @GetCenter 3 -1 roll @GetCenter
    end
  grestore
  4 copy @ABDist 1e-7 lt {
%    \end{macrocode}
% The two nodes are closer together than $10^{-7}$, correct that to avoid
% problems with the angle direction when drawing fibers.
%    \begin{macrocode}
    6 -1 roll
    gsave
      tx@Dict begin 
        STV CP T
        (TrefA) NodeName @GetCenter 7 -1 roll 
        (TrefB) NodeName @GetCenter 
      end
    grestore
    @ABVect NormalizeVec 2 copy
%    \end{macrocode}
% The floating-point precision of the Postscript interpreter is
% approximately 8 digits, so in order to have an effect, the nodes must
% be separated by $10^{-7}$ times the maximum coordinate value.
%    \begin{macrocode}
    8 -2 roll 2 copy abs exch abs max 2e-7 mul 3 1 roll 5 2 roll 
    VecScale VecAdd ToVec 7 -1 roll @NewNode
    4 2 roll 2 copy abs exch abs max -2e-7 mul 3 1 roll 5 2 roll 
    VecScale VecAdd ToVec exch @NewNode
  } {
    8 { pop } repeat
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{debug}
%   Print out the last \opt{N} elements from the stack, checks for
%   stackunderflow. I \opt{N} is negative, the complete stack is
%   printed. Compared to the \PSvar{stack} operand, it prints the content of
%   procedures and array, which we use a lot.
%   \begin{pssyntax}
%     \PSvar{N} \PSop{debug}
%   \end{pssyntax}
%    \begin{macrocode}
/debug { 
  /@N ED count dup @N gt @N 0 ge and { pop @N } if 
  copy @N { == } repeat
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{debugComp}
% Print out all parameters and planes of the component \opt{compname}.
%   \begin{pssyntax}
%     \PSstring{compname} \PSop{debugComp}
%   \end{pssyntax}
%    \begin{macrocode}
/debugComp { 
  dup (debug comp ") exch strcat ("===============) strcat ==
  cvn load { 
    dup type /dicttype eq {
      (plane----------------) == 
      { == == } forall
      (-----------done) ==
      } { == } ifelse
      ==
  } forall
  (================== done) ==
} bind def
%    \end{macrocode}
% \end{macro}

%
%    \begin{macrocode}
end % tx@OptexpDict
%    \end{macrocode}
%</prolog> 
% \Finale
% \endinput
%
%<*indexstyle>
headings_flag       1
heading_prefix   "\\textbf{"
heading_suffix   "}\n"
quote		'"'
level		'!'
actual          '='
preamble
  "\\begin{theindex}\n"
item_1
  "\\par\\leavevmode\\hangindent10pt\\makebox[15pt][l]{ -- }"
item_01
  "\\par\\leavevmode\\hangindent10pt\\makebox[15pt][l]{ -- }"
item_x1
  "\\par\\leavevmode\\hangindent10pt\\makebox[15pt][l]{ -- }"
item_2
  "\\par\\leavevmode\\hangindent20pt\\makebox[30pt][l]{ -- -- }"
item_12
  "\\par\\leavevmode\\hangindent20pt\\makebox[30pt][l]{ -- -- }"
item_x2
  "\\par\\leavevmode\\hangindent20pt\\makebox[30pt][l]{ -- -- }"
%</indexstyle>
