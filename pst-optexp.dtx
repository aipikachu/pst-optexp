% \iffalse meta-comment
%
% Copyright (C) 2011 by Christoph Bersch <usenet@bersch.net>
% -------------------------------------------------------
% 
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.2
% of this license or (at your option) any later version.
% The latest version of this license is in:
%
%    http://www.latex-project.org/lppl.txt
%
% and version 1.2 or later is part of all distributions of LaTeX 
% version 1999/12/01 or later.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{pst-optexp.dtx}
%</driver>
%<stylefile>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<stylefile>\ProvidesPackage{pst-optexp}
%<*stylefile>
    [2011/07/21 v3.0alpha Optical experimental setups with PSTricks]
%</stylefile>
%
%<*driver>
\documentclass[toc=flat, a4paper, DIV=9]{scrartcl} 
\usepackage{doc}
\setcounter{IndexColumns}{2} 
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} 
\usepackage{lmodern} 
\usepackage{amsfonts}
\usepackage{bera} 
\providecommand*\mainlang{}
\usepackage[english,\mainlang]{babel}
\usepackage[dvipsnames,x11names,svgnames]{xcolor} 
\usepackage{amsmath} 
\usepackage{ragged2e}
\usepackage{paralist}
\usepackage{nicefrac}
\usepackage{prettyref} 
\newrefformat{sec}{Sec.~\ref{#1}} 
\usepackage{pst-func} 
\usepackage{pst-tree}
\newcommand{\poeTR}[1]{\TR{\ttfamily\color{DOrange}#1}}
\usepackage{pst-optexp} 
\usepackage{pst-circ}
\usepackage[makeindex]{splitidx} 
\newindex[Code Index]{idx}
\newindex[Documentation Index]{doc}
\usepackage{etoolbox}
\usepackage{hypdoc}
\hypersetup{colorlinks=true,
            urlcolor=pdfurlcolor, 
            filecolor=pdffilecolor, 
            linkcolor=pdflinkcolor,
            breaklinks, 
            linktocpage=true}
\usepackage{breakurl}
\definecolor{DOrange}{rgb}{0.9,.36,.18}
\colorlet{pdflinkcolor}{DOrange}
\colorlet{pdfurlcolor}{DOrange}
\colorlet{pdffilecolor}{DOrange}
\usepackage{showexpl}
\makeatletter\renewcommand*\SX@Info{}\makeatother 
\definecolor{colKeys}{rgb}{0,0,0}
\definecolor{colIdentifier}{rgb}{0,0,0}
\colorlet{colComments}{DOrange!50!white}
\definecolor{colString}{rgb}{0,0.5,0} 
\lstset{%
  language=[LaTeX]TeX, 
  identifierstyle=\color{colIdentifier}, %
  keywordstyle=\color{colKeys}, %
  stringstyle=\color{colString}, %
  commentstyle=\color{colComments}, %
  float=hbp,%
  basicstyle=\ttfamily\small, %
  columns=flexible, %
  tabsize=4, %
  frame=single, %
  extendedchars=true, %
  showspaces=false, %
  showstringspaces=false, %
  breaklines=true, %
  breakautoindent=true, captionpos=b, xleftmargin=1em,
  rulecolor=\color{black!20}, 
  texcsstyle = [20]\color{DOrange},
  moretexcs = [20]{lens, optbox, oenode, oenodeIn, oenodeExt, oenodeOut,
    oenodeRefA, oenodeRefB, oenodeTrefA, oenodeTrefB, optplate,
    optretplate, pinhole, crystal,optdetector, optdiode, doveprism,
    polarization, mirror, beamsplitter, optgrating, optprism,
    rightangleprism, pentaprism, optdipole, optripole, optfiber, optamp,
    optmzm, optfilter, polcontrol, optisolator, optswitch,
    fiberdelayline, optfiberpolarizer, fibercollimator, optcoupler,
    wdmcoupler, wdmsplitter, drawbeam, drawwidebeam, drawfiber,
    custombeam, frontlayer, backlayer, newOptexpDipole,
    newOptexpTripole, newOptexpFiberDipole},
  explpreset={%
    escapeinside={*}{*}, 
    pos=l,width=-99pt,overhang=0pt,hsep=5mm,
    varwidth,vsep=\bigskipamount,rframe={}}, }
\colorlet{sectioncolor}{DOrange}
\addtokomafont{sectioning}{\color{sectioncolor}}
\addtokomafont{subsection}{\Large}
\addtokomafont{subsubsection}{\Large}
\usepackage[automark,nouppercase]{scrpage2} 
\pagestyle{scrheadings}
\clearscrheadings
\clearscrplain 
\ohead{\pagemark} 
\ihead{\headmark}
\ofoot[\pagemark]{}
\automark[subsection]{section}
\setheadsepline{.4pt}[\color{DOrange}]
\setheadwidth[0pt]{text}
\setfootwidth[0pt]{text}
\undef{\cs} 
\undef{\cmd}
\usepackage{ltxdockit}
\usepackage{csquotes}
\MakeAutoQuote{«}{»}
\colorlet{spot}{sectioncolor}
\renewcommand*{\verbatimfont}{\ttfamily}
\renewcommand*{\displayverbfont}{\ttfamily}
\renewcommand*{\marglistfont}{\spotcolor\sffamily\small}
\renewcommand*{\margnotefont}{\sffamily\small}
\renewcommand*{\optionlistfont}{\spotcolor\sffamily\displayverbfont}
\renewcommand*{\ltxsyntaxfont}{\ttfamily}
\renewcommand*{\ltxsyntaxlabelfont}{\spotcolor\displayverbfont}

\makeatletter
%% and idea from GL to provide links inside the listings to the pst-optexp commands: 
%% <https://groups.google.com/groups/search?as_umsgid=4d89ee49%240%2418590%24426a74cc%40news.free.fr>
\providerobustcmd*\ifrefundefined [1]{%
  \begingroup%
    \csname @safe@activestrue\endcsname%
    \expandafter\endgroup\csname @\ifcsname r@#1\endcsname second\else first\fi oftwo\endcsname
}% \ifrefundefined
\def\lsthk@OutputBox@H@@k{%
    \begingroup%
      \let\lst@UM\@empty%
      \edef\@tempc{cmd:\detokenize\expandafter{\the\lst@token }}%\edef
      \ifrefundefined{\@tempc}%
    \endgroup%
    \sethyperlistings%
}% \lsthk@OutputBox@H@@k
\def\sethyperlistings {\global\let \hyperlistingsreference =\@tempc
     \endgroup \aftergroup \dohyperlistings }% after \hbox
\def\dohyperlistings {\def\lst@alloverstyle ##1{\hyperlistings ##1}}
\def\hyperlistings{%
    \setbox\@tempboxa\hbox%
    \bgroup%
      \rlap{\hypersetup {linkcolor=.}\relax\fboxrule\z@%
      \hyperref[\hyperlistingsreference]{\boxframe{\wd\@tempboxa}{\ht\@tempboxa}{\dp\@tempboxa}}}%
      \unhbox\@tempboxa%
    \egroup%
}% \hyperlistings
\let\lsthk@OutputBox\lsthk@OutputBox@H@@k
\makeatother
\DeclareRobustCommand\lsb{{\normalfont\ttfamily[}}
\makeatletter
\def\ltd@optionlist{%
  \let\optitem\POE@optitem
  \let\styleitem\POE@styleitem
  \let\valitem\POE@valitem
  \let\choitem\POE@choitem
  \let\boolitem\POE@boolitem
  \let\intitem\POE@intitem
  \let\numitem\POE@numitem
  \let\poeitem\ltd@item}

\newcommand*{\POE@optitem}[3][]{%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{#3}{}}
    {\ltd@option{#2}{#2}{#3}{\ltd@textverb{#1}}}}%

\newcommand*{\POE@styleitem}[2][]{%
  \xLstyle{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{psstyle}}{}}
    {\ltd@option{#2}{#2}{\prm{psstyle}}{\ltd@textverb{#1}}}}%

\newcommand*{\POE@valitem}[3][]{%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{#3}}{}}
    {\ltd@option{#2}{#2}{\prm{#3}}{\ltd@textverb{#1}}}}%

\newcommand*{\POE@choitem}[3][]{%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\ltd@verblist{#3}}{}}
    {\ltd@option{#2}{#2}{\ltd@verblist{#3}}{\ltd@textverb{#1}}}}%

\newcommand*{\POE@boolitem}[2][]{%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\ltd@verblist{true,false}}{}}
    {\ltd@option{#2}{#2}{\ltd@verblist{true,false}}{\ltd@textverb{#1}}}}%

\newcommand*{\POE@intitem}[2][]{%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{integer}}{}}
    {\ltd@option{#2}{#2}{\prm{integer}}{\ltd@textverb{#1}}}}%
\newcommand*{\POE@numitem}[2][]{%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{num}}{}}
    {\ltd@option{#2}{#2}{\prm{num}}{\ltd@textverb{#1}}}}%

\let\plainllap\llap
\newrobustcmd\macro@llap[1]{{\global\let\llap\plainllap
 \setbox0=\hbox\bgroup \macro@font\saved@macroname\egroup
 \ifdim\wd0>30mm
    \hbox to\z@ \bgroup\hss \hbox to30mm{\unhcopy0\hss}\egroup
    \edef\@tempa{\hskip\dimexpr\the\wd0-30mm}\global\everypar\expandafter{\the\expandafter\everypar
                                                                           \@tempa \global\everypar{}}%
 \else \llap{\unhbox0}\fi}}
 \AtBeginEnvironment{macro}{\let\llap\macro@llap}
\makeatother

\newcommand*{\PSstring}[1]{{\normalfont\ttfamily(#1)}}
\newcommand*{\PSname}[1]{{\normalfont\ttfamily/#1}}
\newcommand*{\PSproc}[1]{{\normalfont\ttfamily\textbraceleft #1\textbraceright}}
\newcommand*{\PSvar}[1]{{\normalfont\ttfamily #1}}

\newcommand*{\nodename}[1]{\emph{#1}}
\newcommand*{\param}[1]{\normalfont\texttt{#1}}
\newcommand*{\paramvalue}[1]{\texttt{#1}}
\newcommand*{\styleshape}[1]{\texttt{#1}}
\newcommand{\docindex}[1]{\sindex[doc]{#1|hyperpage}}
\def\xLcs#1{\docindex{#1=\nxLcs{#1}}\docindex{Macro!#1=\nxLcs{#1}}}
\def\Lcs#1{\nxLcs{#1}\xLcs{#1}}
\def\nxLcs#1{\texttt{\textbackslash#1}}

\def\LPack#1{\texttt{#1}\docindex{#1=\texttt{#1}}\docindex{Package!#1=\texttt{#1}}}
\def\nxLPack#1{\texttt{#1}}

\def\Lkeyword#1{\texttt{#1}\xLkeyword{#1}}
\def\xLkeyword#1{\docindex{#1=\texttt{#1}}\docindex{Keyword!#1=\texttt{#1}}}
\def\nxLkeyword#1{\texttt{#1}}

\def\xLoption#1{\docindex{#1=\texttt{#1}}\docindex{Package option!#1=\texttt{#1}}}
\def\Loption#1{\texttt{#1}\xLoption{#1}}

\def\Lstyle#1{\texttt{#1}\xLstyle{#1}}
\def\xLstyle#1{\docindex{#1=\texttt{#1}}\docindex{Style!#1=\texttt{#1}}}
\def\nxLstyle#1{\texttt{#1}}

\def\Ldipole#1{\nxLcs{#1}\xLdipole{#1}}
\def\xLdipole#1{\docindex{#1=\nxLcs{#1}}\docindex{Dipoles!#1=\nxLcs{#1}}}

\def\Ltripole#1{\nxLcs{#1}\xLtripole{#1}}
\def\xLtripole#1{\docindex{#1=\nxLcs{#1}}\docindex{Tripoles!#1=\nxLcs{#1}}}

\def\Lfdipole#1{\nxLcs{#1}\xLfdipole{#1}}
\def\xLfdipole#1{\docindex{#1=\nxLcs{#1}}\docindex{Fiber dipoles!#1=\nxLcs{#1}}}

\def\Lfmultipole#1{\nxLcs{#1}\xLfmultipole{#1}}
\def\xLfmultipole#1{\docindex{#1=\nxLcs{#1}}\docindex{Fiber multipoles!#1=\nxLcs{#1}}}

\newcommand{\dipoledesc}[1]{%
  \xLdipole{#1}\label{cmd:#1}\cmditem{#1}[Options](In)(Out)%
  \xLdipole{#1}\cmditem{#1}[Options](In)(Out){Label}%
}
\newcommand{\tripoledesc}[1]{%
  \xLtripole{#1}\cmditem{#1}[Options](In)(Center)(Out){Label}
}

\newcommand{\fiberdipoledesc}[1]{%
  \xLfdipole{#1}\cmditem{#1}[Options](In)(Out){Label}
}

\newcommand{\refstringexplanation}[0]{%
  A \paramvalue{<ref string>} is any combination of \paramvalue{c}
  (center), \paramvalue{t} (top), \paramvalue{b} (bottom), \paramvalue{l}
  (left), \paramvalue{r} (right)}

\addtopsstyle{Fiber}{linecolor=DOrange,linewidth=1.5\pslinewidth}
\addtopsstyle{Beam}{linewidth=1.5\pslinewidth}
\EnableCrossrefs
\CodelineIndex
\begin{document}
  \DocInput{pst-optexp.dtx}
  \begin{otherlanguage}{english}
    \printindex[idx]
  \end{otherlanguage}
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
%
% \GetFileInfo{pst-optexp.dtx}
%
% \DoNotIndex{\@,\g@addto@macro,\newif,\gdef,\xdef,\newcounter,\or,\ifcase}
% \DoNotIndex{\newcommand,\newenvironment,\def,\edef,\let,\if,\ifx,\else,\fi,\@ifnextchar}
% \DoNotIndex{\space,\relax,\nr,\ignorespaces,\ifdim,\ifcat,\@nil,\@none,\@empty}
% \DoNotIndex{\PackageError,\PackageWarning,\advance,\csname,\endcsname,\bgroup,\egroup}
% \DoNotIndex{\expandafter,\@nameuse}
% \DoNotIndex{\psset}
% \DoNotIndex{\@wd,\@sz,\@ht,\@yshift,\@step,\@xl,\@sep,\@r,\@dp,\@altan}
% \DoNotIndex{\@f@cnt,\@f@r,\@f@sep,\@hshift,\@bs@wd,\@c@caxisL,\@cnt}
% 
% \newif\ifGERMAN  \GERMANfalse
% \newif\ifENGLISH \ENGLISHfalse
% \iflanguage{ngerman}{\GERMANtrue}{%
%   \iflanguage{german}{\GERMANtrue}{\GERMANfalse}}
% \iflanguage{english}{\ENGLISHtrue}{\ENGLISHfalse}
%
% \newcommand*{\sizeexplanation}[1][1.6]{% 
%   \ifGERMAN 
%     Die Höhe der Komponente, die Breite ist \opt{#1} mal die Höhe. Mit
%     dem \opt{xunit} oder \opt{yunit} Parameter kann dieses Verhältnis
%     geändert werden.
%   \fi
%   \ifENGLISH
%     The height of the delay line, the width is \opt{#1} times the
%     height. Use the \opt{xunit} or \opt{yunit} parameter to change this
%     relation.
%   \fi
% }%
%
% \makeatletter
% \renewcommand\maketitle{%
% \thispagestyle{empty}%
% \begin{titlepage}
% \begin{pspicture}(1.6in,0.685in)(10,21.7)
%   \psframe[fillstyle=solid,linecolor=lightgray,fillcolor=lightgray,linestyle=solid](0,-5.75)(21.5,10)
%   \psframe[fillstyle=solid,linecolor=Orange!85!Red,fillcolor=Orange!85!Red,linestyle=solid](0,10)(21.5,10.5)
%   \psframe[fillstyle=solid,linecolor=Orange!85!Red,fillcolor=Orange!85!Red,linestyle=solid](0,21.1)(21.5,21.2)
%   \rput[lb](3,22){\Huge\sffamily\color{Orange!65!Red}\psscalebox{2}{\textbf{PSTricks}}}
%   \rput[lb](3,14.1){\parbox{15cm}{\sffamily\RaggedRight\bfseries\huge\@title}}
%   \rput[lb](3,7.6){\parbox{13cm}{\sffamily\@date}}
%   \rput[lb](3,-2.6){\parbox[b]{17cm}{\sffamily\RaggedRight 
%     ~\hfill\makebox[7cm][l]{\ifGERMAN Paketautor:\fi\ifENGLISH Package author:\fi}\\
%     ~\hfill\makebox[7cm][l]{%
%       \bfseries\tabular[t]{@{}l@{}}\@author\endtabular}}}
%  \rput[C](11,4){\bgImage}%
% \end{pspicture}%
% \end{titlepage}}
% \makeatother
% 
% \ifGERMAN
%   \title{\texttt{pst-optexp}\\ Optische Versuchsaufbauten\\[0.5ex] \small \fileversion}
% \fi
% \ifENGLISH
%   \title{\texttt{pst-optexp}\\ Drawing optical experimental setups\\[0.5ex] \small \fileversion}
% \fi
% \author{Christoph Bersch}
% \date{\filedate}
% \def\bgImage{\psset{unit=1.3}
%\begin{pspicture}[showgrid=false](-0.2,0.1)(8.2,5.3)
%   \pnode(0,3){M1}
%   \pnode(8,3){M2}
%   \pnode(8,0.5){In}
%   \pnode(6.5,0.5){Min}
%   \pnode(6.5,3){Pin}
%   \pnode(4.5,3){Min2}
%   \pnode(1.5, 0.5){Mout}
%   \pnode(1.5,3){Pout}
%   \pnode(3.5,3){Mout2}
%   \pnode(0,0.5){Out}
%   \definecolor[ps]{bl}{rgb}{tx@addDict begin Red Green Blue end}%
%   \addtopsstyle{Beam}{linecolor=bl, linejoin=1}
%   \psset{mirrortype=extended, mirrordepth=0.15}
%   \newpsstyle{ExtendedMirror}{linestyle=none, hatchwidth=0.5\pslinewidth, hatchsep=1.2\pslinewidth,%
%                 fillstyle=hlines}%
%   \begin{optexp}
%   \mirror[mirrorwidth=4, mirrorradius=10.4](M2)(M1)(M2){}
%   \mirror[mirrorwidth=4, mirrorradius=10.4](M1)(M2)(M1){}
%   \mirror(In)(Min)(Pin){}
%   \optprism[n=1.85, addtoOptComp={linewidth=1.5\pslinewidth}](Min)(Pin)(Min2){}
%   \mirror[compshift=0.4](Pin)(Min2)(Pin){}
%   \mirror[compshift=-0.4](Pout)(Mout2)(Pout){}
%   \optprism[n=1.85, compshift=0.15, linewidth=1.5\pslinewidth](Mout2)(Pout)(Mout){}
%   \mirror(Pout)(Mout)(Out){}
%  \multido{\i=0+1}{40}{^^A
%    \pstVerb{^^A
%       \i\space 650 400 sub 39 div mul 400 add 
%       tx@addDict begin wavelengthToRGB end }%
%     \drawbeam[nadd=-0.002 \i\space mul]{(In)}{3}{4}{5}{2}{1}{6}{7}{8}{(Out)}
%  }^^A
%   \newpsstyle{Beam}{linecolor=red}
%   \backlayer{%
%     \psline[style=Beam,ArrowInside=->, linewidth=2\pslinewidth, arrowinset=0](In)(\oenodeIn{3})(\oenodeOut{4})
%   }
%   \drawbeam[beamangle=0.29,startpos=0.1, arrows=<-, linewidth=2\pslinewidth, arrowinset=0]{([Xnodesep=-0.2]Out)}{8}{7}
% \end{optexp}
% \rput(4,4.5){%
%   \psframe[fillstyle=solid,fillcolor=gray!70](-0.1, -0.6)(0.1, 0.7)
%   \multido{\r=-0.5+0.1}{12}{%
%     \psline[linewidth=0.5\pslinewidth](-0.1,\r)(0.1,\r)
%   }%
% }%
% \end{pspicture}}
%
% \maketitle
% 
% \clearpage
% \tableofcontents
% \clearpage
% 
% \ifGERMAN
%   \section{Einführung}
%   Das Paket \LPack{pst-optexp} ist eine Sammlung optischer Komponenten zum Zeichnen optischer Versuchsaufbauten.
% \fi
% \ifENGLISH
%   \section{Introduction}
%   The package \LPack{pst-optexp} is a collection of optical components
%   that facilitate easy sketching of optical experimental
%   setups. Mechanisms for proper alignment of different components are
%   provided internally. This way the user does not have to care for proper
%   orientation of the elements. Macros for convenient definition of new 
%   user-defined components are also provided.
% \fi
%
% \ifGERMAN
%   \section{Paketgrundlagen}
% \fi
% \ifENGLISH
%   \section{Basics for the package}
% \fi
% 
% \ifGERMAN
%   \subsection{Anforderungen}
% \LPack{pst-optexp} Version 3.0 benötigt aktuelle Versionen der Pakete \LPack{pst-node}, \LPack{pstricks-add}, \LPack{multido},
% \LPack{pst-eucl} und \LPack{environ}. 
%
% Alle PSTricks-Pakete machen regen Gebrauch von Postscript, so dass der
% typische Arbeitsfluss \cmd{latex}, \cmd{dvips} und ggf. \cmd{ps2pdf}
% umfasst. Alternative Methoden sind auf
% \url{http://tug.org/PSTricks/main.cgi?file=pdf/pdfoutput} beschrieben.
% \fi 
% \ifENGLISH
%   \subsection{Requirements}
%   \LPack{pst-optexp} version 3.0 requires recent versions of
%   \LPack{pst-node}, \LPack{pstricks-add}, \LPack{multido},
%   \LPack{pst-eucl}, and \LPack{environ}. 
%
%   All PSTricks package heavily rely on the Postscript language so that
%   the typical workflow involves \cmd{latex}, \cmd{dvips}, and
%   \cmd{ps2pdf}. Of course there are several alternative ways, see
%   \url{http://tug.org/PSTricks/main.cgi?file=pdf/pdfoutput} for details.
% \fi
%
% \ifGERMAN
%   \subsection{Verbreitung und Installation}
%   Dieses Paket ist auf CTAN
%   (\url{http://mirror.ctan.org/graphics/pstricks/contrib/pst-optexp})
%   erhältlich und in \TeX Live and MiK\TeX{} enthalten.
% 
%   Das \LPack{pst-optexp} Paket umfasst die zwei Hauptdateien
%   \texttt{pst-optexp.ins} und \texttt{pst-optexp.dtx}. Durch Aufrufen
%   von \texttt{latex pst-optexp.ins} werden die beiden folgenden
%   Dateien erzeugt:
%   \begin{compactitem}
%   \item \texttt{pst-optexp.pro}: die Postscript Prologdatei
%   \item \texttt{pst-optexp.sty}: die \LaTeX{} Stildatei
%   \end{compactitem}
%   Speichern Sie diese Dateien in einem Verzeichnis der Teil Ihres
%   lokalen \TeX-Baums ist.
% 
%   Vergessen Sie nicht \texttt{texhash} aufzurufen um den Baum zu
%   aktualisieren. MiK\TeX{}-Benutzer müssen die Dateinamen-Datenbank
%   (FNDB) aktualisieren.
% 
%   Detailliertere Information finden Sie in der Dokumentation Ihrer
%   \LaTeX-Distribution über die Installation in den lokalen
%   \TeX{}-Baum.
% \fi
% \ifENGLISH
%   \subsection{Distribution and installation}
%   This package is available on CTAN
%   (\url{http://mirror.ctan.org/graphics/pstricks/contrib/pst-optexp})
%   and is included in \TeX Live and MiK\TeX.
% 
%   The \LPack{pst-optexp} package consists of the two main files \texttt{pst-optexp.ins} and \texttt{pst-optexp.dtx}. 
%   \begin{compactitem}
%   \item \texttt{pst-optexp.pro}: the Postscript prolog file
%   \item \texttt{pst-optexp.sty}: the \LaTeX{} style file
%   \end{compactitem}
%   Save the files in a directory which is part of your local \TeX{} tree.
% 
%   Do not forget to run \texttt{texhash} to update this tree. For MiK\TeX{}
%   users, do not forget to update the file name database (FNDB).
% 
%   For more detailed information see the documentation of your personal
%   \LaTeX{} distribution on installing packages to your local \TeX{}
%   system.
% \fi
%
% \ifGERMAN
%   \section{Erste Schritte}
% \fi
% \ifENGLISH
%   \section{Getting started}
% \fi
% \label{sec:quick}
% \ifGERMAN
% In diesem einführenden Abschnitt soll anhand von ein paar Beispielen der
% typische Entwicklungsprozess sowie einige der besonderen Stärken des
% \LPack{pst-optexp} Paketes demonstriert werden.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, vsep=5mm, numbers=left, numberstyle=\footnotesize]
\begin{pspicture}[showgrid=true](5,1.8)
  \pnode(0,1){In}\pnode(3.5,1){Out}
  \newpsstyle{Beam}{linecolor=green, fillstyle=solid, fillcolor=green, opacity=0.2}
  \lens[lensradius=-0.7, lenswidth=0.1, abspos=1](In)(Out){concave}
  \lens[lensradius=2.3, lensheight=1.3, abspos=2.6](In)(Out){convex}
  \optbox[endbox, labeloffset=0](In)(Out){CCD}
  \drawwidebeam[beamwidth=0.2]{(In)}{1}{2}{3}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{document}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[hsep=10mm, numbers=left, numberstyle=\footnotesize]
\begin{pspicture}[showgrid=true](3.2,5)
  \pnode(0,3){In}\pnode(1,3){BS}\pnode(3,3){M1}
  \pnode(1,5){M2}\pnode(1,1){PD}
  \psset{mirrortype=extended, mirrordepth=0.2, bsstyle=plate, dettype=diode}
\begin{optexp}
  \beamsplitter(In)(BS)(PD)
  \mirror(BS)(M1)(BS)
  \mirror[variable](BS)(M2)(BS)
  \lens(BS)(PD)
  \optdetector(BS)(PD)
  \addtopsstyle{Beam}{fillstyle=solid, fillcolor=green!20!white, beamwidth=0.2}
  \drawwidebeam{(In)}{1}{2}{1}{3}{1}{4}{5}
  \drawbeam[linecolor=red, beamangle=1.2]{(In)}{1}{2}{1}{3}{1}{4}{5}
  \drawbeam[linecolor=blue, beamangle=-1.2]{(In)}{1}{2}{1}{3}{1}{4}{5}
\end{optexp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \iffalse
%<*ignore>
% \fi
%%\begingroup
%%\catcode`\*=13
%%\def*{}%
\begin{LTXexample}[pos=t, vsep=5mm, numbers=left, numberstyle=\footnotesize]
\begin{pspicture}[showgrid=true](7.7,2.4)
  \pnode(1,1){Laser}\pnode(6.5,1){Osa}\pnode([offset=1]Osa){Pd}
  \psset{optboxwidth=1, usefiberstyle}
  \optbox[endbox, labeloffset=0](Osa)(Laser){Laser}
  \polcontrol[nofiber, abspos=1](Laser)(Osa)
  \optmzm[nofiber, abspos=2.5](Laser)(Osa){MZM}
  \wdmsplitter[fiberin=none, align=bottom, abspos=4](Laser)(Pd)(Osa)
  \optdetector[dettype=diode]([Xnodesep=-0.1]Pd)(Pd){}
  \optbox[endbox, labeloffset=0](Laser)(Osa){OSA}
  \drawfiber{1}{3}
  \drawfiber{3}{4}
\end{pspicture}
\end{LTXexample}
%%\endgroup
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begingroup
\catcode`\*=13
\def*{}%
\begin{LTXexample}[pos=t, vsep=5mm, numbers=left, numberstyle=\footnotesize]
\begin{pspicture}(0.4,0.1)(9,3.4)
  \pnode(2,3){Laser}*\label{expl:quick-nodefirst}*
  \pnode(2,1){PwMeter}
  \pnode(6,3){CplTop}
  \pnode(6,1){CplBot}*\label{expl:quick-nodelast}*
  \psset{arrowscale=1.5, arrowinset=0}
  \optbox[endbox, optboxheight=1, optboxwidth=1.6, labeloffset=0]([Xnodesep=0.1]Laser)(Laser){%
    \begin{tabular}{@{}c@{}}Nd:YAG\\cw laser\end{tabular}}
  \optcoupler[addtoFiberIn1={ArrowInside=->},
              addtoFiberIn2={ArrowInside=-<},
              labeloffset=0.4]%
              (Laser)(PwMeter)(CplTop)(CplBot){WDM}
  \optfiber[addtoFiberOut={ncurv=1, angleB=0},
            addtoFiberIn={ncurv=1, angleA=0}, 
            compshift=-1,
            label=0.2 . l](CplBot)(CplTop){Fiber}
  \optdetector[labelangle=180, dettype=diode]([Xnodesep=0.1]PwMeter)(PwMeter){power meter}
\end{pspicture}
\end{LTXexample}
\endgroup
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begingroup
\catcode`\*=13
\def*{}%
\begin{LTXexample}[pos=t, vsep=5mm, numbers=left, numberstyle=\footnotesize]
\begin{pspicture}[showgrid=true](1,1.2)(6.2,5)
  \pnode(1,4){SigIn}
  \pnode(3,4){BS}
  \pnode(3,5){LO}
  \pnode(5,4){Det1}
  \pnode(3,2){Det2}
  \begin{optexp}
  \optplane(LO)(1,0){LO}
  \beamsplitter[compname=BS](SigIn)(BS)(Det2){}
  \lens[abspos=0.5, compname=L2, n=2.1](Det2)(BS){}
  \lens[abspos=0.5, compname=L1, n=2.1](Det1)(BS){}
  \optdetector[compname=Det1, extnode=c](BS)(Det1){PD1}
  \optdetector[compname=Det2, extnode=c](BS)(Det2){PD2}
  \addtopsstyle{Beam}{beamwidth=0.2, fillstyle=solid, fillcolor=green, opacity=0.2}
  \drawwidebeam{(SigIn)}{BS}{L2}{Det2}
  \drawwidebeam[beaminsidefirst]{BS}{L1}{Det1}
  \newpsstyle{Beam}{linecolor=red, linestyle=dashed, linewidth=1.5\pslinewidth}
  \drawbeam{LO}{BS}{L1}{Det1}
  \drawbeam[beaminsidefirst]{BS}{L2}{Det2}
\end{optexp}
\cnodeput([Xnodesep=0.5, offset=-0.5]\oenodeExt{Det1}|\oenodeExt{Det2}){M}{\rule{3mm}{1pt}}
  \nccurve[angleA=90, arrows=<-]{M}{\oenodeExt{Det1}}
  \nccurve[angleA=180, angleB=-90, arrows=<-]{M}{\oenodeExt{Det2}}
\end{pspicture}
\end{LTXexample}
\endgroup
% \iffalse
%</ignore>
% \fi
% 
% \section{Backward compatibility}
% 
% \begin{optionlist}
% \optitem[new]{namingscheme}{old, new}
% Version 3.0 introduced a lot of advanced features which made it too difficult to
% maintain full backward compatibility with version 2.x. However, using the
% \Loption{compat} package option allows you to compile old setups but without
% profiting from the new features. If you only need the old naming scheme, because
% you accessed internal nodes directly, then you must only set
% \nxLkeyword{namingscheme=old}.
% \end{optionlist}
% 
% \section{Concept and general behavior}\label{sec:general}
% 
% This section introduces into the basic concepts of the package design and
% explains the parameters and commands which are supported by most optical
% objects.
% 
% \subsection{Concept}
% 
% The objects provided by \LPack{pst-optexp} can be differentiated into
% two different categories: free-ray and fiber-optical objects.
% 
% The free-ray units are subdivided in two different kinds: dipoles which
% require two reference points for alignment and do not alter the
% direction of passing light beams (e.g. lenses and retardation plates)
% and tripoles which work in reflection and require three reference points
% (mirrors, gratings, beamsplitters etc.).
% 
% For free-ray setups one usually has a few straight light paths in which
% several different objects are to be arranged. In this case it is very
% convenient to define only two nodes for each light path. The objects are
% placed on this light path using the different positioning parameters
% (see \prettyref{sec:positioning}) of the package. After having arranged
% everything, the beams themselves are drawn (see \prettyref{sec:connecting}).
% 
% The fiber-optical objects can be classified as dipoles, tripoles and quadrupoles
% which have a corresponding number of fiber connections. Their handling differs
% in some aspects from the free-ray objects. The fiber optics are directly
% connected to the reference nodes. Every input and output fiber can be flexibly
% customized for each object (see \prettyref{sec:styles}). Positioning of the
% fiber dipoles is handled equivalently to the free-ray dipoles. Tripoles and
% quadrupoles can be found only as different coupler types. Their positioning
% mechanisms are a bit more involved and explained in the respective section
% (\prettyref{sec:coupler}).
% 
% Some hybrid dipoles (optbox, detector etc.) can be used both as
% fiber-optical or free-ray elements. 
% 
% \subsection{General settings}
% 
% Some generic parameters which can be used for all objects.
% 
% \begin{optionlist}
% \numitem[0]{angle}
% Rotate an object by \nxLkeyword{angle} degrees.
% 
% \boolitem[false]{optional}
% \styleitem{OptionalStyle}
% Can be used with every object and marks it as optional. The style of an
% optional element can be configured by changing the style
% \nxLkeyword{OptionalStyle}.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
\lens[optional, beam](0,1)(3,1){L}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \boolitem[false]{showoptdots}
% Draw some internal nodes which are used to place the object and the
% label. The black points are used for positioning, the red points mark
% the label references.
% 
% \begin{lstlisting}[gobble=2]
% \begin{pspicture}(3,2)
% \mirror[showoptdots,
%           beam](0,1)(1.9,1)(1.9,0){mirror}
% \end{pspicture}
% \end{lstlisting}
% \end{optionlist}
% 
% \subsection{Using PSStyles}\label{sec:styles}
% 
% The appearance of many functional parts of \LPack{pst-optexp} objects is
% controlled via psstyles. These are collections of parameters which are
% applied only to selected subparts of the objects. In general, these
% psstyles can be overwritten with the \Lcs{newpsstyle} macro and extended
% with the \Lcs{addtopsstyle} macro. \ref{mylabel}
% 
% \begin{optionlist}
% \styleitem{OptComp}
% Affects only the appearence of the optical
% components. This was introduced, because using only the standard
% graphics parameters changes also the connections that are drawn within
% the component.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,4)
  \psset{beam}
  % wrong, also beam width is changed
  \mirror[linewidth=3\pslinewidth]%
         (0,3)(2,3)(2,2){mirror}
  % correct result
  \mirror[addtoOptComp={linewidth=3\pslinewidth}]%
         (0,1)(2,1)(2,0){mirror}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \styleitem{OptionalStyle}
% \end{optionlist}
%
% \subsection{Positioning}\label{sec:positioning}
% \begin{optionlist}
%   \numitem{position} Equivalent to the \Lkeyword{npos} parameter of
%   \Lcs{ncput} (a number in the range $0-1$) and controls the relative position
%   of object between the two reference points. It is available for all components
%   but the free-ray tripoles.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5) 
  \lens[beam, position=0.8](0,1)(3,1){L}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem{abspos}
% The parameter \Lkeyword{abspos} allows absolute positioning between the
% two reference nodes.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5) 
  \lens[beam, abspos=1](0,1)(3,1){L}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem[0]{compshift}
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2) 
  \lens[compshift=0.1, n=1](0,1)(3,1){L}
  \addtopsstyle{Beam}{beamangleabs}
  \drawbeam{(0,1)}{}{(3,1)}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}
\begin{pspicture}(3,2) 
  \mirror[beam, compshift=0.2, beamangleabs, labelangle=45](0,1)(2,1)(2,0){mirror}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% 
% \ifGERMAN
%   \subsection{Beschriftungen}
% \fi
% \ifENGLISH
%   \subsection{Labels}
% \fi
% \label{sec:labels}
%
% \begin{optionlist}
% \numitem[0.8]{labeloffset}
% Specify the offset from the label reference node of the object which in most
% cases is the center.
% 
% \valitem[\nxLcs{small}]{labelstyle}{macros}
% Define the textstyle that is used to typeset the label. 
% 
% \valitem[c]{labelalign}{refstring}
% Has the same meaning as the refpoint of \Lcs{rput} and can take the same values.
% 
% \numitem[0]{labelangle}
% Set the label rotation angle around the object. \nxLkeyword{labelref} can be used to change the reference system.
% 
% \choitem[relgrav]{labelref}{relative, relgrav, global}
% Set the reference coordinate system for the \nxLkeyword{labelangle} and the orientation of
% the label text. The detailed behaviour is best illustrated looking at
% the following three examples.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(-2,-2)(2.5,2)
  \psset{endbox, optboxwidth=1, optboxheight=0.6}
  \multido{\i=0+45}{8}{%
    \optbox[label=0 . . relative](0,0)(1;\i){\i}
  }
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}
\begin{pspicture}(-2,-2)(2.5,2)
  \psset{endbox, optboxwidth=1, optboxheight=0.6}
  \multido{\i=0+72}{5}{%
    \optbox[labelref=relgrav](0,0)(1;\i){\i}
  }
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}
\begin{pspicture}(-2,-2)(2.5,2)
  \psset{endbox, optboxwidth=1, optboxheight=0.6}
  \multido{\i=0+72}{5}{%
    \optbox[labelref=global](0,0)(1;\i){\i}
  }
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \optitem{label}{\prm{offset}[ \prm{angle}[ \prm{ref string}[ \prm{labelref}]]]}
% Allows simplified notation for changing more than one
% label-related parameter. It takes up to four space-separated arguments
% (\nxLkeyword{labeloffset}, \nxLkeyword{labelangle}, \nxLkeyword{labelalign}, and
% \nxLkeyword{labelref}). Unchanged intermediate arguments may be specified with a dot.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(0,0)(4,3)
  \psset{endbox, beam}
  \optbox[label=0.7](1.5,2.5)(2.5,2.5){label}
  \optbox[label=1 -45](1.5,1)(2.5,1){$-45$}
  \optbox[label=0 . . relative]%
         (0.6,0.6)(0.6,1.6){relative}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \subsection{Accessing Objects and Special Nodes}\label{sec:objnodes}
% 
% Every \nxLPack{pst-optexp} object of an experimental setup provides several
% special nodes which are related to the geometry and the positioning of the
% component. These are useful for related positioning and drawing.
% 
% \subsubsection{Object Names}\label{sec:namingobj}
% All objects are numbered automatically in increasing order by their definition
% in the code. The objects as well as their special nodes can be accessed via this
% number.
% 
% \begin{optionlist}
%   \valitem{compname}{string} This parameter can be used to assign a unique
%   name instead of the automatic number to an object. It can be used only
%   directly within a \nxLPack{pst-optexp} object and must be unique within one
%   \nxLkeyword{pspicture} environment.
% 
% \begin{lstlisting}[gobble=2]
% \optbox[compname=MyBox](A)(B){Box} % valid use of 'compname'
% \psset{compname=MyName}            % not valid, gives an error
% \end{lstlisting}
% \end{optionlist}
% 
% \subsubsection{Accessing Internal Nodes}\label{sec:internalnodes}
% 
% Every object defines several special internal nodes which are very useful for
% related positioning and drawing. You should always use the provided \nxLcs{oenode*}
% macros to access the node names.
% 
% \begin{ltxsyntax}
% \cmditem{oenode}{Obj}{Node}
% 
% This is the basic command which takes as first argument the name of the
% target object (for naming see \ref{sec:namingobj}) and as second argument the
% name of the requested special node. For most special nodes an appropriate macro is provided.
% 
% \end{ltxsyntax}
% 
% \subsection{Nodes For External Usage}\label{sec:extnode}
% 
% Some of the objects can provide a supplementary node for additional
% connections. A laser diode may be connected for example to a frequency synthesizer
% (use package \LPack{pst-circ}) or a detector to a computer.
% 
% \begin{optionlist}
% \valitem{extnode}{refstring}
% 
% Controls the position of the additional node and
% takes a \paramvalue{<ref string>} as its argument. By default this
% parameter is empty (\paramvalue{\{\}}) and no node is created.
% 
% The name of the new node depends on the \Lkeyword{compname} parameter
% (see Sec.~\ref{sec:namedobj} for naming conventions). If \nxLkeyword{compname} is empty
% the new node is named \nodename{ExtNode} by default and overwritten by
% following objects.
% 
% Table.~\ref{tab:nodes} shows all objects which provide an external
% node. Some allow any possible \paramvalue{<ref string>} for \Lkeyword{extnode}, others have
% only one reasonable possibility (e.g. piezo mirror, see
% Sec.~\ref{sec:mirror}) which does not depend on the actual value of \Lkeyword{extnode}.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, vsep=8mm]
\begin{pspicture}[showgrid=true](11,3) 
   \psset{beam, beaminside=false, labelangle=-90, labeloffset=0.3}
   \optbox[extnode=tl](0,2.5)(3,2.5){\texttt{tl}}\psdot(\oenodeExt{})
   \optbox[extnode=l](0,1.5)(3,1.5){\texttt{l}}\psdot(\oenodeExt{})
   \optbox[extnode=bl](0,0.5)(3,0.5){\texttt{bl}}\psdot(\oenodeExt{})
   \optbox[extnode=t](4,2.5)(7,2.5){\texttt{t}}\psdot(\oenodeExt{})
   \optbox[extnode=c](4,1.5)(7,1.5){\texttt{c}}\psdot(\oenodeExt{})
   \optbox[extnode=b](4,0.5)(7,0.5){\texttt{b}}\psdot(\oenodeExt{})
   \optbox[extnode=tr](8,2.5)(11,2.5){\texttt{tr}}\psdot(\oenodeExt{})
   \optbox[extnode=r](8,1.5)(11,1.5){\texttt{r}}\psdot(\oenodeExt{})
   \optbox[extnode=br](8,0.5)(11,0.5){\texttt{br}}\psdot(\oenodeExt{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \newpage
% 
% \ifGERMAN
%   \section{Freistrahl-Komponenten}
% \fi
% \ifENGLISH
%   \section{Free-Ray Objects}
% \fi
%
% \ifGERMAN
%   \subsection{Linse}
% \fi
% \ifENGLISH
%   \subsection{Lens}
% \fi
% \label{sec:lens}
%
% \begin{ltxsyntax}
% \dipoledesc{lens}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
\lens[beam](0,1)(3,1){L}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[1]{lensheight} 
% \ifGERMAN Setzt die Höhe der Linse.\fi
% \ifENGLISH Set the height of the lens.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
\lens[beam](0,1)(3,1){L1}
\lens[lensheight=0.5](2,1)(3,1){L2}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \numitem[1]{lensradiusleft} 
% \ifGERMAN
% Setzt den Radius der linken Linsengrenzfläche. Ein positiver Wert \prm{num}
% ist für eine konvexe, ein negativer für eine konkave Krümmung. Null ergibt
% eine ebene Fläche.
% \fi
% \ifENGLISH
% Set the left radius of the lens. A positive \prm{num} is for convex, a
% negative one for concave curvatures. Use zero for a plain surface.
% \fi
% 
% \numitem[1]{lensradiusright} 
% \ifGERMAN
% Dasgleiche wie \opt{lensradiusleft}, nur für die rechte Grenzfläche.
% \fi
% \ifENGLISH
% Same as \opt{lensradiusleft} but for the right surface.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset{lensradiusright=0, beam}
  \lens[lensradiusleft=1](0,1)(1.5,1){$R > 0$}
  \lens[lensradiusleft=-1](1.5,1)(3,1){$R < 0$}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem{lensradius} 
% \ifGERMAN
%   Setzt beide Krümmungen auf denselben Wert.
% \fi
% \ifENGLISH
%   Set both curvatures to the same value.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \lens[lensradius=-2, beam](0,1)(3,1){L1}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \numitem[0]{lenswidth}
% \ifGERMAN
% Üblicherweise werden nur die Höhe und die beiden Radien für die
% Konstuktion der Linse verwendet. Die Mittenbreite wird automatisch
% ermittelt. Wenn \opt{lenswidth} auf einen Wert größer Null gesetzt wird,
% wird diese Breite verwendet. Das ist nur sinnvoll, wenn dicke Linsen
% gezeichnet werden sollen, da es andernfalls für zu kleine Werte zu unschönen
% Ergebnissen führt.
% \fi
% \ifENGLISH
% Usually only the height and the two radii are used to construct the lens and
% the width is calculated from these parameters. If \opt{lenswidth} is greater
% than zero, this width is used instead. This is only useful if you want to draw
% thick lenses and it can have ugly results if the lens width is choosen too
% small.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \lens[lenswidth=0.5, beam](0,1)(2,1){thicklens}
  \lens[lenswidth=0.1, beam](2,1)(3,1){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \optitem{lens}{\prm{radiusleft} [\prm{radiusright} [\prm{height} [\prm{width}]]]}
% \ifGERMAN
% Eine Option zum gleichzeitigen Setzen mehrerer Linsenparameter. Es müssen
% nicht alle Werte gesetzt werden, die übrigen bleiben unverändert.
% \fi
% \ifENGLISH
% A convenience option to specify all lens parameters with a single option.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \lens[lens=1](0,1)(1,1){L1}
  \lens[lens=-2 1, beam](0,1)(3,1){L2}
  \lens[lens=1 -0.5 0.7](2,1)(3,1){L3}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Optisches Pl\"attchen}
% \fi
% \ifENGLISH
%   \subsection{Optical Plate}
% \fi
% 
% \begin{ltxsyntax}
% \dipoledesc{optplate}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optplate[beam](0,1)(3,1){filter}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
%   \numitem[1]{plateheight} The height of the plate.
% 
%   \optitem[2\nxLcs{pslinewidth}]{platelinewidth}{\prm{num} or \prm{dimen}} The linewidth of the
%   plate. This could be defined also with the generic \opt{linewidth} option,
%   possibly inside the \opt{OptComp} style. But using \opt{platelinewidth} allows
%   to globally change the linewidth of all \nxLcs{optplate} objects.
% 
% \numitem[0]{angle} Rotate the plate around its center.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optplate[angle=10, beam](0,1.2)(3,1.2){glass plate}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Verzögerungsplättchen}
% \fi
% \ifENGLISH
%   \subsection{Retardation plate}
% \fi
% \begin{ltxsyntax}
% \dipoledesc{optretplate}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optretplate[beam](0,1)(3,1){$\nicefrac{\lambda}{2}$}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[1]{plateheight} The height of the plate.
% \numitem[0.1]{platewidth} The width of the plate.
% \end{optionlist}
% 
% \subsection{Pinhole}
% 
% \begin{ltxsyntax}
% \dipoledesc{pinhole}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \pinhole[beam](0,1)(3,1){PH}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[1]{outerheight}
% \numitem[0.1]{innerheight}
% \optitem[2\nxLcs{pslinewidth}]{phlinewidth}{\prm{num} or \prm{dimen}}
% The linewidth of the pinhole. This could be defined also with the generic \opt{linewidth} option,
% possibly inside the \opt{OptComp} style. But using \opt{phlinewidth} allows
% to globally change the linewidth of all \nxLcs{pinhole} objects.
% 
% \numitem[0]{phwidth} The pinhole is drawn in a more plastic style if the
% \nxLkeyword{phwidth} is not zero.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \pinhole[beam, phwidth=-0.1](0,1)(3,1){PH}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \subsection{Crystal}\label{sec:crystal}
% 
% \begin{ltxsyntax}
% \dipoledesc{crystal}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
\crystal[beam](0,1)(3,1){Crystal}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[1.4]{crystalwidth}
% \numitem[0.6]{crystalheight}
% \numitem[0.6]{caxislength}
% \boolitem[false]{caxisinv}
% \styleitem{CrystalCaxis}
% \boolitem[false]{voltage}
% \boolitem[false]{lamp}
% \numitem[0.3]{lampscale}
% \numitem[0]{angle}
% \valitem[c]{rotateref}{refstring}
% \end{optionlist}
% 
% \noindent For a discussion of the \Lkeyword{angle} and \Lkeyword{rotateref}
% parameters see Sec.~\ref{sec:box} about boxes.  \medskip
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
\crystal[fillstyle=solid, fillcolor=yellow!90!black, 
           label=1.2 -45, voltage, 
           lamp, beam](0,1)(3,1){SBN:Ce}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \medskip
% 
% \subsection{Box}\label{sec:box}
% 
% \begin{ltxsyntax}
% \dipoledesc{optbox}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optbox[beam](0,0)(3,2){box}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{optboxheight}
% \numitem[1.4]{optboxwidth}
% \boolitem[false]{endbox}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optbox[beam, endbox, label=0 . . relative]%
           (0,0)(1.5,1){box}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem[0]{angle}
% \numitem[c]{rotateref}{refstring}
% The parameter \Lkeyword{angle} describes the tilt of the box
% relative to the reference line defined by the two reference nodes. The
% reference point for the rotation can be defined
% with \Lkeyword{rotateref} which can take any combination
% of \paramvalue{c}, \paramvalue{t}, \paramvalue{b}, \paramvalue{l}
% and \paramvalue{r} (compare with \Lkeyword{extnode} in
% Sec.~\ref{sec:extnode}). Note, that all connection-related nodes are
% also rotate, while the label is not affected.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optbox[angle=20, beam, rotateref=l, 
            labeloffset=0.5](0,1)(3,1){box}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem{refractiveindex}
% Together with the parameter \Lkeyword{refractiveindex} this
% can be exploited to sketch the refraction through a tilted homogeneous
% medium (e.g. a glass plate). Then, however, the reference nodes for the
% beam connection must be corrected which is rather easy using the outer
% nodes of the object as coordinate references and the 
% node
% operator.
% 
% \medskip
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \pnode(0,1){A}\pnode(3,1){B}
  \optbox[labeloffset=0.8, optboxwidth=0.5, optboxheight=1, angle=20, n=2.3, compname=Box](A)(B){glass plate}
  \drawbeam{(A|\oenodeIn{Box})}{Box}
  \drawbeam{Box}{(B|\oenodeOut{Box})}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \subsection{Detector}
% 
% \begin{ltxsyntax}
% \dipoledesc{optdetector}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.2)
  \optdetector[beam](0,0)(1.5,1){detector}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.8]{detsize} For a \opt{round} detector this is the object
%   diameter, for the \opt{diode} detector its side length.
% 
% \choitem[round]{dettype}{round, diode} This parameter selects between different
% types of detectors.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optdetector[beam, dettype=diode](0,0)(1.5,1){detector}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \subsection{Optical Diode}\label{sec:optdiode}
% 
% 
% \begin{ltxsyntax}
% \dipoledesc{optdiode}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
   \optdiode[beam, beaminside=false](0,1)(3,1){Diode}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.8]{optdiodesize}
% \end{optionlist}
% 
% \subsection{Dove Prism}\label{sec:doveprism}
% 
% \begin{ltxsyntax}
% \dipoledesc{doveprism}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \doveprism[beam](0,1)(3,1){Dove}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.6]{doveprismsize} The height of the prism, the total width is
%   three times the height and the angles at the input and output faces are
%   45\textdegree.
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Polarisation}
% \fi
% \ifENGLISH
%   \subsection{Polarization}
% \fi
%
% \begin{ltxsyntax}
% \dipoledesc{polarization}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1)
  \polarization[beam](0,0.5)(3,0.5)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \choitem[parallel]{poltype}{parallel, perp, misc, lcirc, rcirc}
% \numitem[0.6]{polsize}
% \optitem[0.7\nxLcs{pslinewidth}]{pollinewidth}{\prm{num} or \prm{dimen}}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,5)
  \psset{beam}
  \begin{optexp}
  \polarization[poltype=parallel, 
                  abspos=0.5](0,4.5)(3,4.5)
  \polarization[poltype=perp, abspos=1](0,3.5)(3,3.5)
  \polarization[poltype=misc, abspos=1.5](0,2.5)(3,2.5)
  \polarization[poltype=lcirc, abspos=2](0,1.5)(3,1.5)
  \polarization[poltype=rcirc, 
                  abspos=2.5](0,0.5)(3,0.5)
  \end{optexp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Spiegel}
% \fi
% \ifENGLISH
%   \subsection{Mirror}
% \fi
% \label{sec:mirror}
% 
% \begin{ltxsyntax}
% \tripoledesc{mirror}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \mirror[beam](0,0)(1.8,1.5)(0,2){M}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[1]{mirrorwidth}
% \ifGERMAN 
%   Die Breite des Spiegels.
%  \fi
% \ifENGLISH 
%   The width of the mirror.
% \fi
% 
% \optitem[2\nxLcs{pslinewidth}]{mirrorlinewidth}{\prm{num} or \prm{dimen}} 
% \ifGERMAN
% Die Linienbreite des Spiegels. Diese könnte ebenfalls über den
% \opt{linewidth} Parameter gesetzt werden. Mit diesem Parameter kann
% aber die Linienbreite aller Spiegel global eingestellt werden.
% \fi
% \ifENGLISH
% The linewidth of the grating. This could be defined also with the
% generic \opt{linewidth} option. But this parameter allows setting
% globally the linewidth of all mirrors.
% \fi
%
% \numitem[0]{mirrorradius} 
% \ifGERMAN
% Diese Parameter setzt die Krümmung des Spiegels. Null ergibt einen
% ebenen, ein negativer Radius einen konkaven und ein positiver Radius
% einen konvexen Spiegel.
% \fi
% \ifENGLISH
% This parameter defines the curvature of the mirror. A value of \opt{0}
% is for a plain mirror, a negative radius for a concave mirror and a
% positive radius gives you a convex mirror.
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[width=3.5cm]
\begin{pspicture}(3,3)
  \psset{labeloffset=0.5}
  \mirror[mirrorradius=1](0,0)(1,2)(1.8,1){concave}
  \mirror[mirrorradius=-1](1,2)(1.8,1)(2.5,3){convex}
  \drawbeam{(0,0)}{1}{2}{(2.5,3)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[normal]{mirrortype}{normal, piezo, extended}
% \ifGERMAN
%   Diese Parameter wählt die Spiegelart aus. Beachte, dass der
%   Anschlussdraht für den Piezospiegel nicht gezeichnet wird, wenn
%   \Lkeyword{extnode} verwendet wird.
% \fi
% \ifENGLISH
% The \nxLkeyword{mirrortype} selects between different types of
% mirrors. Note, when using \Lkeyword{extnode} with a piezo mirror, the
% default piece of wire is omitted.
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \mirror[mirrortype=extended,
            beam](0,0)(1.8,1.5)(0,2){ext}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}
\begin{pspicture}(3,2)
\mirror[mirrortype=piezo,
          beam](0,0)(1.8,1.5)(0,2){piezo}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \styleitem{ExtendedMirror} 
% \ifGERMAN Der Stil für den «extended» Spiegel.\fi
% \ifENGLISH The style for the extended mirror.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \newpsstyle{ExtendedMirror}{fillstyle=solid, 
                                fillcolor=gray!50,
                                linestyle=none}
  \mirror[mirrortype=extended,
            beam](0,0)(1.8,1.5)(0,2){ext}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \styleitem{PiezoMirror} 
% \ifGERMAN 
% Der Stil für den «piezo» Spiegel. Dieser kann auch dazu verwendet
% werden, die Größe des Piezos zu verändern, wie die Beispiele zeigen.
% \fi
% \ifENGLISH
% This style defines the appearance of the piezo mirror. This can also
% be used to change the size of piezo part, as shown in the examples.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \addtopsstyle{PiezoMirror}{xunit=2}
  \mirror[mirrortype=piezo,
            beam](0,0)(1.8,1.5)(0,2){piezo}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \boolitem[false]{variable}
% 
% \styleitem{VariableMirror} With the \opt{variable} option a moveable
% mirror is drawn which has two additional curved arrows on both sides. The style
% of the arrows can be changed with the \opt{VariableMirror} style.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \mirror[beam, variable](0,0)(1.8,1.5)(0,2){var}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem[0.1]{mirrordepth} Define the depth of an extended mirror
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \mirror[mirrortype=extended, mirrordepth=0.2,
            beam](0,0)(1.8,1.5)(0,2){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Strahlteiler}
% \fi
% \ifENGLISH
%   \subsection{Beamsplitter}
% \fi
% \begin{ltxsyntax}
% \tripoledesc{beamsplitter}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \beamsplitter[beam](0,1)(2,1)(2,0){BS}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{bssize}
% \ifGERMAN
%   Die Größe des Strahlteilers.
% \fi
% \ifENGLISH
%   The beamplitter size.
% \fi
%  
% \choitem[cube]{bsstyle}{cube, plate} 
% \ifGERMAN
% Wähle zwischen zwei Strahlteilertypen: einem Strahlteilerwürfel
% (\opt{cube}) und einem halbdurchlässigen Spiegel
% (\opt{plate}). Beachte, dass trotz des gleichen Aussehens der
% halbdurchlässige Spiegel eine anderes Verhalten beim Strahlzeichnen
% als der gewöhnliche Spiegel hat.
% \fi
% \ifENGLISH
% Selects between two types of beamsplitters: the beamsplitter cube
% (\opt{cube}) and the semitransparent mirror (\opt{plate}).  Note, that
% despite the same look, the \opt{plate} beamsplitter behaves
% differently for beam drawing.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \beamsplitter[bsstyle=plate, beam](0,1)(2,1)(2,0){BS}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Optisches Gitter}
% \fi
% \ifENGLISH
%   \subsection{Optical Grating}
% \fi
% 
% \begin{ltxsyntax}
% \tripoledesc{optgrating}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[1]{gratingwidth} 
% \ifGERMAN Die Breite des Gitters.\fi
% \ifENGLISH The width of the grating.\fi
% 
% \numitem[0.15]{gratingheight} 
% \ifGERMAN Die Gesamthöhe des Gitters.\fi
% \ifENGLISH The total height of the grating.\fi
% 
% \numitem[0.075]{gratingdepth}
% \ifGERMAN 
% Die absolute Modulationstiefe der Gitterstruktur. Die Gesamthöhe wird
% an diesen Wert angepasst falls sie kleiner als die Modulationtiefe ist, 
% andernfalls wird sie nicht beinflusst.
% \fi
% \ifENGLISH
% The modulation depth of the grating structure. The total height is
% adapted to this value if it is smaller than the modulation
% depth. Otherwise the total height is not affected.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[gratingdepth=0.05, 
               beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \intitem[10]{gratingcount} 
% \ifGERMAN Die Anzahl der Gitterlinien.\fi
% \ifENGLISH The number of grating grooves.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[gratingcount=3, 
               beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[blazed]{gratingtype}{blazed, binary} 
% \ifGERMAN 
%   Wähle zwischen einem binären Gitter (\opt{binary}) und einem Blazegitter (\opt{blazed}).
% \fi
% \ifENGLISH
%   Select between a \opt{binary} and a \opt{blazed} grating.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[gratingtype=binary, 
               beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \boolitem[false]{reverse} 
% \ifGERMAN
%   Invertiere die Steigung des Blazegitters.
% \fi
% \ifENGLISH
%   Reverse the slope of the grooves of the \opt{blazed} grating.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[reverse, beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \optitem[0.7\nxLcs{pslinewidth}]{gratinglinewidth}{\prm{num} or \prm{dimen}} 
% \ifGERMAN
% Die Linienbreite des Gitters. Diese könnte ebenfalls über den
% \opt{linewidth} Parameter gesetzt werden. Mit diesem Parameter kann
% aber die Linienbreite aller Gitter global eingestellt werden.
% \fi
% \ifENGLISH
% The linewidth of the grating. This could be defined also with the
% generic \opt{linewidth} option. But this parameter allows setting
% globally the linewidth of all gratings.
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Prisma}
% \fi
% \ifENGLISH
%   \subsection{Prism}
% \fi
% \label{sec:prism}
% 
% \begin{ltxsyntax}
% \tripoledesc{optprism}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optprism[beam](0,1)(2,1)(3,0){Prism}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \ifGERMAN
% Das Prisma wird immer symmetrisch bezüglich der \prm{In} und \prm{Out}
% Knoten ausgerichtet. Für asymmetrischen Strahlengang siehe
% \prettyref{sec:connecting}.
% \fi
% \ifENGLISH
% The prism is always placed symmetric between \prm{In} and \prm{Out}
% nodes. For asymmetric beam traces see \prettyref{sec:connecting}.
% \fi
%
% \begin{optionlist}
% \numitem[1]{prismsize} 
% \ifGERMAN Die Höhe des Prismas.\fi
% \ifENGLISH The height of the prism.\fi
% \numitem[60]{prismangle}
% \ifGERMAN Der obere Winkel des Prismas.\fi
% \ifENGLISH The upper angle of the prism.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optprism[prismangle=30, beam](0,1)(2,1)(3,0){Prism}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Umkehrprisma}
% \fi
% \ifENGLISH
%   \subsection{Right-Angle Prism}
% \fi
% \label{sec:raprism}
% 
% \begin{ltxsyntax}
% \tripoledesc{raprism}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psdot(1.8,1)
  \rightangleprism[beam](0,1.5)(1.8,1)(0,0.5){RA}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \ifGERMAN
% Das Umkehrprisma wird so ausgerichtet, dass der einfallende und der
% reflektierte Strahl parallel sind und der \prm{Center} Knoten vertikal
% zentriert in dem Prisma liegt.
% \fi
% \ifENGLISH
% The right-angle prisms is align such that the incoming and reflected
% beam are parallel and the \prm{Center} node is vertically centered in
% the prism.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psdot(1.8,1.2)
  \rightangleprism[beam](0,1.5)(1.8,1.2)(0,0.5){RA}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \begin{optionlist}
% \numitem[1.5]{raprismsize}
% \ifGERMAN Die Länge der Eingangsfläche.\fi
% \ifENGLISH The length of the input plane.\fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Pentaprisma}
% \fi
% \ifENGLISH
%   \subsection{Penta Prism}
% \fi
% \label{sec:ppprism}
% 
% \begin{ltxsyntax}
% \tripoledesc{pentaprism}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \pentaprism[beam](0,1)(2,1)(2,0){PP}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.7]{pentaprismsize} 
%   \ifGERMAN Die Länge der Eingangs- und Ausgangsfläche.\fi
%   \ifENGLISH The length of the input and output plane.\fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Benutzerdefinierte Komponenten}
% \fi
% \ifENGLISH
%   \subsection{Custom Components}
% \fi
% \label{sec:custom}
%
% \ifGERMAN
% Das \LPack{pst-optexp} Paket stellt zwei Makros zur Verfügung um
% eigene Komponenten zu zeichnen. Diese können z.B. aus Bildern oder
% eigenen Zeichnungen bestehen.
% \fi
% \ifENGLISH
% The \nxLPack{pst-optexp} package provides two commands which can use
% anything as optical components. This includes e.g. external images or
% your own drawings.
% \fi
% 
% \begin{ltxsyntax}
%   \dipoledesc{optdipole}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \optdipole[labeloffset=1, beam](0,2)(3,1){%
    \rput(0,0){%
      \rule{0.5cm}{1cm}
    }
  }{label}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \tripoledesc{opttripole}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \pnode(0,0){A}
  \pnode(1.5,2){G}
  \pnode(3,1.5){B}
  \opttripole[beam](3,1.5)(1.5,2)(0,0){%
    \rput[b](0,0){text}
  }{label}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
%
% If you want to use a custom component more often, you should define
% it as a new component. For details on how to define your own components see
% \prettyref{sec:newobj}.
% 
% \ifGERMAN
%   \section{Faseroptische Komponenten}
% \fi
% \ifENGLISH
%   \section{Fiber-Optical Components}
% \fi
% \label{sec:fibercomp}
% 
% \begin{optionlist}
%   \boolitem{usefiberstyle} For some components it might me nice to highlight
%   some internals. If \Lkeyword{usefiberstyle} is enabled, for examples the
%   passing parts of the optical filter are drawn with the \styleshape{Fiber}
%   style. In the documentation this parameter is enabled to show the parts
%   which would be highlighted.
% \end{optionlist}
%
% \ifGERMAN
%   \subsection{Optische Faser}
% \fi
% \ifENGLISH
%   \subsection{Optical Fiber}
% \fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optfiber}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset{labeloffset=0.3}
  \optfiber(0,0.5)(3,0.5){SSMF}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \intitem[3]{fiberloops} 
% \ifGERMAN Anzahl der Faserschleifen.\fi
% \ifENGLISH Number of the fiber loops.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}[showgrid=true](3,1.5)
  \optfiber[fiberloops=2](0,0.5)(3,0.5){SSMF}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem[0.4]{fiberloopradius}
% \ifGERMAN Radius der Faserschleifen.\fi
% \ifENGLISH Radius of the fiber loops.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfiber[fiberloopradius=0.2](0,0.5)(3,0.5){SSMF}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem[0.3]{fiberloopsep}
% \ifGERMAN Abstand zwischen zwei aufeinanderfolgenden Faserschleifen.\fi
% \ifENGLISH Separation between two successive fiber loops.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset{labeloffset=0.3}
  \optfiber[fiberloopsep=0.6](0,0.5)(3,0.5){SSMF}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Optischer Verstärker}
% \fi
% \ifENGLISH
%   \subsection{Optical Amplifier}
% \fi
% \begin{ltxsyntax}
% \fiberdipoledesc{optamp}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optamp(0,1)(3,1){EDFA}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{optampsize} \sizeexplanation
% \end{optionlist}
% 
% \subsection{Mach-Zehnder Modulator}
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optmzm}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optmzm(0,1)(3,1){MZM}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{optmzmsize} \sizeexplanation
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Optischer Filter}
% \fi
% \ifENGLISH
%   \subsection{Optical Filter}
% \fi
% \begin{ltxsyntax}
% \fiberdipoledesc{optfilter}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfilter(0,1)(3,1){bandpass}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{filtersize}
% \ifGERMAN Die Größe des Filters.\fi
% \ifENGLISH The size of the filter.\fi
%
% \choitem[bandpass]{filtertype}{bandpass, bandstop, lowpass, highpass}
% \ifGERMAN Wähle zwischen unterschiedlichen Filtertypen.\fi
% \ifENGLISH Select between different filter types.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfilter[filtertype=bandstop](0,1)(3,1){bandstop}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfilter[filtertype=lowpass](0,1)(3,1){lowpass}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfilter[filtertype=highpass](0,1)(3,1){highpass}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Polarisationssteller}
% \fi
% \ifENGLISH
%   \subsection{Polarization Controller}
% \fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{polcontrol}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \polcontrol(0,1)(3,1){PC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.15]{polcontrolsize} 
% \ifGERMAN Der Radius der Polarisationssteller-Kreise.\fi
% \ifENGLISH The radius of the polarization controller circles.\fi
% \end{optionlist}
% 
% \subsection{Isolator}
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optisolator}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optisolator(0,1)(3,1){isolator}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.6]{isolatorsize} \sizeexplanation
%
% \styleitem{IsolatorArrow} 
% \ifGERMAN 
% Der Stil für den Isolatorpfeil. Das kann insbesonders nützlich sein um
% die Länge des Pfeils zu verändern. 
% \fi
% \ifENGLISH 
% The style of the isolator arrow. This can be especially useful to
% adapt the length of the arrow.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \addtopsstyle{IsolatorArrow}{xunit=1.2, 
                                 arrowinset=0.1}
  \optisolator(0,1)(3,1){isolator}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Schalter}
% \fi
% \ifENGLISH
%   \subsection{Switch}
% \fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optswitch}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optswitch(0,1)(3,1){Opened switch}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{switchsize}
% \ifGERMAN Die Größe des Schalters.\fi
% \ifENGLISH The size of the switch.\fi
%
% \choitem[opened]{switchstyle}{opened, closed} 
% \ifGERMAN Der Zustand des Schalters kann geschlossen (\opt{closed}) oder geöffnet (\opt{opened}) sein. \fi
% \ifENGLISH Indicate the switch as \opt{opened} or \opt{closed}.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optswitch[switchstyle=closed](0,1)(3,1){Closed switch}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Faserverzögerungstrecke}
% \fi
% \ifENGLISH
%   \subsection{Fiber Delay Line}
% \fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{fiberdelayline}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \fiberdelayline(0,1)(3,1){Delay line}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.6]{fdlsize} \sizeexplanation
%
% \styleitem{FdlArrow} 
% \ifGERMAN 
% Der Stil für den Pfeil. Das kann insbesonders nützlich sein um die
% Länge des Pfeils zu verändern, die bei geänderter Größe nicht mehr
% passend sein kann, oder um den Pfeil zu spiegeln.
% \fi
% \ifENGLISH 
% The style of the arrow. This can be especially useful to
% adapt the length of the arrow which may not be appropriate depending
% on the \opt{fdlsize}, or to reverse the arrow.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \addtopsstyle{FdlArrow}{xunit=-1}
  \fiberdelayline(0,1)(3,1){Delay line}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Polarisator}
% \fi
% \ifENGLISH
%   \subsection{Polarizer}
% \fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optfiberpolarizer}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfiberpolarizer(0,1)(3,1){polarizer}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.6]{fiberpolsize} \sizeexplanation
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Faserkollimator}
% \fi
% \ifENGLISH
%   \subsection{Fiber Collimator}
% \fi
% 
% \begin{ltxsyntax}
% \xLcs{fibercollimator}\cmditem{fibercollimator}(In)(A)(B)(Out){Label}%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \fibercollimator[beam](0,1)(3,1){FC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.3]{fibercolsize} \sizeexplanation
% \end{optionlist}
% \ifGERMAN
% Der Fasekollimator kann mit zwei, drei oder vier Punkten verwendet
% werden. Bei zwei Punkten wird der Kollimator wie jeder andere Zweipol
% zwischen \prm{In} und \prm{Out} Knoten platziert. Bei drei Punkten
% wird eine \Lcs{psbezier} Kurve gezeichnet, wobei der mittlere Punkt
% doppelt verwendet wird. Die Positionierungsparameter (see
% \prettyref{sec:positioning}) können verwendet werden um den Kollimator
% zwischen dem \prm{In} und \prm{A} Knoten auszurichten.
% \fi
% \ifENGLISH
% The \nxLcs{fibercollimator} can be used with two, three or four
% points. With two points, the collimator is placed like any other
% dipole component between \prm{In} and \prm{Out} node. For three nodes,
% the fiber is drawn as \Lcs{psbezier} curve for which the central node
% \prm{A} is used twice. Positioning parameters can be used to shift the
% object between \prm{In} and \prm{A} nodes.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
   \fibercollimator[beam](0,1)(2,1)(3,2){FC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \medskip
%
% \ifGERMAN
% Bei vier Konten wird eine \Lcs{psbezier} Kurve mit allen vier Knoten
% gezeichnet. Die Positionierungsparameter (see
% \prettyref{sec:positioning}) können verwendet werden um den Kollimator
% zwischen dem \prm{In} und \prm{A} Knoten auszurichten.
% \fi
% \ifENGLISH
% For four nodes, the fiber is drawn as \Lcs{psbezier} curve with the
% specified nodes. Positioning parameters can be used to shift the
% object between \prm{In} and \prm{A} nodes.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
   \fibercollimator[beam](0,1)(2,1)(3,1)(3,2){FC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \ifGERMAN
%   \subsection{Koppler}
% \fi
% \ifENGLISH
%   \subsection{Coupler}
% \fi
% \label{sec:coupler}
%
% \ifGERMAN
%   \subsubsection{\texorpdfstring{\mathversion{bold}$2\times 2$}{2x2}-Koppler}
% \fi
% \ifENGLISH
%   \subsubsection{\texorpdfstring{\mathversion{bold}$2\times 2$}{2x2} Coupler}
% \fi
% \begin{ltxsyntax}
% \xLfmultipole{optcoupler}\cmditem{optcoupler}(LeftTop)(LeftBottom)(RightTop)(RightBottom){Label}%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optcoupler(0,1.5)(0,0.5)(3,1.5)(3,0.5){Coupler}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.2]{couplersize} \sizeexplanation{2.5}
% \numitem[0.1]{couplersep} 
% \ifGERMAN Der vertikale Abstand zwischen zwei Faserports.\fi
% \ifENGLISH The vertical distance between two fiber ports.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optcoupler[couplersep=0]%
               (0,1.5)(0,0.5)(3,1.5)(3,0.5){Coupler}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[elliptic]{couplertype}{none, elliptic, rectangular, crossswitch}
% \ifGERMAN Wähle zwischen unterschiedlichen Kopplertypen.\fi
% \ifENGLISH Select between different coupler types.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,4.5)
  \psset{labeloffset=0.5}
  \optcoupler[couplertype=none]%
                (0,4.5)(0,3.5)(3,4.5)(3,3.5){Coupler}
  \optcoupler[couplertype=rectangular]%
               (0,3)(0,2)(3,3)(3,2){Coupler}
  \optcoupler[couplertype=crossswitch]%
               (0,1.5)(0,0.5)(3,1.5)(3,0.5){Coupler}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[center]{align}{top, bottom, center}
% \ifGERMAN Die Ausrichtung des Kopplers bezüglich der Referenzknoten.\fi
% \ifENGLISH The alignment of the coupler with respect to the reference nodes.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \psset{labeloffset=0.4}
  \optcoupler[align=top]%
               (0,3)(0,2)(3,3)(3,2){Top}
  \optcoupler[align=bottom]
               (0,1.5)(0,0.5)(3,1.5)(3,0.5){Bottom}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsubsection{WDM-Koppler}
% \fi
% \ifENGLISH
%   \subsubsection{WDM Coupler}
% \fi
% \begin{ltxsyntax}
% \xLfmultipole{wdmcoupler}\cmditem{wdmcoupler}(LeftTop)(LeftBottom)(Right){Label}%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \wdmcoupler(0,1.5)(0,0.5)(3,1){WDM}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.2]{couplersize}
% \numitem[0.1]{couplersep} The vertical distance between the two input fiber ports.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \wdmcoupler[couplersep=0](0,1.5)(0,0.5)(3,1){WDM}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[elliptic]{couplertype}{none, elliptic, rectangular}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \psset{labeloffset=0.5}
  \wdmcoupler[couplertype=none](0,3)(0,2)(3,2.5){WDM}
  \wdmcoupler[couplertype=rectangular]%
               (0,1.5)(0,0.5)(3,1){WDM}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[center]{align}{top, bottom, center}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \psset{labeloffset=0.4}
  \wdmcoupler[align=top,
                couplertype=none](0,3)(0,2)(3,3){Top}
  \wdmcoupler[align=bottom]
               (0,1.5)(0,0.5)(3,0.5){Bottom}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \subsubsection{WDM Splitter}
% \begin{ltxsyntax}
% \xLfmultipole{wdmcoupler}\cmditem{wdmsplitter}(Left)(RightTop)(RightBottom){Label}%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \wdmsplitter(0,1)(3,1.5)(3,0.5){WDM}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.2]{couplersize}
% \numitem[0.1]{couplersep} The vertical distance between the two output fiber ports.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \wdmsplitter[couplersep=0](0,1)(3,1.5)(3,0.5){WDM}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[elliptic]{couplertype}{none, elliptic, rectangular}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \psset{labeloffset=0.5}
  \wdmsplitter[couplertype=none](0,2.5)(3,3)(3,2){WDM}
  \wdmsplitter[couplertype=rectangular]%
                 (0,1)(3,1.5)(3,0.5){Coupler}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[center]{align}{top, bottom, center}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \psset{labeloffset=0.4}
  \wdmsplitter[align=top,
                 couplertype=none](0,3)(3,3)(3,2){Top}
  \wdmsplitter[align=bottom](0,0.5)(3,1.5)(3,0.5){Bottom}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% 
% \section{Connecting Objects}\label{sec:connecting}
% 
% The package provides several methods for automatic beam and fiber
% drawing which are two fundamentally different way of connecting.
% 
% \subsection{Accessing Objects}\label{sec:namedobj}
% 
% The macro arguments, specified as Obj$_1$, Obj$_2$, \ldots Obj$_N$ in
% the following macro definitions, can be either objects or PSTricks
% nodes. To distinguish between named nodes (see \prettyref{sec:namedobj})
% and object names, the node content must be enclosed in parenthesis
% within the brackets. Components can either be assigned a name
% explicitely using the \Lkeyword{compname} parameter, or they get a
% unique number in ascending order by their definition in the code. If the
% argument is left empty, the last object is used.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \pnode(0,1){A}\pnode(1.5,1){B}
  \optbox[endbox, labeloffset=0](A)(B){1}
  % connect an object by its automatic number
  \drawbeam{(A)}{1}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}
\begin{pspicture}(3,2)
  \psset{endbox, labeloffset=0}
  \optbox[compname=obj](0,1)(1.5,1){obj}
  % connect an object by its compname
  \drawbeam{(0,1)}{obj}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \medskip
% 
% The objects which have an explicit \Lkeyword{compname} also increase the internal
% counter, so that removing the \nxLkeyword{compname} from an intermediate
% object does not affect the numbering of the following ones.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psset{endbox, labeloffset=0}
  \optbox[compname=obj](0,0.5)(1.5,0.5){obj}
  \optbox(0,1.5)(1.5,1.5){2}
  % named objects are also numbered
  \drawbeam{(0,1)}{2}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}
\begin{pspicture}(3,2)
  \psset{endbox, labeloffset=0}
  \optbox(0,0.5)(1.5,0.5){1}
  \optbox(0,1.5)(1.5,1.5){2}
  % an empty argument refers to the last object
  \drawbeam{(0,1)}{}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \subsection{Drawing beams}\label{sec:drawbeam}
% 
% \begin{ltxsyntax}
%   \xLcs{drawbeam}\cmditem{drawbeam}[Options]{Obj$_1$}{Obj$_2$}{\ldots}{Obj$_N$}
%   \xLcs{drawwidebeam}\cmditem{drawwidebeam}[Options]{Obj$_1$}{Obj$_2$}{\ldots}{Obj$_N$}
% \end{ltxsyntax}
% The package provides two macros for connecting objects with beams. Most
% parameters are valid for both, those which are specified for wide beams
% are demonstrated separately in the next section.
% 
% \begin{optionlist}
%   \optitem[0]{startpos}{[\prm{X}] \prm{Y}} This is the start position
%   (\prm{X}, \prm{Y}) of the beam at the first interface. Can be any code
%   which evaluates in Postscript to one or two numbers. If is only one
%   number then the $x$-coordinate is set to \texttt{0}.
% 
% \medskip
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(4,2.8)
  \pnode(1.5,0.5){A}\pnode(3.5,0.5){B}
  \pnode(3.5,2.5){C} 
  \optbox[endbox](B)(A){}
  \psset{mirrortype=extended, mirrordepth=0.15}
  \mirror[mirrorradius=2](A)(B)(C){} 
  \mirror(B)(C)(B){} 
  \drawbeam[linecolor=red, 
              startpos=-0.2]{1}{2}{3}
  \drawbeam[linecolor=blue]{1}{2}{3}
  \drawbeam[linecolor=green,
              startpos=0.2]{1}{2}{3}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem[0]{beamangle}
% This is the start angle of the beam and can by anything which evaluates to a number in Postscript.
% The \nxLkeyword{beamangle} is relative to the connection between the first
% two components, use \Lkeyword{beamangleabs} to change this.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(4,3)
  \pnode(1.5,0.5){A}\pnode(3.5,0.5){B}
  \pnode(3.5,2.5){C} 
  \psset{mirrortype=extended, mirrordepth=0.15}
  \optbox[endbox](B)(A){}
  \mirror(A)(B)(C){} 
  \mirror(B)(C)(B){} 
  \drawbeam[linecolor=red, 
              beamangle=3]{1}{2}{3}
  \drawbeam[linecolor=blue]{1}{2}{3}
  \drawbeam[linecolor=green, 
              beamangle=-3]{1}{2}{3}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \boolitem[false]{beamangleabs}
% 
% \boolitem[false]{connectplanes}
% 
% \numitem[1.5]{n}
% 
% \boolitem[false]{beaminside}
% 
% \boolitem[false]{beaminsidelast}
% 
% \boolitem[false]{beaminsidefirst}
% \end{optionlist}
% 
% \subsubsection{Internal component structure}
% 
% In order to understand properly how the automatic beam drawing actually works,
% it is necessary to describe in more detail the internal component structure.
% 
% Every component type consists internally of interfaces which are defined by a
% node on the optical axis, a plane vector or a curvature radius, and by its
% optical characteristic (reflective or transmittive). The interface nodes can be
% visualized for each component type with the \Lkeyword{showifcnodes}
% parameter. 
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(4,3)
  \psset{showifcnodes}
  \optbox(0,2.5)(4,2.5){}
  \doveprism(0,1.5)(4,1.5){}
  \lens(0,0.5)(4,0.5){}
  \mirror(0,0.5)(3.5,0.5)(3.5,3){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \medskip
% 
% \nxLcs{draw*beam} calculates the distance between the interface nodes of two
% objects and connects the two nearest
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(-2,-2)(2,2)
  \psset{optboxwidth=0.6, optboxheight=0.5, labeloffset=0}
  \multido{\i=0+60,\ii=1+1}{6}{%
    \pnode(1.75;\i){A}
    \optbox([Xnodesep=-1]A)([Xnodesep=1]A){\ii}
  }
  \optbox[compname=ref](-1,0)(1,0){ref}
  \addtopsstyle{Beam}{arrows=->}
  \multido{\i=1+1}{6}{\drawbeam{ref}{\i}}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \subsection{Drawing wide beams}\label{sec:drawwidebeam}
% 
% \begin{optionlist}
% \numitem[0.1]{beamwidth}
% 
% \numitem[0]{beamdiv}
% \end{optionlist}
% 
% \subsection{Drawing fibers}\label{sec:drawfiber}
% 
% Fiber-optical objects are automatically connected to the reference
% nodes. The style of all fiber connections can be configured
% independently (see Sec.~\ref{sec:fiberstyles}).
%
% This works quiet well if the components are aligned serially, but ceases to
% give good result for more complicated situations. In that case single or all
% fiber can be omitted and drawn separately.
%
% \subsubsection{Automatic fiber connections}\label{sec:drawfiber-auto}
%
% All fiber-optical components described in \prettyref{sec:fibercomp} are
% connected automatically to their reference nodes with \Lcs{pccurve}. The
% styles of the fiber connections can be configured independently by the
% styles shown in \prettyref{fig:style-inheritance}.
%
% \begin{figure}\centering
% \begin{pspicture}(10,4.4)
% \rput[lt](0,4.4){%
%   \pstree[levelsep=1.5cm, treesep=0.4, 
%           nodesep=5pt, arrows=<-, 
%           arrowinset=0, arrowscale=1.5]{\poeTR{Fiber}}{%
%     \pstree{\poeTR{FiberIn}}{%
%       \poeTR{FiberIn1} \poeTR{FiberIn2}%
%     }%
%     \pstree{\poeTR{FiberOut}}{%
%       \poeTR{FiberOut1} \poeTR{FiberOut2}%
%     }%
%   }%
%   \rput[l](-1,0|T-0){parent style}
%   \rput[l](-1,0|T-0-0){\parbox{\widthof{outgoing fibers}}{\RaggedRight incoming and outgoing fibers}}
%   \rput[t](! \psGetNodeCenter{T-0-0-0} \psGetNodeCenter{T-0-0-1}
%      T-0-0-0.x T-0-0-1.x add 2 div T-0-0-0.y 0.4 sub){%
%      \parbox{3.8cm}{\RaggedRight Upper(1) or lower(2) incoming fiber.}}
%   \rput[t](! \psGetNodeCenter{T-0-1-0} \psGetNodeCenter{T-0-1-1}
%      T-0-1-0.x T-0-1-1.x add 2 div T-0-1-0.y 0.4 sub){%
%      \parbox{3.8cm}{\RaggedRight Upper(1) or lower(2) outgoing fiber.}}%
% }%
% \end{pspicture}
% \caption{Inheritance diagram for the psstyles used for the automatic fiber
%   connections. These styles should be changed with \protect\Lcs{addtopsstyle} to preserve
%   the inheritance.}\label{fig:style-inheritance}
% \xLstyle{Fiber}\xLstyle{FiberIn}\xLstyle{FiberIn1}\xLstyle{FiberIn2}
% \xLstyle{FiberOut}\xLstyle{FiberOut1}\xLstyle{FiberOut2}
% \end{figure}
%
% \begin{optionlist}
% \item[\smash{\begin{tabular}[t]{@{}r}\opt{new}\prm{style}\\\opt{addto}\prm{style}\end{tabular}}]
%   \xLkeyword{newFiber}\xLkeyword{addtoFiber}
%   \xLkeyword{newFiberIn}\xLkeyword{addtoFiberIn}
%   \xLkeyword{newFiberIn1}\xLkeyword{addtoFiberIn1}
%   \xLkeyword{newFiberIn2}\xLkeyword{addtoFiberIn2}
%   \xLkeyword{newFiberOut}\xLkeyword{addtoFiberOut}
%   \xLkeyword{newFiberOut1}\xLkeyword{addtoFiberOut1}
%   \xLkeyword{newFiberOut2}\xLkeyword{addtoFiberOut2} For every style two
%   appropriate keys \opt{new}\prm{style} and \opt{addto}\prm{style} are
%   provided which can be used to change the styles for only one object. This
%   can be used to define own components with respectively changed fiber
%   connections or to avoid grouping.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
   \newpsobject{tapcoupler}{wdmsplitter}{%
     align=bottom, addtoFiberOut1={arrows=->, arrowscale=1.2, arrowinset=0}
   }
   \tapcoupler(0,0.5)(3,1.5)(3,0.5){99/1}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%   \boolitem{fiber} Some components can be used either for free-ray or
%   fiber-optical setups (\Lcs{optbox}, \Lcs{optdetector}). The \opt{fiber}
%   parameter enables automatic fiber connections for them.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \addtopsstyle{FiberIn}{ArrowInside=->, 
                           arrowscale=1.5,
                           arrowinset=0}
  \optbox[fiber](0,1)(3,1){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%   \boolitem{nofiber} Do not draw any automatic fiber connection. Is equivalent
%   to \opt{fiberin=none} and \opt{fiberout=none}.
%
%   \choitem[all]{fiberin}{none, top, bottom, all} Choose which input fiber
%   connections to draw automatically. The values \opt{top} and \opt{bottom}
%   affect only \Lcs{optcoupler} and \Lcs{wdmcoupler}.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optcoupler[fiberin=top](0,2)(0,0)(3,2)(3,0){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%   \choitem[all]{fiberout}{none, top, bottom, all} Choose which output fiber
%   connections to draw automatically. The values \opt{top} and \opt{bottom}
%   affect only \Lcs{optcoupler} and \Lcs{wdmsplitter}.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \wdmsplitter[fiberout=bottom](0,1)(3,2)(3,0){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \minisec{Fiber angles}
%
% The angles of the fiber connections are calculated automatically from the
% orientation of the component. The automatic connections are a special case of
% \Lcs{drawfiber} from a node to a component, see
% \prettyref{sec:drawfiber-manual} for detail.
% 
% \subsubsection{Manual fiber connections}\label{sec:drawfiber-manual}
%
% \begin{ltxsyntax}
%   \xLcs{drawfiber}\cmditem{drawfiber}[Options]{Obj$_1$}{Obj$_2$}
% \end{ltxsyntax}
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, linerange={1,2,9-11}]
\begin{pspicture}(-1,0)(7,2.4)
  \optbox[fiber, angle=20, rotateref=bl](0,1)(6,1){}
  \psdot(\oenodeRefA{})\uput[180](\oenodeRefA{}){RefA}%
  \psdot(\oenodeRefB{})\uput[0](\oenodeRefB{}){RefB}%
  \psdot(\oenodeRotref{})\uput[-90](\oenodeRotref{}){Rotref}%
  \psdot(\oenodeTrefA{})\uput[180](\oenodeTrefA{}){TrefA}%
  \psdot(\oenodeTrefB{})\uput[0](\oenodeTrefB{}){TrefB}%
  \uput{0.5}[180](\oenodeTrefB{}){\textcolor{black!30}{reference line}}%
  \psline[linecolor=black!30, 
            linestyle=dashed](\oenodeTrefA{})(\oenodeTrefB{})
  \end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, explpreset={linerange={1,2,9-11}}]
\begin{pspicture}[showgrid=true](-1,-0.1)(7,3.2)
  \optbox[fiber, angle=-30, rotateref=t, compshift=0.5](0,1)(6,1){}
  \psdot(\oenodeRefA{})\uput[180](\oenodeRefA{}){RefA}%
  \psdot(\oenodeRefB{})\uput[0](\oenodeRefB{}){RefB}%
  \psdot(\oenodeRotref{})\uput[60](\oenodeRotref{}){Rotref}%
  \psdot(\oenodeTrefA{})\uput[180](\oenodeTrefA{}){TrefA}%
  \psdot(\oenodeTrefB{})\uput[0](\oenodeTrefB{}){TrefB}%
  \uput{0.5}[180](\oenodeTrefB{}){\textcolor{black!30}{reference line}}%
  \psline[linecolor=black!30, 
            linestyle=dashed](\oenodeTrefA{})(\oenodeTrefB{})
  \end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optbox[angle=20, fiber](0,1)(3,1){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optbox[compshift=0.5, fiber](0,1)(3,1){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \begin{optionlist}
%   \boolitem{relangle}
%   \choitem{startnode}{auto, 1, 2, 3, 4, N}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(4,3)
  \pnode(0,0.5){A}\pnode(2,0.5){B}
  \pnode([offset=1]B){C}\pnode(A|C){D}
  \optamp[nofiber](A)(B){EDFA}
  \optbox(C)(D){PM}
  \drawfiber[linecolor=black]{1}{2}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem{stopnode}{auto, 1, 2, 3, 4, N}
% \end{optionlist}
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(2.1,3)
\pnode(0,0){A}\pnode(2,0){B}
\pnode(0.3,3){C}\pnode(1.7,3){D}
\optcoupler[fiberout=none,
            addtoFiberIn1={angleA=0, ArrowInside=->},
            addtoFiberIn2={angleA=180, arrows=<-},
            abspos=0.5, compname=Cpl](A)(B)(C)(D){}
\optfiber[nofiber, compname=Hnlf, abspos=1](C)(C|A){}
\optamp[nofiber, abspos=2, compname=Amp](D|B)(D){}
\drawfiber{Cpl}{Hnlf}
\drawfiber[startnode=1, stopnode=N, ncurv=1.2]{Hnlf}{Amp}
\drawfiber{Cpl}{Amp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \subsection{Custom beams}\label{sec:custombeam}
% \begin{ltxsyntax}
%   \xLcs{custombeam}\cmditem{custombeam}[Options]{\nxLcs{draw*beam}}
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \boolitem[false]{startinside}
% 
% \boolitem[false]{stopinside}
% \end{optionlist}
% 
% 
% \section{Defining New Objects}
% 
% \subsection{Customized Versions of Existing Macros}
% 
% The easiest way to define your own components is to use the
% \Lcs{newpsobject} macro. With this you can define a new component using
% predefined objects with a set of options. These options serve only as
% default values and can be overridden when calling the macro. The
% following examples defines a new object \nxLcs{sbn} for the special crystal
% used in Sec.~\ref{sec:crystal}.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[width=3.5cm]
\newpsobject{sbn}{crystal}{voltage, lamp, labelangle=45, labeloffset=1.2, fillstyle=solid, fillcolor=yellow!90!black}
\begin{pspicture}[showgrid=true](3,2) 
   \sbn(0,1)(3,1){SBN:Ce}
   \psline[style=Beam](0,1)(3,1)
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}[width=3.5cm]
\newpsobject{pumpcoupler}{wdmcoupler}{align=top, labelangle=180, labeloffset=0.5,addtoFiberIn2={ArrowInside=->, arrowscale=2}}
\begin{pspicture}[showgrid=true](3,2) 
   \pumpcoupler(0,1)(0,0)(3,1){Pumpcoupler}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \medskip
% 
% Or if you need more than one type of lenses several times in your setup
% it is very cumbersome to specify all parameters every time.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[width=5.5cm]
\newpsobject{MOLensIn}{lens}{lens=0.5 0.5 0.5}
\newpsobject{MOLensOut}{lens}{lens=1.5 1.5 1.5}
\begin{pspicture}[showgrid=true](5,2) 
   \pnode(0,1){A}\pnode(5,1){B}
   \psset{n=1}
   \MOLensIn[abspos=0.5](A)(B){}
   \MOLensOut[abspos=1](A)(B){}
   \MOLensOut[abspos=4](A)(B){}
   \MOLensIn[abspos=4.5](A)(B){}
   \custombeam{%
     \drawwidebeam[beamwidth=0.1]{(A)}{1}
     \drawwidebeam[beamdiv=1]{1}{2}
   }
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \subsection{Defining New Objects}\label{sec:newobj}
% 
% Since version 1.2 \nxLPack{pst-optexp} provides some high-level macros to
% allow very convenient definition of completely new components. The macro
% \Lcs{newOptexpDipole} generates all organizing code for a new free-ray
% component. All you have to do is to define a new `drawing' macro
% \nxLcs{mycomponent@iii} which contains all drawing code. Analogously
% \Lcs{newOptexpDipoleNolabel} defines a new free-ray object without label
% (like \Lcs{polarization}) and \Lcs{newOptexpTripole} defines a new
% reflective component. 
% 
% New fiber-optical components can be defined using
% \Lcs{newOptexpFiberDipole}. This macro differs from its free-ray
% analogous only in that it presets \Lkeyword{fiber} and hence directly
% connects the component with its reference nodes. The first node in the
% parameter list gets connected with a node \nodename{tempNode@A@}, the
% second node with a node \nodename{tempNode@B@}. These two internal
% nodes are preset to \paramvalue{(0,0)} and can be overwritten within the
% drawing macro.
% 
% The syntax of the macros is
% \begin{lstlisting}[gobble=2]
% \newOptexpDipole[fixed options]{name}{default options}
% \newOptexpDipoleNolabel[fixed options]{name}{default options}
% \newOptexpTripole[fixed options]{name}{default options}
% \newOptexpFiberDipole[fixed options]{name}{default options}
% \end{lstlisting}
% The \texttt{default options} are simply a list of PSTricks parameters
% which are taken as defaults for the new component. The optional argument
% allows setting of parameters which cannot be overridden later.
% 
% This is illustrate a bit more in the next code snippet, which also shows
% how the coordinate system is handled within the \nxLcs{mycomponent@iii}
% macro.
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\newOptexpTripole{mygrid}{%
  subgriddiv=5, griddots=0, 
  subgridwidth=\pslinewidth, gridwidth=2\pslinewidth}
\makeatletter
\def\mygrid@comp{% put here all PSTricks drawing code
  \psgrid(-1,0)(1,1)
}%
\makeatother
\begin{pspicture}(3,3.7) 
   \mygrid[gridcolor=red,
             labeloffset=1.5](0,1)(2,1.7)(3,0){myGrid}
   \drawbeam{(0,1)}{1}{(3,0)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \medskip
% 
% The default position of the label reference point is (0,0). If you want
% to change this, you have to define a new pnode named
% \nodename{tempNode@Label} in the \nxLcs{mycomponent@iii} macro.
% 
% If you create a new component, please send it to me then I can
% incorporate this in a new released version.
% 
% \newpage
% 
% \section{Examples}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t,vsep=8mm]
\begin{pspicture}(10,2)
\psset{optboxwidth=1}\addtopsstyle{Beam}{linewidth=2\pslinewidth}
\pnode(1,1){Start}\pnode(9,1){CCD}\optbox[endbox, labeloffset=0](CCD)(Start){Laser}
\optbox[endbox,labeloffset=0,beam](Start)(CCD){CCD}
\polarization[poltype=perp,abspos=0.5](Start)(CCD)
\optretplate[abspos=1](Start)(CCD){$\nicefrac{\lambda}{2}$}
\lens[lens=0.4 0.4 0.5,abspos=2](Start)(CCD){$L_1$}\lens[abspos=4](Start)(CCD){$L_2$}
\optplate[abspos=6,platelinewidth=3\pslinewidth](Start)(CCD){SLM}
\optplate[abspos=6.5,labelangle=180](Start)(CCD){PF}
\polarization[abspos=6.7](Start)(CCD)\lens[abspos=7](Start)(CCD){$L_3$}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \vspace{\fill}
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t,vsep=8mm]
\begin{pspicture}(-4,-1)(3,3)
\psset{labeloffset=0.5}
\pnode(-2,0){LOut}\pnode(0,0){Grat}\pnode(4;45){Out}\pnode(2.5;70){Mvar}
\newpsstyle{Beam}{linewidth=2\pslinewidth, linecolor=red!90!black}
\begin{optexp}
  \optbox[optboxwidth=2, labeloffset=0, endbox](Grat)(LOut){diode laser}
  \mirror[variable](Grat)(Mvar)(Grat){M$_\mathrm{var}$}
  \optretplate[position=0.3, labeloffset=0.8]%
    (LOut)(Grat){$\nicefrac{\lambda}{4}$}
  \optgrating(LOut)(Grat)(Out){grating}
  \drawbeam[arrows=->]{1}{3}{4}{(Out)}
  \drawbeam{2}{4}
\end{optexp}
\rput[l](-3,2){Littman setup}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, vsep=8mm]
\begin{pspicture}(8.5,1.6)
    \addtopsstyle{Beam}{linecolor=green!90!black}
    \pnode(1.6,1){Laser}\pnode(7.6,1){Diode}
    \optbox[endbox,labeloffset=0](Diode)(Laser){Laser}%
%    \optbox[abspos=4, optboxwidth=1, optboxheight=0.6, labeloffset=1, compname=PC, conn=o-, angle=-10, rotateref=l, refractiveindex=2.3](Laser)(Diode){Photonic Crystal}
%    \optdetector[dettype=diode, conn=o-](\oenodeOut{PC})(Diode|\oenodeOut{PC}){PD}
    \optbox[abspos=4, optboxwidth=1, optboxheight=0.6, labeloffset=1, compname=PC, angle=-10, rotateref=l, refractiveindex=2.3](Laser)(Diode){Photonic Crystal}
    \optdetector[dettype=diode](\oenodeOut{PC})(Diode|\oenodeOut{PC}){PD}
    \nodexn{(\oenodeIn{PC}) + (2;170)}{Angle1}
    \psline[linestyle=dashed](\oenodeIn{PC})(Angle1)
    \psarc{<->}(\oenodeIn{PC}){1.3}{330}{30}
    \psarc[arcsep=1pt]{<->}(\oenodeIn{PC}){2}{170}{180}
    \uput{2.1}[175](\oenodeIn{PC}){\small $\varphi$}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, vsep=8mm]
\begin{pspicture}(6.4,3.2)
  \addtopsstyle{Fiber}{linecolor=red}
  \pnode(2.3,2.3){Lin}\pnode([Xnodesep=0.5]Lin){Lout}
  \pnode([Xnodesep=1.5]Lout){EAMout}
  \pnode([Xnodesep=1.5]EAMout){Det}
  \optbox[fiber, label=-0.2, endbox, compname=L, extnode=b](Lout)(Lin){%
    \psGauss[yunit=0.03,sigma=0.03]{-0.5}{0.5}}
  \optbox[fiber, label=0, optboxwidth=1, compname=EAM, extnode=b](Lout)(EAMout){EAM}
  \optfiber[labeloffset=0.3](EAMout)(Det){fibre}
  \optdetector(EAMout)(Det){OSA}
  \pnode([Xnodesep=-1,offset=-1]\oenodeExt{L}){Osc}
  \pnode(\oenodeExt{L}|Osc){PSin}\pnode(\oenodeExt{EAM}|Osc){PSout}
  \oscillator[output=right](Osc){10\,GHz}{}
  \phaseshifter[arrowscale=1.5, inputarrow, labeloffset=-0.7](PSin)(PSout){$\tau$}
  \psset{arrows=->, arrowinset=0, arrowscale=1.5}
  \wire(PSin)(\oenodeExt{L})
  \wire(PSout)(\oenodeExt{EAM})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, vsep=5mm]
\begin{pspicture}(0.9,0.9)(10.4,5.9)
  \psset{arrowscale=1.5, arrowinset=0}
  \pnode(2,5){PC1in}\pnode(4,5){PC1out}\pnode(6,5){PC2in}
  \pnode(8,5){PC2out}\pnode(2,2){CplSig}\pnode(5,2){CplIn}
  \pnode(2,1){CplOut}\pnode(10,4.5){Pump}\pnode(8,2){PumpSig}
  \optisolator[compshift=0.8, addtoFiberIn={angleA=180}, 
                 addtoFiberOut={angleB=180}, label=0.5 . l]%
                 (CplSig)(PC1in){isolator}
  \polcontrol[addtoFiberIn={arrows=|-}](PC1in)(PC1out){}
  \optfiberpolarizer[labeloffset=0.6](PC1out)(PC2in){polarizer}
  \polcontrol[addtoFiberOut={arrows=-|}](PC2in)(PC2out){}
  \wdmsplitter[labeloffset=0.3, align=bottom, addtoFiberIn={arrows=|-}, 
                 addtoFiberOut1={arrows=->}, addtoFiberOut2={arrows=-|}]%
                 (CplIn)(CplOut)(CplSig){95/5}
  \wdmcoupler[addtoFiberIn1={ArrowInside=->}, addtoFiberIn2={angleA=0}, 
                addtoFiberOut={angleB=0,arrows=-|}, ncurv=0.9, 
                align=bottom, compshift=0.8](Pump)(PC2out)(PumpSig){Pump}
  \optbox[endbox, label=0 . . relative]([offset=-0.1]Pump)(Pump){980~nm}
  \optfiber[fiberloops=2, labeloffset=0.4](CplIn)(PumpSig){Er$^+$-doped}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, vsep=8mm]
\makeatletter
\def\LCLV@nodes{%
  \newOptexpComp{ {-0.12 0} {0 1} trans {NewPlaneInt}
                  {0.15 0} {0 1} trans {NewPlaneInt} \POE@key@n}%
}%
\def\LCLV@comp{%
  \psframe[fillstyle=solid,fillcolor=black,dimen=outer](-0.12,-0.5)(0,0.5)
  \psframe[fillstyle=solid,fillcolor=gray!50,dimen=outer](0,-0.5)(0.15,0.5)
}%
\makeatother
\begin{pspicture}(9,5)
\newOptexpDipole{LCLV}{}\psset{lens=1.2 0 1}
\pnode(2.4,1){BS1}\pnode([offset=3]BS1){M1}\pnode([Xnodesep=5.5]M1){PP}\pnode(PP|BS1){BS2}
\LCLV[position=0.2, compname=LCLV](BS1)(BS2){LCLV}\beamsplitter[compname=BS](BS2)(BS1)(M1){BS}
\optretplate(BS1)(M1){P}\mirror(BS1)(M1)(PP){M}\lens[position=0.2](M1)(PP){L}
\pinhole(M1)(PP){}\lens[position=0.2](PP)(M1){L}\pentaprism(M1)(PP)(BS2){PP}
\beamsplitter(PP)(BS2)(BS1){BS}\lens(BS2)(BS1){L}
\doveprism[compname=Dove,position=0.27](BS2)(BS1){D}
\addtopsstyle{Beam}{arrowscale=1.3, ArrowInside=-<}
\optbox[labeloffset=0, endbox](BS1)([Xnodesep=-1]BS1){Nd:YAG}
\drawbeam{LCLV}{BS}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \begin{pspicture}(0,-0.4)(9,6)
%   \addtopsstyle{Beam}{linewidth=2\pslinewidth}
%   \pnode(1.5,5){Laser}\pnode(4,5){PBS}\pnode(6.5,5){PBS2}
%   \pnode(6.5,5.7){piezo}\pnode(4,2){BSFwd}\pnode(6.5,2){BSBwd}
%   \pnode(2,2){BS4f}\pnode(2,0.5){M4f3}\pnode(8,2){M4f1}
%   \pnode(8,0.5){M4f2}\pnode(1,2){CCD}
%   \psline[style=Beam](Laser)(PBS2)(piezo)(BSBwd)(M4f1)(M4f2)(M4f3)(BS4f)(CCD)
%   \psline[style=Beam](PBS)(BSFwd)(BS4f)
%   \psset{mirrorwidth=0.6, plateheight=0.7, outerheight=0.7, labeloffset=0.7, labelstyle=\scriptsize, lens=1.2 1.2 0.8, bssize=0.5} 
%   \optbox[endbox,optboxwidth=1.5, optboxheight=0.7,labeloffset=0]%
%      (PBS)(Laser){\parbox{1.5cm}{\centering Nd:YAG\\ 532\,nm}}
%   \lens[lensheight=0.5, position=0.2](Laser)(PBS){MO}
%   \pinhole[position=0.3,labelangle=180](Laser)(PBS){PH}
%   \lens[position=0.5](Laser)(PBS){L}
%   \optretplate[position=0.8](Laser)(PBS){$\nicefrac{\lambda}{2}$}
%   \beamsplitter(Laser)(PBS)(BSFwd){PBS}
%   \optretplate[position=0.4](PBS)(BSFwd){$\nicefrac{\lambda}{2}$}
%   \polarization(PBS)(BSFwd)\polarization(PBS2)(BSBwd)
%   \lens[position=0.8](PBS)(BSFwd){L}
%   \optretplate(PBS)(PBS2){$\nicefrac{\lambda}{2}$}
%   \beamsplitter(PBS)(PBS2)(piezo){PBS}
%   \optretplate[abspos=0.5](PBS2)(piezo){$\nicefrac{\lambda}{4}$}
%   \mirror[mirrortype=piezo,labelangle=90](PBS2)(piezo)(PBS2){PZ}
%   \lens[position=0.8,labelangle=180](PBS2)(BSBwd){L}
%   \crystal[crystalwidth=1, crystalheight=0.5, voltage, lamp, fillstyle=solid, fillcolor=yellow!90!black, labeloffset=0.8, beam](BSFwd)(BSBwd){SBN:Ce}
%   \beamsplitter(PBS)(BSFwd)(BSBwd){BS}
%   \beamsplitter[labelangle=-90](PBS2)(BSBwd)(BSFwd){BS}
%   \mirror(BSBwd)(M4f1)(M4f2){M}\mirror(M4f1)(M4f2)(M4f3){M}
%   \lens[labelangle=180](M4f2)(M4f3){L}\mirror(M4f2)(M4f3)(BS4f){M}
%   \beamsplitter(M4f3)(BS4f)(CCD){BS}\optbox[endbox,labeloffset=0, optboxwidth=1](BS4f)(CCD){CCD}
%   \lens[abspos=0.7](BS4f)(BSFwd){L}\lens[abspos=0.7](BSBwd)(M4f1){L}
% \end{pspicture}
% 
% \psset{unit=0.8cm,labelstyle=\footnotesize}
% \begin{pspicture}(0.5,4)(13.2,10.5)
%   \addtopsstyle{Fiber}{linecolor=red!90!black}\psset{usefiberstyle, optboxwidth=1}
%   \pnode(2,10){LD}\pnode([Xnodesep=5.5]LD){CPLin1}
%   \pnode([offset=-2]CPLin1){CPLin2}\pnode([Xnodesep=1.5]CPLin1){CPLout1}
%   \pnode([Xnodesep=1.5]CPLin2){CPLout2}
%   \optbox[endbox, labeloffset=0, fiber]([Xnodesep=0.1]LD)(LD){LD}
%   \optmzm([Xnodesep=0.1]LD)([Xnodesep=1.5]LD){MZM}
%   \optamp([Xnodesep=1.5]LD)([Xnodesep=2.5]LD){EDFA}
%   \optfilter([Xnodesep=2.5]LD)([Xnodesep=3.5]LD){BPF}
%   \optswitch([Xnodesep=3.5]LD)([Xnodesep=4.5]LD){SW}
%   \polcontrol([Xnodesep=4.5]LD)(CPLin1){}
%   \optcoupler[couplertype=none](CPLin1)(CPLin2)(CPLout1)(CPLout2){}
%   \optamp(CPLout1)([Xnodesep=1.5]CPLout1){EDFA}
%   \optfilter([Xnodesep=1.5]CPLout1)([Xnodesep=3]CPLout1){BPF}
%   \pnode([Xnodesep=2]CPLout2){LoopRU}\pnode([offset=-3.5]LoopRU){LoopRL}
%   \pnode([Xnodesep=-5]CPLin2){LoopLU}\pnode([offset=-3.5]LoopLU){LoopLL}
%   \optamp(CPLout2)(LoopRU){EDFA}
%   \psline[linearc=1,style=Fiber](LoopRU)([Xnodesep=1]LoopRU)([Xnodesep=1,offset=-2]LoopRU)
%   \psline[linearc=1,style=Fiber]([Xnodesep=1,offset=1.5]LoopRL)%
%                                 ([Xnodesep=1]LoopRL)(LoopRL)
%   \optfiber[labelalign=b, labeloffset=-1, position=0.8]([Xnodesep=-2]LoopRL)(LoopRL){\begin{tabular}{c}conventional\\fibre 89.8~km\end{tabular}}
%   \optamp([Xnodesep=-2]LoopRL)([Xnodesep=-3]LoopRL){EDFA}
%   \optfilter([Xnodesep=-3]LoopRL)([Xnodesep=-4.5]LoopRL){BPF}
%   \optfiber[fiberloops=1, labeloffset=-1, labelalign=b]([Xnodesep=-7]LoopRL)([Xnodesep=-4.5]LoopRL){DCF 16.2~km}
%   \optamp([Xnodesep=1.5]LoopLL)(LoopLL){EDFA}
%   \psline[style=Fiber,linearc=1](LoopLL)([Xnodesep=-1]LoopLL)%
%                                 ([Xnodesep=-1,offset=3.5]LoopLL)(LoopLU)
%   \optfilter(LoopLU)([Xnodesep=1.5]LoopLU){BPF}
%   \optswitch([Xnodesep=1.5]LoopLU)([Xnodesep=3.5]LoopLU){SW}
%   \polcontrol([Xnodesep=3.5]LoopLU)(CPLin2){}
% \end{pspicture}
% 
% \section{Todo}
% 
% \begin{itemize}
% \item Automatic sizing of optboxes (like a \Lcs{psframebox}
% \end{itemize}
% 
% \section{Acknowledgements}
% 
% I thank all the people of the PSTricks mailinglist for the continuous help, especially Herbert Vo\ss.
% 
% \section{Revision History}
% \begin{changelog}
%   \begin{release}{3.0}{NN}
%   \item Renamed options \opt{optgrid*} to \opt{grating*}. The
%   old options are still valid, but give a warning. This was a terminological
%   error from the beginning.
% \end{release}
%
% \begin{release}{1.1}{2007-09-06}
% \item Considerably enhanced labeling of the components.   Added new parameter \opt{labelref} which specifies the reference coordinate   system for the label positioning and the rotation of the label. Default is   \opt{labelref=relgrav}, the label point is rotated together with the   component, but the label text itself is not rotated.
% \item Parameter \opt{labelrelative} is now obsolete, and replaced by \opt{labelref=relative}. It will be removed in future versions.
% \end{release}
% 
% \begin{release}{1.0}{2007-07-18}
% \item First CTAN version
% \end{release}
%
% \end{changelog}
% 
% \makeatletter
% \bgroup
% \newcommand*{\index@preamble}{}
% \let\index@preamble=\relax
% \renewcommand{\setindexpreamble}[1]{\def\index@preamble{#1}}
% \renewcommand*{\idx@heading}{%
%   \twocolumn[\idx@@heading{\indexname}]%
%   \@mkboth{\indexname}{\indexname}%
% }
% \renewenvironment{theindex}{%
%   \if@twocolumn
%     \@restonecolfalse
%   \else
%     \@restonecoltrue
%   \fi
%   \columnseprule \z@
%   \columnsep 35\p@
%   \idx@heading%
%   \index@preamble\par\nobreak
%   \thispagestyle{\indexpagestyle}\parindent\z@
%   \setlength{\parskip}{\z@ \@plus .3\p@}%
%   \setlength{\parfillskip}{\z@ \@plus 1fil}%
%   \let\item\@idxitem
% }{%
%   \if@restonecol\onecolumn\else\clearpage\fi
% }
% \renewcommand*\@idxitem{\par\hangindent 40\p@}
% \renewcommand*\subitem{\@idxitem \hspace*{20\p@}}
% \renewcommand*\subsubitem{\@idxitem \hspace*{30\p@}}
% \renewcommand*\indexspace{%
%   \par \vskip 10\p@ \@plus5\p@ \@minus3\p@\relax
% }
% \renewcommand*\indexname{Index}
% \printindex[doc]
% \egroup
% \makeatother
%
% \StopEventually{}
%
% \section{Implementation}
%
%<*stylefile>
%    \begin{macrocode}
\RequirePackage{pstricks}
\RequirePackage{pst-xkey}
\RequirePackage{pst-node}
\RequirePackage{pst-plot}
\RequirePackage{multido}
\RequirePackage{pst-eucl}
\RequirePackage{pstricks-add}
\DeclareOption{compat}{\gdef\pstoptexp@compat{}}
\ProcessOptions\relax
\RequirePackage{environ}
  \long\def\POE@collect#1{%
    \psset{optexpenv, backlayer=true, frontlayer=false}#1%
    \gdef\POE@complist{}\global\POE@cnt=0\relax
    \psset{backlayer=false, frontlayer=true}%
    #1}%
\newenvironment{optexp}{\Collect@Body\POE@collect}{}
\IfFileExists{pst-optexp.pro}{\@addtofilelist{pst-optexp.pro}}{}%
%    \end{macrocode}
%
% \subsection{The Actual \TeX\ Implementation}
%    \begin{macrocode}
\csname PSToptexpLoaded\endcsname
\let\PSToptexpLoaded\endinput
\pst@addfams{optexp}
\pstheader{pst-optexp.pro}
\def\pst@optexpdict{tx@OptexpDict begin }
\def\POE@dict#1{\pst@optexpdict #1 end}
\SpecialCoor
%    \end{macrocode}
% IFs for the boolean keys.
%    \begin{macrocode}
\newif\ifPOE@compat\POE@compatfalse
\newif\ifPOE@connjoin
\newif\ifPOE@backlayer
\newif\ifPOE@frontlayer
\newif\ifPOE@optexpenv
\newif\ifPOE@variable
\newif\ifPOE@voltage
\newif\ifPOE@caxisinv
\newif\ifPOE@reverse
\newif\ifPOE@lamp
\newif\ifPOE@component@optional
\newif\ifPOE@debug@showoptdots
\newif\ifPOE@debug@showifcnodes
\newif\ifPOE@endbox
\newif\ifPOE@thicklens
\newif\ifPOE@usefiberstyle
\newif\ifPOE@fiber@
\newif\ifPOE@fiberin@
\newif\ifPOE@fiberin@top
\newif\ifPOE@fiberin@bottom
\newif\ifPOE@fiberout@
\newif\ifPOE@fiberout@top
\newif\ifPOE@fiberout@bottom
\newif\ifPOE@beam
\newif\ifPOE@startinside
\newif\ifPOE@stopinside
\newif\ifPOE@beaminsidefirst
\newif\ifPOE@beaminsidelast
\newif\ifPOE@beamangleabs
\newif\ifPOE@beaminside
\newif\ifPOE@connectplanes
\newif\ifPOE@custombeam\POE@custombeamfalse
\newif\ifPOE@insideobj\POE@insideobjfalse
%    \end{macrocode}
% count the components in a pspicture environment
%    \begin{macrocode}
\newcount\POE@cnt
%    \end{macrocode}
% count the temporal planes which are created for connections to nodes
%    \begin{macrocode}
\newcount\POE@nodecnt
%    \end{macrocode}
% Fixed strings for choicekeys.
%    \begin{macrocode}
\def\POE@str@pol@polperp{perp}
\def\POE@str@pol@polparallel{parallel}
\def\POE@str@pol@polmisc{misc}
\def\POE@str@pol@polrcirc{rcirc}
\def\POE@str@pol@pollcirc{lcirc}
\def\POE@str@mirrortype@piezo{piezo}
\def\POE@str@mirrortype@plain{plain}
\def\POE@str@mirrortype@extended{extended}
\def\POE@str@gratingtype@blazed{blazed}
\def\POE@str@gratingtype@binary{binary}
\def\POE@str@labelref@relative{relative}
\def\POE@str@labelref@relgrav{relgrav}
\def\POE@str@labelref@global{global}
\def\POE@str@filtertype@bandpass{bandpass}
\def\POE@str@filtertype@bandstop{bandstop}
\def\POE@str@filtertype@lowpass{lowpass}
\def\POE@str@filtertype@highpass{highpass}
\def\POE@str@couplertype@none{none}
\def\POE@str@couplertype@elliptic{elliptic}
\def\POE@str@couplertype@rectangular{rectangular}
\def\POE@str@couplertype@crossswitch{crossswitch}
\def\POE@str@top{top}
\def\POE@str@bottom{bottom}
\def\POE@str@center{center}
\def\POE@str@closed{closed}
\def\POE@str@opened{opened}
\def\POE@str@dettype@round{round}
\def\POE@str@dettype@diode{diode}
\def\POE@str@bsstyle@cube{cube}
\def\POE@str@bsstyle@plate{plate}
\def\POE@str@autonode{auto}
\def\pst@OptexpVerb#1{\pst@Verb{\pst@optexpdict #1 end }}%
%    \end{macrocode}
%
% Some strings which control the naming scheme of internal nodes and components.
%
% Default name stem for all internal nodes
%    \begin{macrocode}
\def\POE@str@basicname@default{@}
%    \end{macrocode}
% The nodes and component names are prefix with this string
%    \begin{macrocode}
\def\POE@str@basicname@prefix{OE@}
%    \end{macrocode}
% The postfix for external nodes
%    \begin{macrocode}
\def\POE@str@extnode@postfix{Ext}
%    \end{macrocode}
% 
% \subsubsection{Parameter and Style Definitions}
%    \begin{macrocode}
\newpsstyle{OptComp}{}%
\define@key[psset]{optexp}{newOptComp}{\newpsstyle{OptComp}{#1}}
\define@key[psset]{optexp}{addtoOptComp}{\addtopsstyle{OptComp}{#1}}
%    \end{macrocode}
% 
% Style for devices marked as 'optional', inherits from OptComp by default.
%    \begin{macrocode}
\newpsstyle{OptionalStyle}{style=OptComp, linestyle=dashed,dash=1.5pt 1pt}%
%    \end{macrocode}
% Style for beams drawn with \cs{drawbeam}
%    \begin{macrocode}
\newpsstyle{Beam}{linecolor=green!90!black,linewidth=\pslinewidth, linejoin=1}%
\define@key[psset]{optexp}{newBeam}{\newpsstyle{Beam}{#1}}
\define@key[psset]{optexp}{addtoBeam}{\addtopsstyle{Beam}{#1}}
%    \end{macrocode}
% Basic look of all fiber connections.
%    \begin{macrocode}
\newpsstyle{Fiber}{}%
\define@key[psset]{optexp}{newFiber}{\newpsstyle{Fiber}{#1}}
\define@key[psset]{optexp}{addtoFiber}{\addtopsstyle{Fiber}{#1}}
%    \end{macrocode}
% Input fiber connections, inherits from Fiber
%    \begin{macrocode}
\newpsstyle{FiberIn}{style=Fiber}%
\define@key[psset]{optexp}{newFiberIn}{\newpsstyle{FiberIn}{#1}}
\define@key[psset]{optexp}{addtoFiberIn}{\addtopsstyle{FiberIn}{#1}}
%    \end{macrocode}
% Output fiber connections, inherits from Fiber
%    \begin{macrocode}
\newpsstyle{FiberOut}{style=Fiber}%
\define@key[psset]{optexp}{newFiberOut}{\newpsstyle{FiberOut}{#1}}
\define@key[psset]{optexp}{addtoFiberOut}{\addtopsstyle{FiberOut}{#1}}
%    \end{macrocode}
% Used for upper (1) and lower (2) input fibers, if present. Inherits from FiberIn.
%    \begin{macrocode}
\newpsstyle{FiberIn1}{style=FiberIn}%
\define@key[psset]{optexp}{newFiberIn1}{\newpsstyle{FiberIn1}{#1}}
\define@key[psset]{optexp}{addtoFiberIn1}{\addtopsstyle{FiberIn1}{#1}}
\newpsstyle{FiberIn2}{style=FiberIn}%
\define@key[psset]{optexp}{newFiberIn2}{\newpsstyle{FiberIn2}{#1}}
\define@key[psset]{optexp}{addtoFiberIn2}{\addtopsstyle{FiberIn2}{#1}}
%    \end{macrocode}
% Used for upper (1) and lower (2) output fibers, if present. Inherits from FiberOut.
%    \begin{macrocode}
\newpsstyle{FiberOut1}{style=FiberOut}%
\define@key[psset]{optexp}{newFiberOut1}{\newpsstyle{FiberOut1}{#1}}
\define@key[psset]{optexp}{addtoFiberOut1}{\addtopsstyle{FiberOut1}{#1}}
\newpsstyle{FiberOut2}{style=FiberOut}%
\define@key[psset]{optexp}{newFiberOut2}{\newpsstyle{FiberOut2}{#1}}
\define@key[psset]{optexp}{addtoFiberOut2}{\addtopsstyle{FiberOut2}{#1}}
%    \end{macrocode}
% Special styles to change only a part of some devices.
%    \begin{macrocode}
\newpsstyle{ExtendedMirror}{linestyle=none,%
                hatchwidth=0.5\POE@key@mirrorlinewidth,
                hatchsep=1.4\POE@key@mirrorlinewidth,%
                fillstyle=hlines}%
\newpsstyle{VariableMirror}{linewidth=0.8\pslinewidth, arrowinset=0, arrowscale=0.8, arrows=<->}
\newpsstyle{PiezoMirror}{fillstyle=solid,fillcolor=black!30}%
\newpsstyle{IsolatorArrow}{linewidth=2\pslinewidth, arrowinset=0}
\newpsstyle{CrystalCaxis}{linestyle=dashed, dash=2pt 2pt, linewidth=0.7\pslinewidth, arrowinset=0, arrows=->}
\newpsstyle{FdlArrow}{arrowinset=0, arrows=->}
\newpsstyle{VariableCoupler}{arrowinset=0, arrows=->}
%    \end{macrocode}
%
% General parameters
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@component@]{optional}[true]{}
\define@boolkey[psset]{optexp}[POE@]{usefiberstyle}[true]{}
\define@boolkey[psset]{optexp}[POE@debug@]{showoptdots}[true]{}
\define@boolkey[psset]{optexp}[POE@debug@]{showifcnodes}[true]{}
\define@choicekey*[psset]{optexp}{namingscheme}[\val\nr]{old,new}[new]{%
  \ifcase\nr\relax
%    \end{macrocode}
% old naming scheme
%    \begin{macrocode}
    \edef\POE@str@basicname@default{tempNode}
    \edef\POE@str@basicname@prefix{}
    \edef\POE@str@extnode@postfix{ExtNode}
  \or
    \edef\POE@str@basicname@default{@}
    \edef\POE@str@basicname@prefix{OE@}
    \edef\POE@str@extnode@postfix{Ext}
  \fi
}%
\psset[optexp]{namingscheme=new}%
%    \end{macrocode}
% Positioning
%    \begin{macrocode}
\define@key[psset]{optexp}{position}{\edef\POE@key@position{#1}}
\define@key[psset]{optexp}{abspos}{\edef\POE@key@abspos{#1}}
\define@key[psset]{optexp}{compshift}{\pst@checknum{#1}\POE@key@compshift}
\define@key[psset]{optexp}{angle}{\pst@checknum{#1}\POE@key@angle}
\psset[optexp]{%
  position=\@empty,
  abspos=\@empty,
  compshift=0,
  angle=0
}%
%    \end{macrocode}
% Layering
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@]{backlayer}[true]{}
\define@boolkey[psset]{optexp}[POE@]{frontlayer}[true]{}
\define@boolkey[psset]{optexp}[POE@]{optexpenv}[true]{}
\psset[optexp]{backlayer, frontlayer, optexpenv=false}%
%    \end{macrocode}
% Label
%    \begin{macrocode}
\define@key[psset]{optexp}{labelangle}{\pst@checknum{#1}\POE@key@labelangle}
\define@key[psset]{optexp}{labeloffset}{\pst@checknum{#1}\POE@key@labeloffset}
\define@key[psset]{optexp}{labelstyle}{\def\POE@key@labelstyle{#1}}
\define@key[psset]{optexp}{labelalign}{\def\POE@key@labelalign{#1}}
\define@key[psset]{optexp}{labelref}{\edef\POE@key@labelref{#1}}
\define@key[psset]{optexp}{label}{%
  \pst@expandafter\psset@@label{#1} {} {} {} {} {}\@nil
}%
%    \end{macrocode}
% parameters: offset angle align ref, intermediate ones can be skipped with a dot
%    \begin{macrocode}
\def\psset@@label#1 #2 #3 #4 #5\@nil{%
  \edef\POE@dot{.}%
  \edef\pst@temp{#4}%
  \ifx\pst@temp\@empty\else
    \ifx\pst@temp\POE@dot\else
      \psset{labelref=#4}%
    \fi
  \fi
  \edef\pst@temp{#3}
  \ifx\pst@temp\@empty\else
    \ifx\pst@temp\POE@dot\else
      \psset{labelalign=#3}%
    \fi
  \fi
  \edef\pst@temp{#2}%
  \ifx\pst@temp\@empty\else
    \ifx\pst@temp\POE@dot\else
      \psset{labelangle=#2}%
    \fi
  \fi
  \edef\pst@temp{#1}%
  \ifx\pst@temp\@empty\else
    \ifx\pst@temp\POE@dot\else
      \psset{labeloffset=#1}%
    \fi
  \fi
}%
%    \end{macrocode}
% for internal use only! Set the reference angle for the labelangle parameter.
%    \begin{macrocode}
\define@key[psset]{optexp}{ref@angle}{\pst@checknum{#1}\POE@key@labelrefangle}%
\psset[optexp]{%
  labeloffset=0.8,
  labelangle=0,
  labelstyle=\small,
  labelalign=c,
  labelref=relgrav,
  ref@angle=0
}%
\define@key[psset]{optexp}{lensheight}{\pst@checknum{#1}\POE@key@lensheight}
\define@key[psset]{optexp}{lenswidth}{%
  \pst@checknum{#1}\POE@key@lenswidth
  \ifdim\POE@key@lenswidth pt > 0pt
    \psset{thicklens=true}
  \fi
}
\define@key[psset]{optexp}{lensradiusleft}{\pst@checknum{#1}\POE@key@lensradiusleft}
\define@key[psset]{optexp}{lensradiusright}{\pst@checknum{#1}\POE@key@lensradiusright}
\define@boolkey[psset]{optexp}[POE@]{thicklens}[true]{}
\define@key[psset]{optexp}{lensradius}{%
  \edef\pst@temp{#1}%
  \ifx\pst@temp\@empty\else
    \psset{lensradiusleft=#1, lensradiusright=#1}%
  \fi
}%
\define@key[psset]{optexp}{lens}{%
  \pst@expandafter\psset@@lens{#1} {} {} {} {} {}\@nil
}%
%    \end{macrocode}
% parameters: radiusleft radiusright height width.
%    \begin{macrocode}
\def\psset@@lens#1 #2 #3 #4 #5\@nil{%
  \edef\pst@temp{#4}%
  \ifx\pst@temp\@empty\else
     \psset{lenswidth=#4}%
  \fi
  \edef\pst@temp{#3}%
  \ifx\pst@temp\@empty\else
     \psset{lensheight=#3}
  \fi
  \edef\pst@temp{#2}%
  \ifx\pst@temp\@empty
     \psset{lensradiusright=#1}%
  \else
     \psset{lensradiusright=#2}%
  \fi
  \psset{lensradiusleft=#1}%
}%
\psset[optexp]{%
  lenswidth=0,
  lensheight=1,
  lensradiusleft=1,
  lensradiusright=1
}%
%    \end{macrocode}
% Pinhole
%    \begin{macrocode}
\define@key[psset]{optexp}{innerheight}{\pst@checknum{#1}\POE@key@innerheight}
\define@key[psset]{optexp}{outerheight}{\pst@checknum{#1}\POE@key@outerheight}
\define@key[psset]{optexp}{phlinewidth}{\edef\POE@key@phlinewidth{#1}}
\define@key[psset]{optexp}{phwidth}{\edef\POE@key@phwidth{#1}}
\psset[optexp]{%
  phlinewidth=2\pslinewidth,
  phwidth=0,
  outerheight=1,
  innerheight=0.1
}%
%    \end{macrocode}
% Crystal
%    \begin{macrocode}
\define@key[psset]{optexp}{crystalwidth}{\pst@checknum{#1}\POE@key@crystalwidth}
\define@key[psset]{optexp}{crystalheight}{\pst@checknum{#1}\POE@key@crystalheight}
\define@key[psset]{optexp}{caxislength}{\pst@checknum{#1}\POE@key@caxislength}
\define@boolkey[psset]{optexp}[POE@]{voltage}[true]{}
\define@boolkey[psset]{optexp}[POE@]{caxisinv}[true]{}
\define@boolkey[psset]{optexp}[POE@]{lamp}[true]{}
\define@key[psset]{optexp}{lampscale}{\pst@checknum{#1}\POE@key@lampscale}
\psset[optexp]{%
  crystalwidth=1.4,
  crystalheight=0.6,
  caxislength=0.6,
  lampscale=0.3
}%
%    \end{macrocode}
% Box
%    \begin{macrocode}
\define@key[psset]{optexp}{optboxwidth}{\pst@checknum{#1}\POE@key@optboxwidth}
\define@key[psset]{optexp}{optboxheight}{\pst@checknum{#1}\POE@key@optboxheight}
\define@boolkey[psset]{optexp}[POE@]{endbox}[true]{}
\psset[optexp]{%
  optboxwidth=1.4,
  optboxheight=0.8
}%
%    \end{macrocode}
% Plate
%    \begin{macrocode}
\define@key[psset]{optexp}{platelinewidth}{\edef\POE@key@platelinewidth{#1}}
\define@key[psset]{optexp}{plateheight}{\pst@checknum{#1}\POE@key@plateheight}
\psset[optexp]{%
  plateheight=1,
  platelinewidth=2\pslinewidth
}%
%    \end{macrocode}
% Optical Retardation Plate
%    \begin{macrocode}
\define@key[psset]{optexp}{platewidth}{\pst@checknum{#1}\POE@key@platewidth}
\psset[optexp]{platewidth=0.1}%
%    \end{macrocode}
% Detector
%    \begin{macrocode}
\define@key[psset]{optexp}{detsize}{\pst@checknum{#1}\POE@key@detsize}
\define@choicekey*+[psset]{optexp}{dettype}[\val\nr]{round,diode}%
   {\edef\POE@key@dettype{\val}}
   {\PackageError{pst-optexp}{Unknown value '\val' for key dettype}}
\psset[optexp]{%
  detsize=0.8,
  dettype=round
}%
%    \end{macrocode}
% Polarization
%    \begin{macrocode}
\define@key[psset]{optexp}{polsize}{\pst@checknum{#1}\POE@key@polsize}
\define@key[psset]{optexp}{pollinewidth}{\edef\POE@key@pollinewidth{#1}}
\define@choicekey+[psset]{optexp}{poltype}[\val\nr]{parallel,misc,perp,rcirc,lcirc}%
   {\edef\POE@key@poltype{#1}}
   {\PackageError{pst-optexp}{Unknown value '\val' for key poltype}}
\psset[optexp]{%
  poltype=parallel,
  polsize=0.6,
  pollinewidth=0.7\pslinewidth
}%
%    \end{macrocode}
% Optical Diode
%    \begin{macrocode}
\define@key[psset]{optexp}{optdiodesize}{\pst@checknum{#1}\POE@key@optdiodesize}
\psset[optexp]{optdiodesize=0.8}%
%    \end{macrocode}
% Dove Prism
%    \begin{macrocode}
\define@key[psset]{optexp}{doveprismsize}{\pst@checknum{#1}\POE@key@doveprismsize}
\psset[optexp]{doveprismsize=0.6}%
%    \end{macrocode}
% Beamsplitter
%    \begin{macrocode}
\define@key[psset]{optexp}{bssize}{\pst@checknum{#1}\POE@key@bssize}
\define@key[psset]{optexp}{bsstyle}{\edef\POE@key@bsstyle{#1}}
\psset[optexp]{%
  bssize=0.8,
  bsstyle=cube
}%
%    \end{macrocode}
% Mirror
%    \begin{macrocode}
\define@key[psset]{optexp}{mirrorwidth}{\pst@checknum{#1}\POE@key@mirrorwidth}
\define@key[psset]{optexp}{mirrorlinewidth}{\edef\POE@key@mirrorlinewidth{#1}}
\define@choicekey*[psset]{optexp}{mirrortype}[\val\nr]{piezo,extended,plain}{\edef\POE@key@mirrortype{#1}}
\define@key[psset]{optexp}{mirrordepth}{\pst@checknum{#1}\POE@key@mirrordepth}
\define@key[psset]{optexp}{mirrorradius}{\pst@checknum{#1}\POE@key@mirrorradius}
\define@boolkey[psset]{optexp}[POE@]{variable}[true]{}
\psset[optexp]{%
  mirrorwidth=1,
  mirrordepth=0.1,
  mirrorradius=0,
  mirrortype=plain,
  mirrorlinewidth=2\pslinewidth,
  variable=false
}%
%    \end{macrocode}
% Grating
%    \begin{macrocode}
\define@key[psset]{optexp}{optgridcount}{%
  \pst@checknum{#1}\POE@key@gratingcount
  \PackageWarning{pst-optexp}{Parameter optgridcount is deprecated, use gratingcount instead.}%
}%
\define@key[psset]{optexp}{optgridwidth}{%
  \pst@checknum{#1}\POE@key@gratingwidth
  \PackageWarning{pst-optexp}{Parameter optgridwidth is deprecated, use gratingwidth instead.}%
}%
\define@key[psset]{optexp}{optgridheight}{%
  \pst@checknum{#1}\POE@key@gratingheight
  \PackageWarning{pst-optexp}{Parameter optgridheight is deprecated, use gratingheight instead.}%
}%
\define@choicekey*[psset]{optexp}{optgridtype}[\val\nr]{binary,blazed}{%
  \edef\POE@key@gratingtype{#1}%
  \PackageWarning{pst-optexp}{Parameter optgridtype is deprecated, use gratingtype instead.}%
}%
\define@key[psset]{optexp}{optgriddepth}{%
  \pst@checknum{#1}\POE@key@gratingdepth
  \PackageWarning{pst-optexp}{Parameter optgriddepth is deprecated, use gratingdepth instead.}%
}%
\define@key[psset]{optexp}{optgridlinewidth}{%
  \edef\POE@key@gratinglinewidth{#1}%
  \PackageWarning{pst-optexp}{Parameter optgridlinewidth is deprecated, use gratinglinewidth instead.}%
}%
\define@key[psset]{optexp}{gratingcount}{\pst@checknum{#1}\POE@key@gratingcount}
\define@key[psset]{optexp}{gratingwidth}{\pst@checknum{#1}\POE@key@gratingwidth}
\define@key[psset]{optexp}{gratingheight}{\pst@checknum{#1}\POE@key@gratingheight}
\define@choicekey*[psset]{optexp}{gratingtype}[\val\nr]{binary,blazed}{\edef\POE@key@gratingtype{#1}}%
\define@key[psset]{optexp}{gratingdepth}{\pst@checknum{#1}\POE@key@gratingdepth}
\define@key[psset]{optexp}{gratinglinewidth}{\edef\POE@key@gratinglinewidth{#1}}
\define@boolkey[psset]{optexp}[POE@]{reverse}[true]{}
\psset[optexp]{%
  gratingcount=10,
  gratingwidth=1,
  gratingheight=0.15,
  gratingdepth=0.075,
  gratingtype=blazed,
  gratinglinewidth=0.7\pslinewidth,
  reverse=false
}%
\define@key[psset]{optexp}{refractiveindex}{\pst@checknum{#1}\POE@key@n}
\define@key[psset]{optexp}{n}{\pst@checknum{#1}\POE@key@n}
\define@key[psset]{optexp}{nmul}{\edef\POE@key@nmul{#1}}
\define@key[psset]{optexp}{nadd}{\edef\POE@key@nadd{#1}}
\psset[optexp]{%
  n=1.5,
  nmul=1,
  nadd=0
}%
%    \end{macrocode}
% Penta Prism
%    \begin{macrocode}
\define@key[psset]{optexp}{pentaprismsize}{\pst@checknum{#1}\POE@key@pentaprismsize}
\psset[optexp]{pentaprismsize=0.7}
%    \end{macrocode}
% Right-Angle Prism
%    \begin{macrocode}
\define@key[psset]{optexp}{raprismsize}{\pst@checknum{#1}\POE@key@raprismsize}
\psset[optexp]{raprismsize=1.5}
%    \end{macrocode}
% Prism
%    \begin{macrocode}
\define@key[psset]{optexp}{prismsize}{\pst@checknum{#1}\POE@key@prismsize}
\define@key[psset]{optexp}{prismangle}{\pst@checknum{#1}\POE@key@prismangle}
\psset[optexp]{%
  prismsize=1,
  prismangle=60
}%
%    \end{macrocode}
% Fiber
%    \begin{macrocode}
\define@key[psset]{optexp}{fiberloops}{\pst@checknum{#1}\POE@key@fiberloops}
\define@key[psset]{optexp}{fiberloopradius}{\pst@checknum{#1}\POE@key@fiberloopradius}
\define@key[psset]{optexp}{fiberloopsep}{\pst@checknum{#1}\POE@key@fiberloopsep}
\psset[optexp]{%
  fiberloops=3,
  fiberloopradius=0.4,
  fiberloopsep=0.3
}%
%    \end{macrocode}
% Filter
%    \begin{macrocode}
\define@key[psset]{optexp}{filtersize}{\pst@checknum{#1}\POE@key@filtersize}
\define@choicekey+[psset]{optexp}{filtertype}[\val\nr]{bandstop,bandpass,lowpass,highpass}%
   {\edef\POE@key@filtertype{#1}}%
   {\PackageError{pst-optexp}{Unknown value '\val' for key filtertype}}
\psset[optexp]{%
  filtersize=0.8,
  filtertype=bandpass
}%
%    \end{macrocode}
% Polarization controller
%    \begin{macrocode}
\define@key[psset]{optexp}{polcontrolsize}{\pst@checknum{#1}\POE@key@polcontrolsize}
\psset[optexp]{polcontrolsize=0.15}%
%    \end{macrocode}
% Optical amplifier
%    \begin{macrocode}
\define@key[psset]{optexp}{optampsize}{\pst@checknum{#1}\POE@key@optampsize}
\psset[optexp]{optampsize=0.8}
%    \end{macrocode}
% Mach-Zehnder modulator
%    \begin{macrocode}
\define@key[psset]{optexp}{optmzmsize}{\pst@checknum{#1}\POE@key@optmzmsize}
\psset[optexp]{optmzmsize=0.8}
%    \end{macrocode}
% Isolator
%    \begin{macrocode}
\define@key[psset]{optexp}{isolatorsize}{\pst@checknum{#1}\POE@key@isolatorsize}
\psset[optexp]{isolatorsize=0.6}%
%    \end{macrocode}
% Fiber polarizer
%    \begin{macrocode}
\define@key[psset]{optexp}{fiberpolsize}{\pst@checknum{#1}\POE@key@fiberpolsize}
\psset[optexp]{fiberpolsize=0.6}%
%    \end{macrocode}
% Optical switch
%    \begin{macrocode}
\define@key[psset]{optexp}{switchsize}{\pst@checknum{#1}\POE@key@switchsize}
\define@choicekey+[psset]{optexp}{switchstyle}[\val\nr]{opened,closed}%
  {\edef\POE@key@switchstyle{#1}}%
  {\PackageError{pst-optexp}{Unknown value '\val' for key switchstyle}}
\psset[optexp]{%
  switchsize=0.8,
  switchstyle=opened
}%
%    \end{macrocode}
% Fiber delay line
%    \begin{macrocode}
\define@key[psset]{optexp}{fdlsize}{\pst@checknum{#1}\POE@key@fdlsize}
\psset[optexp]{fdlsize=0.6}%
%    \end{macrocode}
% Fiber collimator 
%    \begin{macrocode}
\define@key[psset]{optexp}{fibercolsize}{\pst@checknum{#1}\POE@key@fibercolsize}
\psset[optexp]{fibercolsize=0.3}%
%    \end{macrocode}
% Coupler
%    \begin{macrocode}
\define@key[psset]{optexp}{couplersize}{\pst@checknum{#1}\POE@key@couplersize}
\define@key[psset]{optexp}{coupleroutshift}{\pst@checknum{#1}\POE@key@coupleroutshift}
\define@key[psset]{optexp}{couplersep}{\pst@checknum{#1}\POE@key@couplersep}
\define@choicekey+[psset]{optexp}{couplertype}[\val\nr]{none,elliptic,crossswitch,rectangular}%
   {\edef\POE@key@couplertype{#1}}%
   {\PackageError{pst-optexp}{Unknown value '\val' for key couplertype}}
\define@key[psset]{optexp}{align}{\edef\POE@key@align{#1}}
\psset[optexp]{%
  couplersize=0.2,
  couplersep=0.05,
  align=center,
  coupleroutshift=0,
  couplertype=elliptic
}%
%    \end{macrocode}
% External node
%    \begin{macrocode}
\define@key[psset]{optexp}{extnoden@me}{\edef\POE@key@extnoden@me{\POE@str@basicname@prefix#1\POE@str@extnode@postfix}}
%    \end{macrocode}
% (this part was copied and adapted from \cs{psset@@ref} from pstricks.tex)
%    \begin{macrocode}
\define@key[psset]{optexp}{extnode}{%
   \edef\POE@key@extnode{#1}%
   \ifx\@empty\POE@key@extnode\else
      \pst@expandafter\psset@@extnode{#1}\@empty,,\@nil
   \fi
}%
\psset[optexp]{extnode=\@empty}%
\def\POE@key@xref{0}%
\def\POE@key@yref{0}%
\def\psset@@extnode#1#2,#3,#4\@nil{%
  \def\POE@key@xref{0}%
  \def\POE@key@yref{0}%
  \ifx\@empty#3\@empty
    \@nameuse{getref@optexp@#1}%
    \@nameuse{getref@optexp@#2}%
  \else
    \pst@checknum{#1#2}\POE@key@xref%
    \pst@checknum{#3}\POE@key@yref%
  \fi}%
\def\getref@optexp@c{}%
\def\getref@optexp@t{\def\POE@key@yref{1}}%
\def\getref@optexp@b{\def\POE@key@yref{-1}}%
\def\getref@optexp@l{\def\POE@key@xref{-1}}%
\def\getref@optexp@r{\def\POE@key@xref{1}}%
\define@key[psset]{optexp}{rotateref}{%
   \def\pst@temp{#1}%
   \ifx\@empty\pst@temp\else
      \pst@expandafter\psset@@rotateref{#1}\@empty,,\@nil
   \fi
}%
\def\POE@key@rotate@xref{0}%
\def\POE@key@rotate@yref{0}%
\def\psset@@rotateref#1#2,#3,#4\@nil{%
  \def\POE@key@rotate@xref{0}%
  \def\POE@key@rotate@yref{0}%
  \ifx\@empty#3\@empty
    \@nameuse{getref@optexp@rotate@#1}%
    \@nameuse{getref@optexp@rotate@#2}%
  \else
    \pst@checknum{#1#2}\POE@key@rotate@xref%
    \pst@checknum{#3}\POE@key@rotate@yref%
  \fi}%
\def\getref@optexp@rotate@c{}%
\def\getref@optexp@rotate@t{\def\POE@key@rotate@yref{1}}%
\def\getref@optexp@rotate@b{\def\POE@key@rotate@yref{-1}}%
\def\getref@optexp@rotate@l{\def\POE@key@rotate@xref{-1}}%
\def\getref@optexp@rotate@r{\def\POE@key@rotate@xref{1}}%
\psset[optexp]{rotateref=c}%
%    \end{macrocode}
%    \begin{macrocode}
\define@key[psset]{optexp}{b@sicname}{\edef\POE@key@b@sicname{\POE@str@basicname@prefix#1}}%
%    \end{macrocode}
% List with all component names define until now. Is kept for a single pspicture environment
%    \begin{macrocode}
\gdef\POE@complist{}%
\g@addto@macro{\endpspicture}{%
  \gdef\POE@complist{}\global\POE@cnt=0\relax
}%
%    \end{macrocode}
% Set the component name. If the parameter is empty, a generated name is used.
%    \begin{macrocode}
\define@key[psset]{optexp}{compname}{%
  \ifPOE@insideobj\else
    \PackageError{pst-optexp}{compname allowed only inside an object}
  \fi
  \edef\pst@tmp{#1}%
  \ifx\pst@tmp\@empty
    \edef\POE@key@compname{\POE@str@basicname@default\the\POE@cnt}%
    \psset{b@sicname=\POE@str@basicname@default\the\POE@cnt}%
    \ifPOE@compat
      \psset{extnoden@me={}}%
     \else
       \psset{extnoden@me=\POE@str@basicname@default\the\POE@cnt}%
     \fi
  \else
    \edef\POE@key@compname{#1}%
    \ifPOE@compat
      \def\POE@str@basicname@prefix{}%
      \psset{b@sicname=#1Intern}%
    \else
      \psset{b@sicname=#1}%   
    \fi
    \psset{extnoden@me=#1}%
  \fi
%    \end{macrocode}
% check if compname was already defined
%    \begin{macrocode}
  \@expandtwoargs\in@{,\POE@key@compname,}{,\POE@complist,}%
  \ifin@
    \PackageWarning{pst-optexp}%
         {^^Jcompname '\POE@key@compname' already used. Previously defined nodes will be overwritten!^^J}%
  \else
%    \end{macrocode}
% Use definition of \cs{XKV@addtolist@x} with an \cs{xdef} instead of \cs{edef} in order to keep the bookkeeping global
%    \begin{macrocode}
    \xdef\POE@complist{\POE@key@compname\ifx\POE@complist\@empty\else,\fi\POE@complist}%
  \fi
}%
\POE@insideobjtrue
\psset[optexp]{compname=\@empty}
\POE@insideobjfalse
%    \end{macrocode}
% Connect a component directly with its reference nodes using \cs{drawbeam}
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@]{beam}[true]{}
%    \end{macrocode}
% Select which input fibers are drawn directly
%    \begin{macrocode}
\define@choicekey*[psset]{optexp}{fiberin}[\val\nr]{none,top,bottom,both}[both]{%
  \ifcase\nr\relax
    \psset{fiberin@=false, fiberin@top=false, fiberin@bottom=false}
  \or
    \psset{fiberin@=true, fiberin@top, fiberin@bottom=false, fiber@}
  \or
    \psset{fiberin@=true, fiberin@top=false, fiberin@bottom=true, fiber@}
  \or
    \psset{fiberin@=true, fiberin@top=true, fiberin@bottom=true, fiber@}
  \fi
}%
%    \end{macrocode}
% Select which input fibers are drawn directly
%    \begin{macrocode}
\define@choicekey*[psset]{optexp}{fiberout}[\val\nr]{none,top,bottom,both}[both]{%
  \ifcase\nr\relax
    \psset{fiberout@=false, fiberout@top=false, fiberout@bottom=false}
  \or
    \psset{fiberout@=true, fiberout@top, fiberout@bottom=false, fiber@}
  \or
    \psset{fiberout@=true, fiberout@top=false, fiberout@bottom=true, fiber@}
  \or
    \psset{fiberout@=true, fiberout@top=true, fiberout@bottom=true, fiber@}
  \fi
}%
%    \end{macrocode}
% These are the internal boolkeys for the fiber choices done with 'fiberin' and 'fiberout'
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@]{fiber@}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberin@}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberin@top}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberin@bottom}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberout@}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberout@top}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberout@bottom}[true]{}
\define@boolkey[psset]{optexp}[POE@]{relangle}[true]{}
\define@choicekey+[psset]{optexp}{startnode}[\val\nr]{auto,1,2,3,4,N}%
   {\edef\POE@key@startnode{\val}}
   {\PackageError{pst-optexp}{Unknown value '\val' for key startnode}}
\define@choicekey+[psset]{optexp}{stopnode}[\val\nr]{auto,1,2,3,4,N}%
   {\edef\POE@key@stopnode{\val}}
   {\PackageError{pst-optexp}{Unknown value '\val' for key stopnode}}
\psset[optexp]{%
  startnode=auto,
  stopnode=auto
}%
%    \end{macrocode}
%
% \begin{macro}{\POE@getnode}
% \begin{macro}{\POE@getcoor}
%    \begin{macrocode}
\def\POE@getnode#1#2\@nil{%
  \ifx(#1\relax%)
    \POE@getcoor#1#2
    \edef\oe@temp{{\pst@coor}}%
  \else
    \ifnum9<1#1 %
      \edef\oe@temp{/\POE@str@basicname@prefix\POE@str@basicname@default#1#2\space}%
    \else
      \edef\oe@temp{/\POE@str@basicname@prefix#1#2\space}%
    \fi
  \fi%
}%
\def\POE@getcoor(#1){%
  \pst@@getcoor{#1}
}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\drawfiber}
%    \begin{macrocode}
\def\drawfiber{\drawfiber@{Fiber}}%
\def\drawfiber@#1{%
  \def\pst@par{style=#1}%
  \@ifnextchar[%]
    {\drawfiber@i}{\drawfiber@i[]}%
}%
\def\drawfiber@i[#1]#2#3{%
  \addafter@par{#1}%
  \begingroup
    \let\psk@angleA\relax
    \let\psk@angleB\relax
    \use@par
    \def\oe@tempa{#2}
    \ifx\oe@tempa\@empty
      \edef\POE@comps{/\POE@getlastcompname\space}
    \else
      \expandafter\POE@getnode#2\@nil
      \edef\POE@comps{\oe@temp}
    \fi
    \def\oe@tempb{#3}
    \ifx\oe@tempb\@empty
      \edef\POE@comps{/\POE@getlastcompname\space \POE@comps}
    \else
      \expandafter\POE@getnode#3\@nil
      \edef\POE@comps{\oe@temp\space \POE@comps}
    \fi   
    \ifPOE@backlayer
      \ifx\POE@key@startnode\POE@str@autonode\else
        \pnode(! /\POE@key@startnode\space \POE@comps exch pop \POE@dict{getsubnode} \tx@UserCoor){@@A}
      \fi
      \ifx\POE@key@stopnode\POE@str@autonode\else
        \pnode(! /\POE@key@stopnode\space \POE@comps pop \POE@dict{getsubnode} \tx@UserCoor){@@B}
      \fi
      \ifx\POE@key@startnode\POE@str@autonode
        \ifx\POE@key@stopnode\POE@str@autonode
          \pnode(! \POE@comps exch \POE@dict{NearestNode} \tx@UserCoor){@@A}
          \pnode(! \POE@comps \POE@dict{NearestNode} \tx@UserCoor){@@B}
        \else
          \pnode(! \POE@comps exch pop /N@@@B \POE@dict{@GetCenter ToVec NearestNode} \tx@UserCoor){@@A}
        \fi
      \else\ifx\POE@key@stopnode\POE@str@autonode
        \pnode(! \POE@comps pop /N@@@A \POE@dict{@GetCenter ToVec NearestNode} \tx@UserCoor){@@B}
      \fi\fi
      \pst@getcoor{@@A}\pst@tempa
      \pst@getcoor{@@B}\pst@tempb
      \ifx\psk@angleA\relax
        \psset{angleA=! \POE@dict{\pst@tempb \pst@tempa \POE@comps exch RelFiberAngle}}%
      \else
        \ifPOE@relangle
          \psset{angleA=! \POE@dict{\pst@tempb \pst@tempa \POE@comps exch RelFiberAngle} \psk@angleA\space add}%
        \fi
      \fi
      \ifx\psk@angleB\relax
        \psset{angleB=! \POE@dict{\pst@tempa \pst@tempb \POE@comps RelFiberAngle}}%
      \else
        \ifPOE@relangle
          \psset{angleB=! \POE@dict{\pst@tempa \pst@tempb \POE@comps RelFiberAngle} \psk@angleB\space add }%
      \fi\fi
      \nccurve{@@A}{@@B}
    \fi
  \endgroup
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\backlayer}
% \begin{macro}{\frontlayer}
%    \begin{macrocode}
\def\backlayer#1{\ifPOE@backlayer #1\fi\ignorespaces}
\def\frontlayer#1{\ifPOE@frontlayer #1\fi\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%    
%    \begin{macrocode}
\expandafter\ifx\csname pstoptexp@compat\endcsname\relax%
%    \end{macrocode}
%
% \subsubsection{New connection code}
% 
% The keys related to the \cs{draw*} macros
% \begin{macrocode}
\define@key[psset]{optexp}{beamangle}{\edef\POE@key@beamangle{#1}}%
\define@key[psset]{optexp}{startpos}{\edef\POE@key@startpos{#1}}%
\define@key[psset]{optexp}{beamdiv}{\edef\POE@key@beamdiv{#1}}%
\define@key[psset]{optexp}{beamwidth}{\edef\POE@key@beamwidth{#1}}%
\define@boolkey[psset]{optexp}[POE@]{startinside}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{stopinside}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{beaminsidefirst}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{beaminsidelast}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{beaminside}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{connectplanes}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{beamangleabs}[true]{}%
%    \end{macrocode}
%
% \begin{macro}{\custombeam}
% This is analogous to \cs{pscustom}. Inside \cs{custombeam}, sequential uses of \cs{draw*beam} can use the ending
% points of previous calls and the lines are combined to a single one.
%    \begin{macrocode}
\def\custombeam{\pst@object{custombeam}}%
\def\custombeam@i#1{%
  \ifPOE@backlayer
  \addafter@par{style=Beam}%
  \begin@SpecialObj%
    \let\pst@linetype\pst@arrowtype
    \pst@addarrowdef%
    \POE@custombeamtrue
    \def\begin@SpecialObj{%
      \begingroup%
      \use@par%
      \def\end@SpecialObj{\endgroup\ignorespaces}}%
    \let\@drawbeam\drawbeam
    \def\drawbeam{%
      \let\POE@strokebeam\POE@strokesinglebeam
      \def\drawwidebeam{%
        \PackageError{pst-optexp}{You can't switch from single to wide beam in custom mode}%
      }%
      \@drawbeam
    }%
    \let\@drawwidebeam\drawwidebeam
    \def\drawwidebeam{%
      \let\POE@strokebeam\POE@strokewidebeam
      \def\drawbeam{%
        \PackageError{pst-optexp}{You can't switch from wide to single beam in custom mode}%
      }%
      \@drawwidebeam
    }%
    \def\begin@WideBeamObj{%
      \begin@BeamObj
      \def\POE@strokebeam{\addto@pscode{ rearrangeWideBeamPoints }}%
    }%
    \def\begin@SingleBeamObj{%
      \begin@BeamObj
      \def\POE@strokebeam{\addto@pscode{ rearrangeSingleBeamPoints }}%
    }%
    \addto@pscode{[ }%
    #1%
    \ifx\pslinestyle\@none
      \addto@pscode{ cleartomark }%
    \else
      \addto@pscode{\pst@optexpdict }%
      \POE@strokebeam
      \addto@pscode{ end }%
    \fi
  \end@SpecialObj%
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\begin@BeamObj}
%    \begin{macrocode}
\def\begin@BeamObj{%
  \addbefore@par{n=0}%
  \begin@SpecialObj%
  \addto@pscode{%
     \pst@optexpdict 
     /beaminsidefirst \ifPOE@beaminsidefirst true \else false \fi def
     /beaminsidelast \ifPOE@beaminsidelast true \else false \fi def
     /beaminside \ifPOE@beaminside true \else false \fi def
     /custombeam \ifPOE@custombeam true \else false \fi def
     /startinside \ifPOE@startinside true \else false \fi def
     /stopinside \ifPOE@stopinside true \else false \fi def
     /connectplanes \ifPOE@connectplanes true \else false \fi def
     /beamangleabs \ifPOE@beamangleabs true \else false \fi def
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\begin@WideBeamObj}
%    \begin{macrocode}
\def\begin@WideBeamObj{%
  \addafter@par{style=Beam}%
  \begin@BeamObj
  \let\pst@linetype\pst@arrowtype
  \pst@addarrowdef%
  \let\POE@strokebeam\POE@strokewidebeam
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\begin@SingleBeamObj}
%    \begin{macrocode}
\def\begin@SingleBeamObj{%
  \addbefore@par{style=Beam}%
  \begin@BeamObj
  \let\pst@linetype\pst@arrowtype
  \pst@addarrowdef%
  \let\POE@strokebeam\POE@strokesinglebeam
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\drawbeam}
%    \begin{macrocode}
\def\drawbeam{\pst@object{drawbeam}}%
\def\drawbeam@i{%
  \begin@SingleBeamObj
  \POE@getcomps[\drawbeam@ii%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\drawwidebeam}
%    \begin{macrocode}
\def\drawwidebeam{\pst@object{drawwidebeam}}%
\def\drawwidebeam@i{%
  \begin@WideBeamObj
  \POE@getcomps[\drawwidebeam@ii%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\end@BeamObj}
%    \begin{macrocode}
\def\end@BeamObj{%
  \addto@pscode{ end}%
  \let\psk@fillstyle\relax
  \ifPOE@optexpenv
    \ifPOE@frontlayer
      \def\pst@code{}%
    \fi
  \fi
  \end@SpecialObj%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\drawbeam@ii}
%    \begin{macrocode}
\def\drawbeam@ii{%
  \ifx\pslinestyle\@none\else
    \addto@pscode{%
     {/nmul \POE@key@nmul\space def
      /nadd \POE@key@nadd\space def
      /nforce \POE@key@n\space def} }%
    \ifx\POE@key@startpos\@empty
      \addto@pscode{ {0 0} }%
    \else
      \addto@pscode{ [\POE@key@startpos\space counttomark 1 eq { 0 exch } if \tx@ScreenCoor] cvx }%
    \fi
    \addto@pscode{%
       \POE@key@beamangle\space
    }%
    \addto@pscode{ TraceBeam }%
    \POE@strokebeam
  \fi
  \end@BeamObj
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@strokesinglebeam}
%    \begin{macrocode}
\def\POE@strokesinglebeam{%
  \addto@pscode{%
    gsave 
      Drawbeam 
      \tx@setlinejoin
      \pst@number\pslinewidth SLW
      \pst@usecolor\pslinecolor
      \tx@setStrokeTransparency
      \@nameuse{psls@\pslinestyle}
    grestore
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\drawwidebeam@ii}
%    \begin{macrocode}
\def\drawwidebeam@ii{%
  \def\pst@fill##1{ gsave ##1 grestore }%
  \addto@pscode{%
   {/nmul \POE@key@nmul\space def
    /nadd \POE@key@nadd\space def
    /nforce \POE@key@n\space def
    /beamdiv \ifx\POE@key@beamdiv\@empty 0 \else \POE@key@beamdiv\fi\space def} }%
%    \end{macrocode}
% arrange and create the input vectors
%    \begin{macrocode}
    \addto@pscode{%
      \POE@key@beamangle\space dup
      \ifx\POE@key@beamdiv\@empty\else 
        \POE@key@beamdiv\space dup 4 -1 roll add 3 1 roll sub
      \fi
    }%
%    \end{macrocode}
% the start positions
%    \begin{macrocode}
  \addto@pscode{%
    [\ifx\POE@key@startpos\@empty 0 0 \else\POE@key@startpos\space\fi
     counttomark 1 eq { 0 exch } if
     \ifx\POE@key@beamwidth\@empty 0 \else \POE@key@beamwidth\space 0.5 mul \fi\space
     3 copy add \tx@ScreenCoor\space ToVec 5 1 roll sub \tx@ScreenCoor] cvx
  }%
%    \end{macrocode}
% rearrange options
%    \begin{macrocode}
  \addto@pscode{ exch 4 -1 roll 4 2 roll exch }% 
%    \end{macrocode}
% stroke and/or fill
%    \begin{macrocode}
  \ifx\psk@fillstyle\relax\else
    \addto@pscode{%
      counttomark 1 add copy 
      gsave
        /fillBeam { \psk@fillstyle } def
        currentdict /lastBeamPointLow known { /TmpLastBeamPointLow /lastBeamPointLow load def} if
        currentdict /lastBeamPointUp known { /TmpLastBeamPointUp /lastBeamPointUp load def} if
        FillWideBeam
      grestore pop
    }%
  \fi%
%    \end{macrocode}
% stroke
%    \begin{macrocode}
  \ifx\pslinestyle\@none
    \addto@pscode{ cleartomark }%
  \else
    \ifx\psk@fillstyle\relax\else
      \addto@pscode{ restoreBeamPoints }%
    \fi
    \addto@pscode{ TraceWideBeam }%
    \POE@strokebeam
  \fi
  \end@BeamObj
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@strokewidebeam}
%    \begin{macrocode}
\def\POE@strokewidebeam{%
  \POE@strokesinglebeam
  \POE@strokesinglebeam
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@getcomps}
%    \begin{macrocode}
\def\POE@getcomps#1#2{%
  \def\POE@aftercomps{\addto@pscode{#1 \POE@comps }#2}%
  \def\POE@comps{}%
  \POE@@getcomps%
}%
\def\POE@@getcomps{%
  \@ifnextchar\bgroup{\POE@@@getcomps}{\POE@aftercomps}%
}%
\def\POE@@@getcomps#1{\def\oe@temp{#1\@empty}\expandafter\POE@@@@getcomps\oe@temp\@nil}%
\def\POE@@@@getcomps#1#2\@nil{%
  \edef\oe@temp{#1}%
  \ifx\oe@temp\@empty
    \POE@getcomp{(\POE@getlastcompname)}%
  \else\ifx(#1\relax%)
    \POE@getplanenode#1#2%
  \else\ifnum9<1#1
    \POE@getcomp{(\POE@str@basicname@prefix\POE@str@basicname@default#1#2)}%
  \else
    \POE@getcomp{(\POE@str@basicname@prefix#1#2)}%
  \fi\fi\fi%
  \POE@@getcomps%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@getplanenode}
%    \begin{macrocode}
\def\POE@getplanenode(#1){%
  \pst@@getcoor{#1}%
  \advance\POE@nodecnt by 1
  \POE@getcomp{%
    {\pst@coor} {0 1} (\POE@str@basicname@default N@\the\POE@nodecnt) 
    {\tx@UserCoor} NewTempNodeComp 
    (\POE@str@basicname@default N@\the\POE@nodecnt)
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@getcomp}
%    \begin{macrocode}
\def\POE@getcomp#1{%
   \edef\POE@comps{#1 \POE@comps}%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@drawInternalConnections}
%    \begin{macrocode}
\def\POE@drawInternalConnections{%
  \ifPOE@beam
    \ifPOE@endbox
      \drawbeam[connectplanes]{(\oenodeRefA{})}{\POE@key@compname}
    \else
      \drawbeam[connectplanes]{(\oenodeRefA{})}{\POE@key@compname}{(\oenodeRefB{})}
    \fi
  \else
    \ifPOE@endbox
      \ifPOE@fiberin@
        \drawfiber@{FiberIn}{(\oenodeRefA{})}{\POE@key@compname}
      \fi
    \else
      \ifPOE@fiberin@
        \drawfiber@{FiberIn}{(\oenodeRefA{})}{\POE@key@compname}
      \fi
      \ifPOE@fiberout@
        \drawfiber@{FiberOut}{\POE@key@compname}{(\oenodeRefB{})}
      \fi
    \fi
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
%    \begin{macrocode}
\define@choicekey[psset]{optexp}{fiber}[\val\nr]{}[]{%
   \psset{fiberin, fiberout}%
}
\define@choicekey[psset]{optexp}{nofiber}[\val\nr]{}[]{%
   \psset{fiberin=none, fiberout=none}%
}
% Set default settings for the new connection code
%    \begin{macrocode}
\psset[optexp]{%
        startinside=false
        ,stopinside=false
        ,beaminside=true
        ,beaminsidefirst=false
        ,beaminsidelast=false
        ,beamangle=0
        ,startpos=\@empty
        ,beamangleabs=false
        ,beamwidth=0
        ,beamdiv=\@empty
        ,nmul=1
        ,nadd=0
        ,namingscheme=new
}%
\else
%    \end{macrocode}
% The old connection code for backward compatibility to version 2.x. As this is obsolete and was broken by design, there is no need to comment on this.
%    \begin{macrocode}
\def\defShiftedNode(#1)(#2)#3{\nodexn{(#1) + (#2)}{#3}}%
\def\optexp@nodeA{\POE@key@b@sicname 1}%
\def\optexp@nodeB{\POE@key@b@sicname N}%
\def\POS@basicname@postfix{Intern}%
\define@key[psset]{optexp}{connjoin}{%
 \edef\pst@temp{#1}%
 \ifnum\pst@temp<0
   \POE@connjoinfalse
 \else\ifnum\pst@temp>2
   \POE@connjoinfalse
 \else
   \POE@connjointrue
   \edef\POE@key@connjoin{\pst@temp}
 \fi\fi
}%
\define@key[psset]{optexp}{conn}{%
  \edef\pst@tempg{#1}%
  \expandafter\psset@@conn\pst@tempg\@empty-\@empty\@nil
  \if@pst\else
   \pstrickserr{Bad connection specification: #1}\@ehpa
  \fi
}%
\def\psset@@conn#1-#2\@empty#3\@nil{%
  \@psttrue
  \def\next##1,#1-##2,##3\@nil{\def\pst@tempg{##2}}%
  \expandafter\next\pst@optexp@conntable,#1-#1,\@nil
  \@ifundefined{psoe@cs@in@\pst@tempg}%
    {\@pstfalse\def\POE@connIn{}}%
    {\edef\POE@connIn{psoe@cs@in@\pst@tempg}}%
  \@ifundefined{psoe@cs@out@#2}%
    {\@pstfalse\def\POE@connOut{}}%
    {\def\POE@connOut{psoe@cs@out@#2}}%
}%
\def\POE@connIn{}%
\def\POE@connOut{}%
\def\pst@optexp@conntable{,o-o,i-i,f-f}%
\def\psoe@cs@out@{}%
\def\psoe@cs@in@{}%
\def\psoe@cs@in@o{\psline[style=Beam](\oenodeRefA{})(\optexp@nodeA)}%
\def\psoe@cs@out@o{\psline[style=Beam](\optexp@nodeB)(\oenodeRefB{})}%
\def\psoe@cs@in@f{%
  \pccurve[angleA=!\POE@dict{/N@\oenodeRefB{} /N@\oenodeRefA{} FiberAngleA}, 
           angleB=!\POE@dict{/N@\oenodeRefB{} /N@\oenodeRefA{} FiberAngleB}, 
           style=FiberIn](\oenodeRefA{})(\optexp@nodeA)%
}%
\def\psoe@cs@out@f{%
   \pccurve[angleA=!\POE@dict{/N@\oenodeRefB{} /N@\oenodeRefA{} FiberAngleA}, 
            angleB=!\POE@dict{/N@\oenodeRefB{} /N@\oenodeRefA{} FiberAngleB}, 
            style=FiberOut](\optexp@nodeB)(\oenodeRefB{})%
}%
\def\psoe@cs@in@i{%
  \def\pst@par{style=Beam}
  \begin@OpenObj
    \addto@pscode{%
      [%]
      \pst@optexpdict
        (\POE@key@b@sicname) false GetInternalBeamNodes 
        (N@\oenodeRefA{}) @GetCenter 
      end
    }%
  \psline@ii
}%
\def\psoe@cs@out@i{%
  \def\pst@par{style=Beam}
  \begin@OpenObj
    \addto@pscode{%
      [%]
      \pst@optexpdict
        (N@\oenodeRefB{}) @GetCenter
        (\POE@key@b@sicname) false GetInternalBeamNodes 
      end
    }%
  \psline@ii
}%
\def\psoe@cs@in@a{(N@\optexp@nodeA) \pst@optexpdict @GetCenter end }%
\def\psoe@cs@in@A{(\POE@key@b@sicname) true \POE@dict{GetInternalBeamNodes} }%
\def\psoe@cs@in@b{(N@\optexp@nodeB) \POE@dict{@GetCenter} }%
\def\psoe@cs@in@B{(\POE@key@b@sicname) false \POE@dict{GetInternalBeamNodes} }%
\def\psoe@cs@out@a{(N@\optexp@nodeA) \pst@optexpdict @GetCenter end }%
\def\psoe@cs@out@A{(\POE@key@b@sicname) false \POE@dict{GetInternalBeamNodes} }%
\def\psoe@cs@out@b{(N@\optexp@nodeB) \POE@dict{@GetCenter} }%
\def\psoe@cs@out@B{(\POE@key@b@sicname) true \POE@dict{GetInternalBeamNodes} }%
\def\drawbeam{%
  \def\conntable{,a-a,b-b,A-A,B-B}%
  \begingroup
    \psset{style=Beam}%
    \pst@object{drawbeam}%
}%
\def\POE@getfirstchar#1#2\@nil{#1}%
\def\drawbeam@i#1#2{%
  \def\pst@tempA{\POE@getfirstchar#1\@nil}%
  \def\pst@tempB{\POE@getfirstchar#2\@nil}%
  \ifPOE@connjoin
    \psset{linejoin=\POE@key@connjoin}%
  \fi
  \begin@OpenObj%
  \if(\pst@tempB%)
    \POE@getcoor#2
    \def\POE@connOut{pst@coor}%
  \else
    \POE@checkcompname{#2}%
    \edef\POE@key@b@sicnameB{#2\POS@basicname@postfix}%
  \fi
  \if(\pst@tempA%)
    \POE@getcoor#1%
    \def\POE@connIn{pst@coor}%
  \else
    \POE@checkcompname{#1}%
    \edef\POE@key@b@sicnameA{#1\POS@basicname@postfix}%
  \fi
  \let\POE@key@b@sicname\POE@key@b@sicnameB
  \addto@pscode{[%] 
    \@nameuse{\POE@connOut}}%
  \let\POE@key@b@sicname\POE@key@b@sicnameA
  \addto@pscode{\@nameuse{\POE@connIn}}%
  \psline@ii
  \endgroup
\ignorespaces}%
\def\POE@getcoor(#1){%
  \pst@@getcoor{#1}%
\ignorespaces}%
\def\POE@drawInternalConnections{%
  \ifPOE@endbox
    \@nameuse{\POE@connIn}
  \else
    \ifPOE@fiber@
      \ifPOE@fiberin@
        \@nameuse{\POE@connIn}
      \fi
      \ifPOE@fiberout@
        \@nameuse{\POE@connOut}
      \fi
    \else
      \ifPOE@connjoin
        \def\tmp@A{psoe@cs@in@i}%
        \ifx\tmp@A\POE@connIn
          \def\tmp@B{psoe@cs@out@o}
          \ifx\tmp@B\POE@connOut
            \pscustom[style=Beam, linejoin=\POE@key@connjoin]{%
              \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}}%
          \else\ifx\@empty\POE@connOut
            \pscustom[style=Beam, linejoin=\POE@key@connjoin]{%
              \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}}%
          \else
            \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}%
          \fi\fi
        \else
          \def\tmp@A{psoe@cs@in@o}%
          \ifx\tmp@A\POE@connIn
            \def\tmp@B{psoe@cs@out@o}
            \ifx\tmp@B\POE@connOut
              \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}%
            \else\ifx\@empty\POE@connOut
              \pscustom[style=Beam, linejoin=\POE@key@connjoin]{%
                \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}}%
            \else
              \pscustom[style=Beam, linejoin=\POE@key@connjoin]{%
                \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}}%
            \fi\fi
          \else
            \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}%
          \fi
        \fi
      \else
        \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}%
      \fi
    \fi
  \fi
}%
\define@choicekey[psset]{optexp}{beam}[\val\nr]{}[]{%
  \psset{conn=o-i}%
}
\define@choicekey[psset]{optexp}{fiber}[\val\nr]{}[]{%
  \psset{conn=f-f, fiberin, fiberout}%
}
\define@choicekey[psset]{optexp}{nofiber}[\val\nr]{}[]{%
  \psset{conn=-, fiberin=none, fiberout=none}%
}
\POE@compattrue
\psset[optexp]{%
  conn=-
  , connjoin=1
  , namingscheme=old
}
\fi
%    \end{macrocode}
%
% \begin{macro}{\POE@checkcompname}
%    \begin{macrocode}
\def\POE@checkcompname#1{%
  \@expandtwoargs\in@{,#1,}{,\POE@complist,}%
  \ifin@\else
    \PackageError{pst-optexp}{^^Jcompname '#1' undefined!^^J}
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@getlastcompname}
%    \begin{macrocode}
\def\POE@getlastcompname{%
  \POE@str@basicname@prefix\expandafter\POE@getlastcompname@i \POE@complist,\relax,\@nil}%
\def\POE@getlastcompname@i#1,#2,#3\@nil{#1}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\oenode}
%    \begin{macrocode}
\def\oenode#1#2{%
  \ifx.#1.%
    \POE@getlastcompname
  \else
    \POE@str@basicname@prefix
    \ifnum9<1#1 
      \POE@str@basicname@default
    \fi
    #1%
    \fi
  #2%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\oenodeExt}
% \begin{macro}{\oenodeIn}
% \begin{macro}{\oenodeOut}
% \begin{macro}{\oenodeCenter}
% \begin{macro}{\oenodeLabel}
%    \begin{macrocode}
\def\oenodeExt#1{\oenode{#1}{\POE@str@extnode@postfix}}%
\def\oenodeIn#1{\oenode{#1}{1}}%
\def\oenodeOut#1{\oenode{#1}{N}}%
\def\oenodeCenter#1{\oenode{#1}{Center}}%
\def\oenodeLabel#1{\oenode{#1}{Label}}%
\def\oenodeRefA#1{\oenode{#1}{A}}%
\def\oenodeRefB#1{\oenode{#1}{B}}%
\def\oenodeRotref#1{\oenode{#1}{Rotref}}%
\def\oenodeTrefA#1{\oenode{#1}{TrefA}}%
\def\oenodeTrefB#1{\oenode{#1}{TrefB}}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\newOptexpComp}
%    \begin{macrocode}
\def\newOptexpComp#1{%
  \pst@OptexpVerb{[ #1 (\POE@key@b@sicname) {\tx@ScreenCoor} false NewOptexpComp}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\newOptexpCompAmb}
%    \begin{macrocode}
\def\newOptexpCompAmb#1{%
  \pst@OptexpVerb{[ #1 (\POE@key@b@sicname) {\tx@ScreenCoor} true NewOptexpComp}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\POE@compalias}
%    \begin{macrocode}
\def\POE@compalias#1#2{%
  \pst@OptexpVerb{%
    /\POE@str@basicname@prefix#1 dup currentdict exch known { load /\POE@str@basicname@prefix#2 ED } if
    (\POE@str@basicname@prefix#2) (\POE@str@basicname@prefix#1)
    tx@NodeDict begin
      (N@) exch strcat exch (N@) exch strcat exch 1 {
        3 copy 3 string cvs dup 
        3 1 roll 2 copy strcat 
        currentdict exch known {
          strcat cvn load 3 1 roll strcat cvn ED
          1 add
        } {
          pop (N) strcat cvn load 3 1 roll pop (N) strcat cvn ED
          pop
          exit
        } ifelse
      } loop
      [ (A) (B) (Center) (Label) (Rotref) (TrefA) (TrefB) (Ext)
      counttomark {
        counttomark 3 add -2 roll 2 copy counttomark 1 add 2 roll
        3 -1 roll dup 4 1 roll strcat cvn dup 
        currentdict exch known { load 3 1 roll exch strcat cvn ED } { pop pop pop } ifelse
      } repeat pop pop pop
    end
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optplane}
%    \begin{macrocode}
\def\optplane(#1)(#2)#3{%
  \pst@getcoor{#1}\pst@tempOrig%
  \pst@getcoor{#2}\pst@tempDiff%
  \pst@OptexpVerb{%
    {\pst@tempOrig} gsave STV CP T exec grestore ToVec 
    {\pst@tempDiff} (\POE@str@basicname@prefix#3) {} NewNodeComp
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\begin@OptexpObj}
% \begin{macro}{\begin@OptexpMultipole}
% \begin{macro}{\end@OptexpObj}
% \begin{macro}{\end@OptexpDipole}
% \begin{macro}{\end@OptexpMultipole}
%    \begin{macrocode}
\def\begin@OptexpObj{%
  \global\advance\POE@cnt by 1
  \addbefore@par{compname={}}
  \pst@killglue
  \begingroup
    \POE@insideobjtrue
    \pst@OptexpVerb{InitOptexpComp}%
    \use@par
%    \end{macrocode}
% Usually the shift refers to the y-direction, shifting in x-direction
% is done by 'abspos' or 'position'
%    \begin{macrocode}
    \let\POE@key@comp@Yshift\POE@key@compshift%
    \def\POE@key@comp@Xshift{0}%
}%
\def\begin@OptexpMultipole{%
  \begin@OptexpObj
%    \end{macrocode}
% for multipoles the default shifting is in x-direction
%    \begin{macrocode}
  \let\POE@key@comp@Xshift\POE@key@compshift%
   \def\POE@key@comp@Yshift{0}%
}%
\def\end@OptexpObj{%
    \edef\pst@temp{\POE@str@basicname@default\the\POE@cnt}%
    \ifx\POE@key@compname\pst@temp\else
      \POE@compalias{\POE@key@compname}{\pst@temp}%
    \fi
  \endgroup
  \ignorespaces%
}%
\let\end@OptexpDipole\end@OptexpObj
\let\end@OptexpMultipole\end@OptexpObj
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\addafter@par}
% Command analog to \cs{addbefore@par} which is defined in pstricks.tex
% \cs{addafter@par} inserts new options at the end of the current token register.
% This can be useful to preset options that are not allowed to be changed by the
% user.
%    \begin{macrocode}
\def\addafter@par#1{%
  \ifx\pst@par\@empty
    \def\pst@par{#1}%
  \else
    \toks@{#1}%
    \pst@toks\expandafter{\pst@par}%
    \edef\pst@par{\the\pst@toks,\the\toks@}%
  \fi%
}%
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\def\getCLWH{CLW \pst@number\psxunit 2 mul div }%
\def\getCLW{CLW \pst@number\psxunit div }%
%    \end{macrocode}
% 
% New high-level macros 
% 1) Allow a compressed notation of all provided elements, as most of the organizing code 
%    is mostly equal.
%
% 2) Provide a rather easy-to-use interface for the user to allow new user-defined elements
%
% \begin{macro}{\newOptexpDipole}
% \begin{macro}{\newOptexpTripole}
% \begin{macro}{\newOptexpFiberDipole}
% \begin{macro}{\newOptexpFiberQuadrupole}
%    \begin{macrocode}
\def\newOptexpDipole{%
  \@ifnextchar[%]
    {\POE@newdipole}{\POE@newdipole[]}%
}%
\def\newOptexpTripole{%
  \@ifnextchar[%]
    {\POE@newtripole}{\POE@newtripole[]}%
}%
\def\newOptexpFiberDipole{%
  \@ifnextchar[%]
    {\POE@newfiberdipole}{\POE@newfiberdipole[]}%
}%
\def\newOptexpFiberQuadrupole{%
  \@ifnextchar[%]
    {\POE@newfiberquadrupole}{\POE@newfiberquadrupole[]}%
}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\POE@newdipole}
%    \begin{macrocode}
\def\POE@newdipole[#1]#2#3{%
  \@ifundefined{#2@i}{%
    \@namedef{#2}{\pst@object{#2}}%
    \expandafter\def\csname #2@i\endcsname(##1)(##2){%
      \@ifnextchar\bgroup{\@nameuse{#2@i@}(##1)(##2)}{\@nameuse{#2@i@}(##1)(##2){}}%
    }%
    \expandafter\def\csname #2@i@\endcsname(##1)(##2)##3{%
      \addbefore@par{#3}%
      \addafter@par{#1}%
      \begin@OptexpObj
        \ifPOE@backlayer
          \POE@regNodes{##1}{##2}
          \POE@adjustTempNodes
        \fi
        \POE@drawcomponent[#2]{##3}{\@nameuse{#2@ii}}
        \ifPOE@backlayer
          \POE@drawInternalConnections
        \fi
      \end@OptexpObj
    }%
    \dipole@iimacro{#2}%
  }{%
    \@pstrickserr{OptExp dipole object `#2' already defined}\@eha}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@newfiberdipole}
%    \begin{macrocode}
\def\POE@newfiberdipole[#1]#2#3{%
  \@ifundefined{#2@i}{%
    \@namedef{#2}{\pst@object{#2}}%
    \expandafter\def\csname #2@i\endcsname(##1)(##2){%
      \@ifnextchar\bgroup{\@nameuse{#2@i@}(##1)(##2)}{\@nameuse{#2@i@}(##1)(##2){}}%
    }%
    \expandafter\def\csname #2@i@\endcsname(##1)(##2)##3{%
      \addbefore@par{fiber, #3}%
      \addafter@par{#1}%
      \begin@OptexpObj
        \ifPOE@backlayer
          \POE@regNodes{##1}{##2}
          \POE@adjustTempNodes
        \fi
        \POE@drawcomponent[#2]{##3}{\@nameuse{#2@ii}}
        \ifPOE@backlayer
          \POE@drawInternalConnections
        \fi
        \end@OptexpObj
      }%
      \fiberdipole@iimacro{#2}%
   }{%
     \@pstrickserr{OptExp fiber dipole object `#2' already defined}\@eha}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@newtripole}
% Equivalent to \cs{poe@newdipole} for tripole objects.
%    \begin{macrocode}
\def\POE@newtripole[#1]#2#3{%
  \@ifundefined{#2@i}{%
    \@namedef{#2}{\pst@object{#2}}%
    \expandafter\def\csname #2@i\endcsname(##1)(##2)(##3){%
      \@ifnextchar\bgroup{\@nameuse{#2@i@}(##1)(##2)(##3)}{\@nameuse{#2@i@}(##1)(##2)(##3){}}%
    }%
    \expandafter\def\csname #2@i@\endcsname(##1)(##2)(##3)##4{%
      \addbefore@par{#3}%
      \addafter@par{ref@angle=180,#1}%
      \begin@OptexpMultipole
        \POE@calcNodes{##1}{##2}{##3}%
        \POE@drawcomponent[#2]{##4}{\@nameuse{#2@ii}}
        \ifPOE@backlayer
          \pst@getcoor{##1}\pst@tempA%
          \pst@getcoor{##3}\pst@tempB%
          \pst@OptexpVerb{%
            tx@NodeDict begin
            {\pst@tempA } false chirality 0 le { /N@\oenodeRefB{}\space }{ /N@\oenodeRefA{}\space } ifelse
            10 {InitPnode } NewNode
            {\pst@tempB } false chirality 0 le { /N@\oenodeRefA{}\space }{ /N@\oenodeRefB{}\space } ifelse
            10 {InitPnode } NewNode
            end
          }%
          \POE@drawInternalConnections
        \fi
      \end@OptexpMultipole
    }%
    \tripole@iimacro{#2}%
  }{%
    \@pstrickserr{OptExp tripole object `#2' already defined}\@eha}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@newfiberquadrupole}
%    \begin{macrocode}
\def\POE@newfiberquadrupole[#1]#2#3{%
  \@ifundefined{#2@i}{%
    \@namedef{#2}{\pst@object{#2}}%
    \expandafter\def\csname #2@i\endcsname(##1)(##2)(##3)(##4){%
      \@ifnextchar\bgroup{\@nameuse{#2@i@}(##1)(##2)(##3)(##4)}{\@nameuse{#2@i@}(##1)(##2)(##3)(##4){}}%
    }%
    \expandafter\def\csname #2@i@\endcsname(##1)(##2)(##3)(##4)##5{%
      \addbefore@par{fiber, #3}%
      \addafter@par{#1}%
      \begin@OptexpObj
        \ifPOE@backlayer
          \ifx\POE@key@align\POE@str@top
            \pnode(##1){\oenodeRefA{}}
            \pnode(##3){\oenodeRefB{}}
          \else\ifx\POE@key@align\POE@str@bottom
            \pnode(##2){\oenodeRefA{}}
            \pnode(##4){\oenodeRefB{}}
          \else
            \pst@getcoor{##1}\pst@tempA%
            \pst@getcoor{##2}\pst@tempB%
            \pnode(!\pst@tempA \pst@tempB \pst@optexpdict mwNode end \tx@UserCoor){\oenodeRefA{}}
            \pst@getcoor{##3}\pst@tempA%
            \pst@getcoor{##4}\pst@tempB%
            \pnode(!\pst@tempA \pst@tempB \pst@optexpdict mwNode end \tx@UserCoor){\oenodeRefB{}}
         \fi\fi
       \fi
       \POE@drawcomponent[#2]{##5}{\@nameuse{#2@ii}}
       \ifPOE@backlayer
         \ifPOE@fiberin@top
           \drawfiber@{FiberIn1}[stopnode=1]{(##1)}{\POE@key@compname}
         \fi
         \ifPOE@fiberin@bottom
           \drawfiber@{FiberIn2}[stopnode=2]{(##2)}{\POE@key@compname}
         \fi
         \ifPOE@fiberout@top
           \drawfiber@{FiberOut}[startnode=3]{\POE@key@compname}{(##3)}
         \fi
         \ifPOE@fiberout@bottom
           \drawfiber@{FiberOut2}[startnode=N]{\POE@key@compname}{(##4)}
         \fi
       \fi
     \end@OptexpObj
    }%
    \fiberdipole@iimacro{#2}%
  }{%
    \@pstrickserr{OptExp fiber quadrupole object `#2' already defined}\@eha}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\dipole@iimacro}
% \begin{macro}{\fiberdipole@iimacro}
% \begin{macro}{\tripole@iimacro}
%    \begin{macrocode}
\def\dipole@iimacro#1{%
  \dipole@iimacro@{#1}{\dipole@nodes}%
\ignorespaces}%
\def\fiberdipole@iimacro#1{%
  \dipole@iimacro@{#1}{\fiberdipole@nodes}%
\ignorespaces}%
\def\tripole@iimacro#1{%
  \dipole@iimacro@{#1}{\tripole@nodes}%
\ignorespaces}%
\def\dipole@iimacro@#1#2{%
  \@namedef{#1@ii}{%
    \ifPOE@backlayer
      \pnode(0,0){\oenodeCenter{}}%
    \fi
    \@ifundefined{#1@iii}{%
      \ifPOE@backlayer
        \@ifundefined{#1@nodes}{#2}{\@nameuse{#1@nodes}}%
      \fi
      \ifPOE@frontlayer
        \@nameuse{#1@comp}%
      \fi
    }{%
      \ifPOE@backlayer
        \@nameuse{#1@iii}%
      \fi
    }%
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\wdmsplitter}
%    \begin{macrocode}
\def\wdmsplitter{\pst@object{wdmsplitter}}%
\def\wdmsplitter@i(#1)(#2)(#3){%
  \@ifnextchar\bgroup{\wdmsplitter@i@(#1)(#2)(#3)}{\wdmsplitter@i@(#1)(#2)(#3){}}%
}%
\def\wdmsplitter@i@(#1)(#2)(#3)#4{%
  \addbefore@par{fiber}%
  \begin@OptexpObj
    \ifPOE@backlayer
      \pnode(#1){\oenodeRefA{}}
      \ifx\POE@key@align\POE@str@top
         \pnode(#2){\oenodeRefB{}}
      \else\ifx\POE@key@align\POE@str@bottom
         \pnode(#3){\oenodeRefB{}}
      \else
         \pst@getcoor{#2}\pst@tempA%
         \pst@getcoor{#3}\pst@tempB%
         \pnode(!\pst@tempA\pst@number\psyunit div exch \pst@number\psxunit div exch
                 \pst@tempB\pst@number\psyunit div exch \pst@number\psxunit div exch 
                 \pst@optexpdict mwNode end \POE@key@coupleroutshift\space add){\oenodeRefB{}}
      \fi\fi
    \fi
    \POE@drawcomponent[wdmsplitter]{#4}\wdmsplitter@ii
    \ifPOE@backlayer
      \ifPOE@fiberin@
        \drawfiber@{FiberIn}[stopnode=1]{(#1)}{\POE@key@compname}
      \fi
      \ifPOE@fiberout@top
        \drawfiber@{FiberOut1}[startnode=2]{\POE@key@compname}{(#2)}
      \fi
      \ifPOE@fiberout@bottom
        \drawfiber@{FiberOut2}[startnode=N]{\POE@key@compname}{(#3)}
      \fi
    \fi
  \end@OptexpObj
}%
\fiberdipole@iimacro{wdmsplitter}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmcoupler}
%    \begin{macrocode}
\def\wdmcoupler{\pst@object{wdmcoupler}}%
\def\wdmcoupler@i(#1)(#2)(#3){%
  \@ifnextchar\bgroup{\wdmcoupler@i@(#1)(#2)(#3)}{\wdmcoupler@i@(#1)(#2)(#3){}}%
}%
\def\wdmcoupler@i@(#1)(#2)(#3)#4{%
  \addbefore@par{fiber}%
  \begin@OptexpObj
    \ifPOE@backlayer
      \pnode(#3){\oenodeRefB{}}
      \ifx\POE@key@align\POE@str@top
         \pnode(#1){\oenodeRefA{}}
      \else\ifx\POE@key@align\POE@str@bottom
         \pnode(#2){\oenodeRefA{}}
      \else
         \pst@getcoor{#1}\pst@tempA%
         \pst@getcoor{#2}\pst@tempB%
         \pnode(!\pst@tempA\pst@number\psyunit div exch \pst@number\psxunit div exch
                 \pst@tempB\pst@number\psyunit div exch \pst@number\psxunit div exch 
                 \pst@optexpdict mwNode end){\oenodeRefA{}}
      \fi\fi
    \fi
    \POE@drawcomponent[wdmcoupler]{#4}\wdmcoupler@ii
    \ifPOE@backlayer 
      \ifPOE@fiberout@
        \drawfiber@{FiberOut}[startnode=N]{\POE@key@compname}{(#3)}
      \fi
      \ifPOE@fiberin@top
        \drawfiber@{FiberIn1}[stopnode=1]{(#1)}{\POE@key@compname}
      \fi
      \ifPOE@fiberin@bottom
        \drawfiber@{FiberIn2}[stopnode=2]{(#2)}{\POE@key@compname}
      \fi
    \fi
  \end@OptexpObj
}%
\fiberdipole@iimacro{wdmcoupler}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@calcNodes}
%   Some of the components need three points to be positioned. 
%   These are:
%
% \begin{enumerate}
% \item starting point of the beam (in the PS-Code: (XA,YA)) 
% \item reflection point on the surface (XG, YG) 
% \item end point (XB,YB)
%  \end{enumerate}     
%
%  With these three points \cs{poe@calcNodes} calculates two new points 'tempNode@A' 
%  and 'tempNode@B', between which the component is placed by the macro 
%  \cs{poe@drawcomponent} in the way, that 'angle of incidence' == 'angle of deflection'
%  regarding the reflection surface (mirror, diagonal of the beamsplitter, 
%  grid etc.)
%    \begin{macrocode}
\def\POE@calcNodes#1#2#3{{%
  \pst@getcoor{#1}\pst@tempa%
  \pst@getcoor{#2}\pst@tempb%
  \pst@getcoor{#3}\pst@tempc%
  \pnode(!%
     \pst@optexpdict
     \pst@tempa \tx@UserCoor
     \pst@tempc \tx@UserCoor
     \pst@tempb \tx@UserCoor
     calcNodes
     /ExchCoorSwitch 
     Y@A X@A neg Y@B X@B neg ExchCoor def
     X@A Y@A end){\oenodeRefA{}}%
  \pnode(! \POE@dict{X@B Y@B}){\oenodeRefB{}}%
  \pst@OptexpVerb{/@xref \POE@key@xref\space def /@yref \POE@key@yref\space def}%
}\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@regNodes}
% If a macro needs only two points, they are equivalent to 
% 'tempNode@A' and 'tempNode@B'. But for easier implementation of other 
% macros the given points are assigned to the temporary nodes.
%    \begin{macrocode}
\def\POE@regNodes#1#2{%
    \pnode(#1){\oenodeRefA{}}
    \pnode(#2){\oenodeRefB{}}
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@adjustTempNodes}
%    \begin{macrocode}
\def\POE@adjustTempNodes{%
    \pst@OptexpVerb{%
      (N@\oenodeRefA{}) @GetCenter (N@\oenodeRefB{}) @GetCenter
      currentdict /chirality known not {%
        /chirality 1 def 
      } if
      ExchCoor dup /ExchCoorSwitch ED 
      {/@xref \POE@key@xref\space neg def /@yref \POE@key@yref\space neg def} 
      {/@xref \POE@key@xref\space def /@yref \POE@key@yref\space def} ifelse
    }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@pnode@shiftedrot}
% Define a new node \#3 shifted by (\#1) relative to existing node \#2.
% Aditionally rotate the new node by \#4 degree around existing node as origin.
%    \begin{macrocode}
\def\POE@pnode@shiftedrot(#1)#2#3#4{%
    \pst@getcoor{#1}\pst@tempDiff%
    \pnode(!%
       \pst@tempDiff /YDiff ED /XDiff ED %
         /N@#2 load GetCenter /YShifted ED /XShifted ED
         /rot@angle #4 \POE@key@labelrefangle\space add def
         /XDiff@Rot rot@angle cos XDiff mul rot@angle sin YDiff mul add def
         /YDiff@Rot rot@angle cos YDiff mul rot@angle sin XDiff mul sub def
         XShifted XDiff@Rot add YShifted YDiff@Rot add neg \tx@UserCoor
       ){#3}%
    \psset{ref@angle=0}
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@putlabelrelative}
% Used to put the label for labelref=relative
%    \begin{macrocode}
\def\POE@putlabelrelative#1{%
   \nput[labelsep=0]{\POE@key@labelangle}%
        {\oenodeLabel{}}%
        {\rput[\POE@key@labelalign](0,0){\POE@key@labelstyle #1}}%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@putcomp}
% Place the component in argument \#1 and define a new node \cs{poe@nodeLabelShifted}
% for positioning of the label
%    \begin{macrocode}
\def\POE@putcomp#1#2{%
  \@ifundefined{#1@ref}{}{\@nameuse{#1@ref}}%
   \rput(\POE@key@comp@Xshift,\POE@key@comp@Yshift){%
     \pnode(! \POE@dict{@@x0 @@x \POE@key@rotate@xref\space mul add
                        @@y0 @@y \POE@key@rotate@yref\space mul add}){\oenodeRotref{}}%
     \ifdim\POE@key@angle pt=0pt
        #2%
        \POE@pnode@shiftedrot(0,\POE@key@labeloffset)%
                             {\oenodeCenter{}}%
                             {\oenodeLabel{}}%
                             {\POE@key@labelangle}%
     \else
        \psrotate(\oenodeRotref{}){\POE@key@angle}{%
          #2%
          \POE@pnode@shiftedrot(0,\POE@key@labeloffset)%
                               {\oenodeCenter{}}%
                               {\oenodeLabel{}}%
                               {\POE@key@labelangle}%
        }%
     \fi%
   }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@putlabel}
% Positioning of the label depending on the reference coordinates.
% Needs possibly a previously defined node \cs{poe@nodeLabelShifted} which
% marks exactly the position of the label relative to the component.
% This is defined by calling \cs{poe@putcomp}.
% 
% Parameter 'labelref' which sets the reference coordinates can have 
% the values 
% \begin{description}
% \item[global] labelangle rotates the label origin in global coordinate system, text is not rotated
% \item[relgrav] labelangle rotates the label origin relativ to the local coordinate system of the component, text is not rotated
% \item[relative] as relgrav but text is rotated together with object.
% \end{description}
%    \begin{macrocode}  
\def\POE@putlabel#1{%
   \def\pst@temp{#1}%
   \ifx\pst@temp\@empty\else
   \ifx\POE@key@labelref\POE@str@labelref@global
      \nput[labelsep=\POE@key@labeloffset]%
           {\POE@key@labelangle}%
           {\oenodeCenter{}}%
           {\rput[\POE@key@labelalign](0,0){\POE@key@labelstyle #1}}%
   \else\ifx\POE@key@labelref\POE@str@labelref@relgrav
      \rput[\POE@key@labelalign](\oenodeLabel{}){\POE@key@labelstyle #1}%
   \else\ifx\POE@key@labelref\POE@str@labelref@relative
      \begingroup
%    \end{macrocode}
% Redefine InitNC only for positioning of the label with labelref=relative
%    \begin{macrocode}
      \pst@def{InitNC}<       % kindly contributed by Herbert Voss
      /b ED /a ED % second and first node
      /NodeSepTypeB ED /NodeSepTypeA ED
      /NodeSepB ED /NodeSepA ED
      /OffsetB ED /OffsetA ED
      tx@NodeDict a known tx@NodeDict b known and dup {
        /NodeA a load def /NodeB b load def
        NodeA GetCenter NodeB GetCenter % xA yA xB yB
        4 copy exch 4 -1 roll 2 copy gt % yA yB xB xA
          { pop pop pop pop /yB ED /xB ED /yA ED /xA ED }
          { eq 3 1 roll lt and 
              { /yB ED /xB ED /yA ED /xA ED} 
              { /yA ED /xA ED /yB ED /xB ED} ifelse
          } ifelse
      } if >%
      \ncline[linestyle=none,fillstyle=none,npos=]{\oenodeRefA{}}{\oenodeRefB{}}%
      \ifx\POE@key@position\@empty
         \ifx\POE@key@abspos\@empty
            \ncput[nrot=:U,npos=]{\POE@putlabelrelative{#1}}%
         \else
            \nlput[nrot=:U](\oenodeRefA{})(\oenodeRefB{}){\POE@key@abspos}{\POE@putlabelrelative{#1}}%
         \fi
      \else
         \ncput[nrot=:U,npos=\POE@key@position]{\POE@putlabelrelative{#1}}
      \fi
      \endgroup
   \fi\fi\fi
   \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{Free-Ray Components}
%
% Define all free-ray dipoles
%    \begin{macrocode}
\newOptexpDipole{lens}{}%
\newOptexpDipole{pinhole}{}%
\newOptexpDipole{crystal}{}%
\newOptexpDipole{polarization}{}%
\newOptexpDipole{optbox}{}%
\newOptexpDipole{optplate}{}%
\newOptexpDipole{optretplate}{}%
\newOptexpDipole[endbox]{optdetector}{}%
\newOptexpDipole{optdiode}{}%
\newOptexpDipole{doveprism}{}%
%    \end{macrocode}
% 
% Define all free-ray tripoles
%    \begin{macrocode}
\newOptexpTripole{mirror}{}%
\newOptexpTripole[ref@angle=-135]{beamsplitter}{}%
\newOptexpTripole{optgrating}{}%
\def\optgrid{%
  \PackageWarning{pst-optexp}{\protect\optgrid\space is deprecated, use \protect\optgrating\space instead.}%
  \optgrating%
}%
\newOptexpTripole[ref@angle=-135]{pentaprism}{}%
\newOptexpTripole[ref@angle=-135]{rightangleprism}{}%
\newOptexpTripole[ref@angle=-135]{optprism}{}%
%    \end{macrocode}
%
% \begin{macro}{\optdipole}
%    \begin{macrocode}
\def\optdipole{\pst@object{optdipole}}
\def\optdipole@i(#1)(#2)#3#4{%
   \begin@OptexpObj
      \ifPOE@backlayer
        \POE@regNodes{#1}{#2}
        \POE@adjustTempNodes
      \fi
      \POE@drawcomponent{#4}{%
        \ifPOE@backlayer
          \pnode(0,0){\oenodeCenter{}}%
          \newOptexpComp{{ 0 0 } { 0 1 } trans {NewPlaneInt} 1 }%
        \fi
        \ifPOE@frontlayer
          #3
        \fi
      }%
      \ifPOE@backlayer
        \POE@drawInternalConnections
      \fi
   \end@OptexpObj
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\opttripole}
%    \begin{macrocode}
\def\opttripole{\pst@object{opttripole}}
\def\opttripole@i(#1)(#2)(#3)#4#5{%
   \begin@OptexpMultipole
      \POE@calcNodes{#1}{#2}{#3}
      \POE@drawcomponent{#5}{%
         \pnode(0,0){\oenodeCenter{}}% 
         \newOptexpComp{{ 0 0 } { 1 0 } refl {NewPlaneInt} 1 }%
         #4
      }%
%    \end{macrocode}
% adjust tempNode@A and tempNode@B for the connections
% check if node must be switched, therefore we implement this
% directly as PS code
%    \begin{macrocode}
      \pst@getcoor{#1}\pst@tempA%
      \pst@getcoor{#3}\pst@tempB%
      \pst@OptexpVerb{%
         tx@NodeDict begin
            {\pst@tempA } false chirality 0 le { /N@\oenodeRefB{}\space }{ /N@\oenodeRefA{}\space } ifelse
             10 {InitPnode } NewNode
             {\pst@tempB } false chirality 0 le { /N@\oenodeRefA{}\space }{ /N@\oenodeRefB{}\space } ifelse
             10 {InitPnode } NewNode
         end
      }%
      \POE@drawInternalConnections
   \end@OptexpMultipole
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\fibercollimator}
%    \begin{macrocode}
\def\fibercollimator{\pst@object{fibercollimator}}
\def\fibercollimator@i(#1)(#2){%
   \def\pst@tempA{#1}%        
   \def\pst@tempB{#2}%
   \def\pst@tempC{}%
   \def\pst@tempD{}%
   \@ifnextchar(%)
     {\fibercollimator@ii}{\fibercollimator@iv}%
}%
\def\fibercollimator@ii(#1){%
   \def\pst@tempC{#1}%
   \@ifnextchar(%)
     {\fibercollimator@iii}{\fibercollimator@iv}%
}%
\def\fibercollimator@iii(#1)#2{%
   \def\pst@tempD{#1}%
   \fibercollimator@iv{#2}%
}%
\def\fibercollimator@iv#1{%
  \ifPOE@compat
    \addbefore@par{conn=o-f}%
  \fi
  \addbefore@par{fiberout=both}%
  \begin@OptexpObj
    \POE@regNodes{\pst@tempA}{\pst@tempB}%
    \POE@adjustTempNodes
    \POE@drawcomponent[fibercollimator]{#1}{%
       \pnode(0,0){\oenodeCenter{}}%
       \ifPOE@backlayer
         \fibercollimator@nodes
       \fi
       \ifPOE@frontlayer
         \fibercollimator@comp
       \fi
    }%
    \ifPOE@backlayer
      \ifPOE@compat
        \@nameuse{\POE@connIn}
      \else
        \ifPOE@beam
          \drawbeam{(\oenodeRefA{})}{\POE@key@compname}
        \fi
      \fi
      \ifPOE@fiberout@
        \ifx\@empty\pst@tempC
          \ifPOE@compat
            \@nameuse{\POE@connOut}
          \else
            \drawfiber{\POE@key@compname}{(\oenodeRefB{})}
          \fi
        \else\ifx\@empty\pst@tempD
          \psbezier[style=FiberOut](\pst@tempC)(\pst@tempB)(\pst@tempB)(\oenodeOut{})%
        \else
          \psbezier[style=FiberOut](\pst@tempD)(\pst@tempC)(\pst@tempB)(\oenodeOut{})%
        \fi\fi
      \fi
    \fi
  \end@OptexpObj
}%
%    \end{macrocode}
% \end{macro}
% 
% Define all fiber dipoles
%    \begin{macrocode}
\newOptexpFiberDipole{optfiber}{}
\newOptexpFiberDipole{optamp}{}
\newOptexpFiberDipole{optmzm}{}
\newOptexpFiberDipole{optfilter}{}
\newOptexpFiberDipole{polcontrol}{}
\newOptexpFiberDipole{optisolator}{}
\newOptexpFiberDipole{optfiberpolarizer}{}
\newOptexpFiberDipole{optswitch}{}
\newOptexpFiberDipole{fiberdelayline}{}
%    \end{macrocode}
% Define all fiber quadrupoles
%    \begin{macrocode}
\newOptexpFiberQuadrupole{optcoupler}{}
%    \end{macrocode}
%
% \begin{macro}{\POE@drawcomponent}
% This macro is called by every unit
% The first parameter contains the label, the second one the drawing code
%    \begin{macrocode}
\def\POE@drawcomponent{%
  \@ifnextchar[%]
    {\POE@drawcomponent@i}{\POE@drawcomponent@i[]}%
}%
\def\POE@drawcomponent@i[#1]#2#3{%
  \def\@@comp{%
    #3%
    \ifx\POE@key@extnode\@empty\else
      \ifPOE@backlayer
        \pnode(! \POE@dict{ExtNode}){\POE@key@extnoden@me}%
      \fi
    \fi
  }%
  \ifPOE@endbox%
    \ifx\POE@key@labeloffset\@empty
      \psset{labeloffset=0}%
    \fi
    \psset{position=1}%
  \fi%
  \ncline[linestyle=none,fillstyle=none,npos=]{\oenodeRefA{}}{\oenodeRefB{}}%
%    \end{macrocode}
% Positioning of the component
%    \begin{macrocode}
  \begingroup
    \psset{style=OptComp}%
%    \end{macrocode}
% linestyle to use, if component should be marked as optional
%    \begin{macrocode}
    \ifPOE@component@optional
      \psset{style=OptionalStyle}%
    \fi
%    \end{macrocode}
% if parameter 'position' is given, use it for 'npos'
%    \begin{macrocode}
    \ifx\POE@key@position\@empty
%    \end{macrocode}
% then check if absolute positioning is wanted
%    \begin{macrocode}
      \ifx\POE@key@abspos\@empty
        \ncput[nrot=:U,npos=]{\POE@putcomp{#1}{\@@comp}}%
      \else
        \nlput[nrot=:U](\oenodeRefA{})(\oenodeRefB{}){\POE@key@abspos}{\POE@putcomp{#1}{\@@comp}}%
      \fi
    \else
      \ncput[nrot=:U,npos=\POE@key@position]{\POE@putcomp{#1}{\@@comp}}%
    \fi
  \endgroup
  \ifPOE@frontlayer
    \POE@putlabel{#2}%
  \fi
  \ifPOE@backlayer
    \pnode(! \POE@dict{%
               (N@\oenodeRotref{}) @GetCenter 2 copy
               (N@\oenodeRefA{}) @GetCenter \POE@key@comp@Xshift\space\POE@key@comp@Yshift\space\tx@ScreenCoor VecAdd 4 2 roll @ABVect \POE@key@angle\space matrix rotate dtransform VecAdd
             \tx@UserCoor}){\oenodeTrefA{}}%
    \pnode(! \POE@dict{%
               (N@\oenodeRotref{}) @GetCenter 2 copy
               (N@\oenodeRefB{}) @GetCenter \POE@key@comp@Xshift\space\POE@key@comp@Yshift\space\tx@ScreenCoor VecAdd 4 2 roll @ABVect \POE@key@angle\space matrix rotate dtransform VecAdd
             \tx@UserCoor}){\oenodeTrefB{}}%
  \fi
%    \end{macrocode}
% Show some special dots for debugging
%    \begin{macrocode}
  \ifPOE@debug@showoptdots
    \ifPOE@backlayer
      \psdot[linecolor=green](\oenodeCenter{})
      \psdot[linecolor=red](\oenodeLabel{})
      \psdot[linecolor=black](\oenodeRefA{})
      \psdot[linecolor=black](\oenodeRefB{})
    \fi
  \fi
  \ifPOE@debug@showifcnodes
    \ifPOE@backlayer
      \oeifcnodes[linecolor=blue]{\POE@key@b@sicname}
    \fi
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\oeifcnodes}
%    \begin{macrocode}
\def\oeifcnodes{\pst@object{oeifcnodes}}
\def\oeifcnodes@i#1{%
  \begin@SpecialObj%
  \solid@star%
  \addto@pscode{
    \psk@dotsize
    \@nameuse{psds@\psk@dotstyle}
    \POE@dict{[ (#1) false GetInternalBeamNodes %]
      counttomark 2 idiv { Dot } repeat
      pop}
    }%
  \end@SpecialObj
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\tripole@nodes}
%    \begin{macrocode}
\def\tripole@nodes{%
  \newOptexpComp{ {0 0} {1 0} refl {NewPlaneInt} 1}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\dipole@nodes}
%    \begin{macrocode}
\def\dipole@nodes{%
  \newOptexpComp{%
    {@@x0 @@x sub 0} {0 1} trans {NewPlaneInt} 
    @@x 0 eq not {
      {@@x0 @@x add 0} {0 1} trans {NewPlaneInt}
    } if \POE@key@n }%
  \pnode(! \POE@dict{@@x0 @@y0}){\oenodeCenter{}}
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{fiberdipole@nodes}
%    \begin{macrocode}
\def\fiberdipole@nodes{%
  \pnode(! \POE@dict{@@x0 @@x sub 0}){\oenodeIn{}}
  \pnode(! \POE@dict{@@x0 @@x add 0}){\oenodeOut{}}
  \pnode(! \POE@dict{@@x0 @@y0}){\oenodeCenter{}}
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\mirror@ref}
%    \begin{macrocode}
\def\mirror@ref{%
  \ifx\POE@key@mirrortype\POE@str@mirrortype@piezo
    \pst@OptexpVerb{/@@y0 \pst@number\psyunit def}%
    \bgroup
      \psset{style=PiezoMirror}
      \pst@OptexpVerb{\pst@number\psyunit @@y0 div \POE@key@mirrorwidth\space 0.5 mul mul 2.5 div /@@y0 ED}%
    \egroup
  \else\ifdim\POE@key@mirrorradius pt=0pt
    \pst@OptexpVerb{/@@x \POE@key@mirrorwidth\space 0.5 mul def}%
  \fi\fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\mirror@nodes}
%    \begin{macrocode}
\def\mirror@nodes{%
   \newOptexpComp{{ 0 0 } 
                  \ifdim\POE@key@mirrorradius pt=0pt
                     { 1 0 } refl {NewPlaneInt}
                  \else
                     { 0 \POE@key@mirrorradius\space neg} refl {NewCurvedInt}
                  \fi
                  1 }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\mirror@comp}
%    \begin{macrocode}
\def\mirror@comp{%
  \edef\@ht{\POE@key@mirrorwidth\space\pst@number\psyunit mul 0.5 mul }%
  \edef\@dp{\POE@key@mirrordepth\space\pst@number\psxunit mul }%
  \edef\@r{\POE@key@mirrorradius\space\pst@number\psxunit mul }%
  \edef\@postcode{neg 5 -1 roll exch 5 2 roll 90 add exch 90 add exch ArcR }%
  \edef\@extpostcode{neg \@dp add 5 -1 roll exch 5 2 roll 90 add exch 90 add }%
%    \end{macrocode}
% concave mirrors
%    \begin{macrocode}
  \ifdim\POE@key@mirrorradius pt<0pt
    \ifx\POE@key@mirrortype\POE@str@mirrortype@extended
%    \end{macrocode}
% extended concave mirror
%    \begin{macrocode}
      \bgroup
        \psset{style=ExtendedMirror}
        \begin@ClosedObj
          \addto@pscode{%
            \pst@optexpdict \@ht \@r rightConcave \@postcode  
            \@ht \@r rightConcave \@extpostcode arc
            closepath end}%
        \end@ClosedObj
      \egroup
    \fi
    \begin@OpenObj
      \addto@pscode{\pst@optexpdict \@ht \@r rightConcave \@postcode end}%
    \end@OpenObj
%    \end{macrocode}
% convex mirrors
%    \begin{macrocode}
  \else\ifdim\POE@key@mirrorradius pt>0pt
    \ifx\POE@key@mirrortype\POE@str@mirrortype@extended
%    \end{macrocode}
% extended convex mirror
%    \begin{macrocode}
      \bgroup
        \psset{style=ExtendedMirror}
        \begin@ClosedObj
          \addto@pscode{%
            \pst@optexpdict \@ht \@r rightConvex \@postcode
            \@ht \@r rightConvex \@extpostcode arcn
            closepath end}%
        \end@ClosedObj
      \egroup
    \fi
   \begin@OpenObj
     \addto@pscode{\pst@optexpdict \@ht \@r rightConvex \@postcode end}%
   \end@OpenObj
  \else
%    \end{macrocode}
% plain mirror 
%    \begin{macrocode}
    \edef\@ht{\POE@key@mirrorwidth\space 0.5 mul }%
    \ifPOE@variable
      \psarc[style=VariableMirror](! \@ht 0.4 sub 0){0.6}{-20}{20}
      \psarc[style=VariableMirror](! \@ht 0.4 sub neg 0){0.6}{160}{200}
     \fi%
     \ifx\POE@key@mirrortype\POE@str@mirrortype@piezo%
       \psframe[style=PiezoMirror,dimen=outer](! \@ht 4 div 0)(! \@ht -4 div \@ht 2.5 div)
       \ifx\POE@key@extnode\@empty
         \psbezier(! 0 \@ht 2.5 div)%
                  (! 0 \@ht 1.5 div)%
                  (! \@ht 2 div \@ht 2 div)%
                  (! \@ht 4 div \@ht)%
       \fi
    \else\ifx\POE@key@mirrortype\POE@str@mirrortype@extended%
      \psframe[style=ExtendedMirror]%
         (! \@ht neg \POE@key@mirrordepth\space )%
         (! \@ht 0)%
    \fi\fi
    \psline[linewidth=\POE@key@mirrorlinewidth](! \@ht neg \getCLWH)(! \@ht \getCLWH)
  \fi\fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\lens@ref}
%    \begin{macrocode}
\def\lens@ref{%
  \pst@OptexpVerb{/@@y \POE@key@lensheight\space 0.5 mul def}%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\lens@nodes}
%    \begin{macrocode}
\def\lens@nodes{%
  \edef\@lens@th{0}% 
  \ifdim\POE@key@lensradiusleft pt=0pt\else
    \edef\@lens@th{\ifPOE@thicklens \POE@key@lenswidth\space 2 div \else \POE@key@lensradiusleft\space\POE@key@lensheight\space 2 div segLen \fi}%     
  \fi
  \ifdim\POE@key@lensradiusright pt=0pt\else
    \edef\@lens@th{\@lens@th\space\ifPOE@thicklens \POE@key@lenswidth\space 2 div\else \POE@key@lensradiusright\space\POE@key@lensheight\space 2 div segLen \fi\space add}%
  \fi
  \newOptexpComp{{\@lens@th\space -2 div 0} 
                  \ifdim\POE@key@lensradiusleft pt=0pt 
                      {0 1} trans {NewPlaneInt}
                   \else 
                      {\POE@key@lensradiusleft\space 0} trans {NewCurvedInt}
                   \fi
                   {\@lens@th\space 2 div 0} 
                   \ifdim\POE@key@lensradiusright pt=0pt
                      {0 1} trans {NewPlaneInt}
                   \else
                      {\POE@key@lensradiusright\space neg 0} trans {NewCurvedInt} 
                   \fi
                   \POE@key@n}%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\lens@comp}
%    \begin{macrocode}
\def\lens@comp{%
  \addbefore@par{linejoin=1}%
  \begin@ClosedObj
  \edef\@lens@newwd{0 }%
  \edef\@lens@wd{\POE@key@lenswidth\space\pst@number\psxunit mul 2 div }%
  \edef\@lens@th{0}%
  \addto@pscode{%
    \pst@optexpdict
    /@wd \POE@key@lenswidth\space\pst@number\psxunit mul 2 div def
    /@ht \POE@key@lensheight\space\pst@number\psyunit mul 2 div def
    /@rL \POE@key@lensradiusleft\space\pst@number\psxunit mul def
    /@rR \POE@key@lensradiusright\space\pst@number\psxunit mul def
    /@th 0 def
  }%
%    \end{macrocode}
% distinguish between all the different lens-combination possibilities
%    \begin{macrocode}
  \ifdim\POE@key@lensradiusleft pt=0pt\else
%    \end{macrocode}
% this takes the /a1 definition from the leftC* procedures
% the macro is necessary for the outer nodes
%    \begin{macrocode}
    \edef\@lens@newwd{%
      \POE@key@lensradiusleft\space\POE@key@lensheight\space 2 div segLen
      \ifdim\POE@key@lensradiusleft pt<0pt
        0.5 mul\space
      \fi
    }%
    \edef\@lens@th{%
      \ifPOE@thicklens
        \POE@key@lenswidth\space 2 div 
      \else
        \POE@key@lensradiusleft\space\POE@key@lensheight\space 2 div segLen
      \fi
    }%
    \addto@pscode{%
      /@th \ifPOE@thicklens @wd \else @rL @ht segLen \fi def
      @ht @rL
      \ifdim\POE@key@lensradiusleft pt<0pt
        leftConcave
      \else
        leftConvex
      \fi
    }%
  \fi
  \ifdim\POE@key@lensradiusright pt=0pt\else
%    \end{macrocode}
% this takes the /a1 definition from the rightC* procedures
% the macro is necessary for the outer nodes
%    \begin{macrocode}
    \edef\@lens@th{%
      \@lens@th\space
      \ifPOE@thicklens 
        \POE@key@lenswidth\space 2 div
      \else
        \POE@key@lensradiusright\space\POE@key@lensheight\space 2 div segLen 
      \fi\space add
    }%
    \addto@pscode{%
      /@th @th \ifPOE@thicklens @wd \else @rR @ht segLen \fi add def
      @ht @rR
      \ifdim\POE@key@lensradiusright pt<0pt
        rightConcave
      \else
        rightConvex
      \fi
    }%
  \fi
%    \end{macrocode}
% Check some special cases:
%
% 1) Left is plain - right concave / convex
%    \begin{macrocode}
  \ifdim\POE@key@lensradiusleft pt=0pt
    \ifdim\POE@key@lensradiusright pt=0pt\else
      \addto@pscode{%
        @th 2 div sub neg 5 1 roll
        @th 2 div neg @ht neg moveto ArcR
        @th 2 div neg @ht lineto
      }%
    \fi
  \fi
%    \end{macrocode}
% 2) Right is plain - left concave / convex
%    \begin{macrocode}
  \ifdim\POE@key@lensradiusright pt=0pt
    \ifdim\POE@key@lensradiusleft pt=0pt\else
      \addto@pscode{%
        @th 2 div sub 5 1 roll
        @th 2 div @ht moveto ArcL
        @th 2 div @ht neg lineto
      }%
    \fi
  \fi
%    \end{macrocode}
% 3) right and left are both curved
%    \begin{macrocode}
  \ifdim\POE@key@lensradiusright pt=0pt\else
    \ifdim\POE@key@lensradiusleft pt=0pt\else
      \addto@pscode{%
        @th 2 div dup
        7 1 roll sub neg 5 1 roll
        ArcR sub 5 1 roll ArcL
      }%
    \fi
  \fi
%    \end{macrocode}
% now complete the object
%    \begin{macrocode}
  \addto@pscode{closepath 1 setlinejoin end }%
  \end@ClosedObj
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\pinhole@ref}
%    \begin{macrocode}
\def\pinhole@ref{%
  \pst@OptexpVerb{/@@y \POE@key@outerheight\space 0.5 mul def}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\pinhole@comp}
%    \begin{macrocode}
\def\pinhole@comp{%
  \ifdim\POE@key@phwidth pt=0pt
    \psline[linewidth=\POE@key@phlinewidth]%
           (! 0 \POE@key@outerheight\space 2 div)%
           (! 0 \POE@key@innerheight\space 2 div)%
    \psline[linewidth=\POE@key@phlinewidth]%
           (! 0 \POE@key@outerheight\space -2 div)%
           (! 0 \POE@key@innerheight\space -2 div)%
  \else
    \pspolygon*[linestyle=none](! 0 \POE@key@innerheight\space 2 div)%
               (! 0 \POE@key@outerheight\space 2 div)%
               (! \POE@key@phwidth\space \POE@key@outerheight\space 2 div)%
               (! \POE@key@phwidth\space \POE@key@innerheight\space dup neg \POE@key@outerheight\space add 2 div add 2 div)%
    \pspolygon*[linestyle=none](! 0 \POE@key@innerheight\space -2 div)%
               (! 0 \POE@key@outerheight\space -2 div)%
               (! \POE@key@phwidth\space \POE@key@outerheight\space -2 div)%
               (! \POE@key@phwidth\space \POE@key@innerheight\space dup neg \POE@key@outerheight\space add 2 div add -2 div)%
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\beamsplitter@nodes}
%    \begin{macrocode}
\def\beamsplitter@nodes{%
  \edef\@bs@wd{\POE@key@bssize\space 2.0 div }%
  \ifx\POE@key@bsstyle\POE@str@bsstyle@cube
    \ifPOE@compat
%    \end{macrocode}
% the old beamsplitter had only one defined plane
%    \begin{macrocode}
      \newOptexpCompAmb{ {0 0} {1 0} trans {NewPlaneInt} 1 }%
    \else
      \newOptexpCompAmb{ {\@bs@wd 2 sqrt div neg dup} {-1 1} trans {NewPlaneInt}
                         {\@bs@wd 2 sqrt div dup neg} {1 1} trans {NewPlaneInt}
                         {\@bs@wd 2 sqrt div dup} {-1 1} trans {NewPlaneInt}
                         {\@bs@wd 2 sqrt div neg dup neg} {1 1} trans {NewPlaneInt} 
                         {0 0} {1 0} trans {NewPlaneInt} \POE@key@n}%
    \fi
  \else\ifx\POE@key@bsstyle\POE@str@bsstyle@plate
    \newOptexpCompAmb{ {0 0} {1 0} trans {NewPlaneInt} 1 }%
  \fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\beamsplitter@comp}
%    \begin{macrocode}
\def\beamsplitter@comp{%
  \edef\@bs@wd{\POE@key@bssize\space 2.0 div }%
  \ifx\POE@key@bsstyle\POE@str@bsstyle@cube
    \psline{cc-cc}(! \@bs@wd neg 2 sqrt mul 0)(! \@bs@wd 2 sqrt mul 0)
    \rput[c]{45}(0,0){\psframe(! \@bs@wd neg \@bs@wd neg)(! \@bs@wd \@bs@wd)}
  \else\ifx\POE@key@bsstyle\POE@str@bsstyle@plate
    \psline(! \@bs@wd neg 2 sqrt mul 0)(! \@bs@wd 2 sqrt mul 0)
  \fi\fi
\ignorespaces}%
%
%
%
% \begin{macro}{\crystal@ref}
%    \begin{macrocode}
\def\crystal@ref{%
  \let\POE@key@optboxwidth\POE@key@crystalwidth
  \let\POE@key@optboxheight\POE@key@crystalheight
  \optbox@ref
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\crystal@comp}
%    \begin{macrocode}
\def\crystal@comp{%
  \edef\@wd{\POE@key@crystalwidth\space 0.5 mul }
  \edef\@ht{\POE@key@crystalheight\space 0.5 mul }
  \psframe(! \@wd neg \@ht neg)(! \@wd \@ht)
  \ifPOE@voltage%
    \psline(!\@wd 4 div 3 mul neg \@ht)(! \@wd 4 div 3 mul neg \@ht 0.2 add)
    \pscircle[fillstyle=solid, fillcolor=white](! \@wd 4 div 3 mul neg \@ht 0.2 add){0.04}
    \psline(! \@wd 4 div 3 mul neg \@ht neg)%
           (! \@wd 4 div 3 mul neg \@ht neg 0.2 sub)%
    \psline(! \@wd 4 div 3 mul neg 0.15 sub \@ht neg 0.2 sub)%
           (! \@wd 4 div 3 mul neg 0.15 add \@ht neg 0.2 sub)%
  \fi
  \ifPOE@lamp
    \rput{180}(! \@wd \@ht 1.4 \POE@key@lampscale\space mul add){\crystal@lamp}%
  \fi
  \ifdim\POE@key@caxislength pt>0pt
    \edef\@c@caxisL{\POE@key@caxislength\space 2 div }%
    \ifPOE@caxisinv
      \psline[style=CrystalCaxis](! 0 \@ht neg)(! 0 \@ht \@c@caxisL add)%
    \else
      \psline[style=CrystalCaxis](! 0 \@ht)(! 0 \@ht neg \@c@caxisL sub)%
    \fi
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\crystal@lamp}
%    \begin{macrocode}
\def\crystal@lamp{%
  \psset{linewidth=0.6\pslinewidth}
  \edef\@sz{\POE@key@lampscale\space}%
  \pscurve[fillstyle=none](! -0.05 \@sz mul 0)%
          (! -0.1 \@sz mul 0.15 \@sz mul)%
          (! -0.2 \@sz mul 0.25 \@sz mul)%
          (! -0.25 \@sz mul 0.5 \@sz mul)%
          (! 0 0.7 \@sz mul)%
          (! 0.25 \@sz mul 0.5 \@sz mul)%
          (! 0.2 \@sz mul 0.25 \@sz mul)%
          (! 0.1 \@sz mul 0.15 \@sz mul)%
          (! 0.05 \@sz mul 0)
  \multido{\i=-210+40}{7}{%
    \rput{\i}(! 0 0.45 \@sz mul){\psline(! -0.35 \@sz mul 0)(! -0.6 \@sz mul 0)}
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\polarization@comp}
%    \begin{macrocode}
\def\polarization@comp{%
  \edef\@pol@size{\POE@key@polsize\space 0.5 mul }%
  \ifx\POE@key@poltype\POE@str@pol@polparallel
    \psline[linestyle=solid, linewidth=\POE@key@pollinewidth, arrowscale=0.8]{<->}(! 0 \@pol@size neg)(! 0 \@pol@size)%
  \fi
  \ifx\POE@key@poltype\POE@str@pol@polperp
    \psdot[dotsize=0.05](0,0)%
    \pscircle[fillstyle=none,linestyle=solid,linewidth=\POE@key@pollinewidth](0,0){0.12}%
  \fi
  \ifx\POE@key@poltype\POE@str@pol@polmisc
    \psline[linestyle=solid,linewidth=\POE@key@pollinewidth,arrowscale=0.8]{<->}(! 0 \@pol@size neg)(! 0 \@pol@size)%
    \psdot[dotsize=0.05](0,0)%
    \pscircle[fillstyle=none,linestyle=solid,linewidth=0.7\pslinewidth](0,0){0.12}%
  \fi
  \ifx\POE@key@poltype\POE@str@pol@polrcirc
    \psellipticarc[linewidth=\POE@key@pollinewidth]{->}(0,0)(! \@pol@size 2 div \@pol@size){20}{-20}%
  \fi
  \ifx\POE@key@poltype\POE@str@pol@pollcirc
    \psellipticarc[linewidth=\POE@key@pollinewidth]{<-}(0,0)(! \@pol@size 2 div \@pol@size){20}{-20}
  \fi
\ignorespaces}%
%
%
%
% \begin{macro}{\optgrating@ref}
%    \begin{macrocode}
\def\optgrating@ref{%
  \pst@OptexpVerb{/@@y0 \POE@key@gratingheight\space def
                  /@@x \POE@key@gratingwidth\space 0.5 mul def}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optgrating@comp}
%    \begin{macrocode}
\def\optgrating@comp{%
  \edef\@cnt{\POE@key@gratingcount\space}%
  \edef\@wd{\POE@key@gratingwidth\space 2 div }%
  \edef\@ht{\POE@key@gratingheight\space}%
  \edef\@dp{\POE@key@gratingdepth\space}%
  \edef\@step{\POE@key@gratingwidth\space\@cnt div }%
  \ifx\POE@key@gratingtype\POE@str@gratingtype@blazed
    \pscustom[linewidth=\POE@key@gratinglinewidth, linejoin=1]{%
      \psline[liftpen=1](! \@wd \@dp)(! \@wd \@ht)%
                        (! \@wd neg \@ht)(! \@wd neg \@dp)
      \multido{\i=0+1}{\POE@key@gratingcount}{%
        \psline[liftpen=1](! \@wd neg \i\space \@step mul add \@dp)%
                          (! \@wd neg \i\space \ifPOE@reverse\else 1 add \fi \@step mul add 0)%
                          (! \@wd neg \i\space 1 add \@step mul add \@dp)%
      }%
      \closepath
    }%
  \else\ifx\POE@key@gratingtype\POE@str@gratingtype@binary
    \pscustom[linewidth=\POE@key@gratinglinewidth]{%
      \psline[liftpen=1](! \@wd \@dp)(! \@wd \@ht)%
                        (! \@wd neg \@ht)(! \@wd neg \@dp)
      \multido{\i=0+1}{\POE@key@gratingcount}{%
        \psline[liftpen=1](! \@wd neg \i\space \@step mul add \@dp)%
                          (! \@wd neg \i\space \@step mul add 0)%
                          (! \@wd neg \i\space 0.5 add \@step mul add 0)%
                          (! \@wd neg \i\space 0.5 add \@step mul add \@dp)%
                          (! \@wd neg \i\space 1 add \@step mul add \@dp)%
      }%
    }%
  \fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optbox@ref}
%    \begin{macrocode}
\def\optbox@ref{%
  \pst@OptexpVerb{%
    /@@x \POE@key@optboxwidth\space 0.5 mul def
    /@@y \POE@key@optboxheight\space 0.5 mul def
  }%
  \ifPOE@endbox
    \pst@OptexpVerb{/@@x0 @@x def}%
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optbox@comp}
%    \begin{macrocode}
\def\optbox@comp{%
  \edef\@wd{\POE@key@optboxwidth\space 0.5 mul }
  \edef\@ht{\POE@key@optboxheight\space 0.5 mul }
  \ifPOE@endbox
    \psframe[dimen=outer](! 0 \@ht neg)(! \@wd 2 mul \@ht)
  \else
    \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optplate@ref}
%    \begin{macrocode}
\def\optplate@ref{%
  \pst@OptexpVerb{/@@y \POE@key@plateheight\space 0.5 mul def }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optplate@comp}
%    \begin{macrocode}
\def\optplate@comp{%
   \psline[linewidth=\POE@key@platelinewidth](! \POE@dict{0 @@y neg})(! \POE@dict{0 @@y})
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optdetector@ref}
%    \begin{macrocode}
\def\optdetector@ref{%
  \pst@OptexpVerb{/@@x0 \POE@key@detsize\space 0.5 mul def}%
  \ifx\POE@key@dettype\POE@str@dettype@diode
    \pst@OptexpVerb{ @@x0 dup /@@x ED /@@y ED}%
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optdetector@nodes}
%    \begin{macrocode}
\def\optdetector@nodes{%
  \newOptexpComp{{ 0 0} { 0 1 } refl {NewPlaneInt} 1 }%
  \ifx\POE@key@dettype\POE@str@dettype@round
    \pnode(! \POE@key@detsize\space 0.2 mul 0){\oenodeCenter{}}%
  \else\ifx\POE@key@dettype\POE@str@dettype@diode
    \pnode(! \POE@key@detsize\space 0.5 mul 0){\oenodeCenter{}}
  \fi\fi
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optdetector@comp}
%    \begin{macrocode}
\def\optdetector@comp{%
   \pnode(\oenodeRefB{}){\oenodeIn{}}
   \ifx\POE@key@dettype\POE@str@dettype@round
      \begin@ClosedObj
%    \end{macrocode}
% I could have use pswedge but then a correction of the component size
% depending on the current linewidth is not possible
%    \begin{macrocode}
         \addto@pscode{CLW 0.5 mul 0 \POE@key@detsize\space\pst@number\psrunit mul 0.5 mul 
            CLW sub -90 90 arc closepath }%
      \end@ClosedObj
   \else\ifx\POE@key@dettype\POE@str@dettype@diode
      \edef\@sz{\POE@key@detsize\space 0.5 mul }%
      \psframe[dimen=outer](! 0 \@sz neg)(!\@sz 2 mul \@sz)
      \pspolygon(! \@sz 0.8 mul \@sz -0.4 mul)%
             (! \@sz 1.6 mul \@sz -0.4 mul)%
             (! \@sz 1.2 mul \@sz 0.4 mul)%
      \psline(! \@sz 0.8 mul \@sz 0.4 mul \getCLWH add)(! \@sz 1.6 mul \@sz 0.4 mul \getCLWH add)
      \psset{arrows=->, arrowinset=0, arrowscale=0.8}
      \psline(! \@sz 0.2 mul \@sz 0.3 mul)(! \@sz 0.7 mul \@sz 0.15 mul)
      \psline(! \@sz 0.2 mul 0)(! \@sz 0.7 mul \@sz -0.15 mul)
   \fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optretplate@ref}
%    \begin{macrocode}
\def\optretplate@ref{%
   \pst@OptexpVerb{%
     /@@y \POE@key@plateheight\space 0.5 mul def
     /@@x \POE@key@platewidth\space 0.5 mul def
   }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optretplate@comp}
%    \begin{macrocode}
\def\optretplate@comp{%
   \edef\@ht{\POE@key@plateheight\space 0.5 mul }%
   \edef\@wd{\POE@key@platewidth\space 0.5 mul }%
   \psframe(! \@wd neg \@ht neg)(! \@wd \@ht)
   \psline{cc-cc}(! \@wd neg \@ht)(! \@wd \@ht neg)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optdiode@ref}
%    \begin{macrocode}
\def\optdiode@ref{%
   \pst@OptexpVerb{\POE@key@optdiodesize\space 0.5 mul dup /@@y ED /@@x ED }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optdiode@comp}
%    \begin{macrocode}
\def\optdiode@comp{%
   \edef\@sz{\POE@key@optdiodesize\space}%
   \psframe[dimen=outer](! \@sz -0.5 mul dup)(!\@sz 0.5 mul dup)
   \pspolygon(! \@sz -0.2 mul \@sz -0.2 mul)
             (! \@sz -0.2 mul \@sz 0.2 mul)
             (! \@sz 0.2 mul 0)
   \psline(! \@sz 0.2 mul \getCLWH add \@sz 0.2 mul)(! \@sz 0.2 mul \getCLWH add \@sz -0.2 mul)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\doveprism@nodes}
%    \begin{macrocode}
\def\doveprism@nodes{%
  \newOptexpComp{ {\POE@key@doveprismsize\space neg 0} {1 1} trans {NewPlaneInt}
                  {0 \POE@key@doveprismsize\space -0.5 mul} {1 0} refl {NewPlaneInt}
                  {\POE@key@doveprismsize\space 0} {-1 1} trans {NewPlaneInt} \POE@key@n }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\doveprism@comp}
%    \begin{macrocode}
\def\doveprism@comp{%
   \edef\@ht{\POE@key@doveprismsize\space 0.5 mul }%
   \edef\@wd{\POE@key@doveprismsize\space 1.5 mul }%
   \pspolygon(! \@wd neg \@ht neg)%
             (! \@wd \@ht neg)%
             (! \@ht dup)%
             (! \@ht neg \@ht)%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\pentaprism@nodes}
%    \begin{macrocode}
\def\pentaprism@nodes{%
  \edef\@pp@size{\POE@key@pentaprismsize\space}%
  \newOptexpComp{ {\@pp@size 2 sqrt -2 mul div dup } {-1 1} trans {NewPlaneInt}
                  {\@pp@size 2 sqrt div 67.5 cos \@pp@size mul 67.5 sin 2 mul div sub \@pp@size 2 div}
                  { 67.5 cos \@pp@size mul 67.5 sin div neg \@pp@size} refl {NewPlaneInt}
                  {\@pp@size 2 sqrt div neg 67.5 cos \@pp@size mul 67.5 sin 2 mul div add \@pp@size 2 div}
                  { 67.5 cos \@pp@size mul 67.5 sin div \@pp@size} refl {NewPlaneInt}
                  {\@pp@size 2 sqrt 2 mul div dup neg} {1 1} trans {NewPlaneInt} \POE@key@n}%   
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\pentaprism@comp}
%    \begin{macrocode}
\def\pentaprism@comp{%
   \edef\@pp@size{\POE@key@pentaprismsize\space}%
   \pscustom{%
      \psline(! \@pp@size 2 sqrt div 0)%
         (! \@pp@size 2 sqrt div 67.5 cos \@pp@size mul 67.5 sin div sub \@pp@size)%
         (! 67.5 cos \@pp@size mul 67.5 sin div \@pp@size 2 sqrt div sub \@pp@size)%
         (! \@pp@size 2 sqrt div neg 0)%
         (! 0 \@pp@size 2 sqrt div neg)%
      \closepath
   }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optprism@nodes}
%    \begin{macrocode}
\def\optprism@nodes{%
   \edef\@sz{\POE@key@prismsize\space}%
   \edef\@altan{\POE@key@prismangle\space 0.5 mul tan }%
   \edef\@hshift{\@sz 0.6 mul \@altan mul \pst@optexpdict OEangle end 0.5 mul tan div }%
   \newOptexpComp{ {\@sz -0.6 mul \@altan mul \@hshift neg} {90 \POE@key@prismangle\space 0.5 mul sub dup cos exch sin} trans {NewPlaneInt}
                   {\@sz 0.6 mul \@altan mul \@hshift neg} {90 \POE@key@prismangle\space 0.5 mul add dup cos exch sin} trans {NewPlaneInt} \POE@key@n }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optprism@comp}
%    \begin{macrocode}
\def\optprism@comp{%
   \edef\@sz{\POE@key@prismsize\space}%
   \edef\@altan{\POE@key@prismangle\space 0.5 mul tan }%
   \edef\@hshift{\@sz 0.6 mul \@altan mul \pst@optexpdict OEangle end 0.5 mul tan div }%
   \pspolygon(! \@sz neg \@altan mul \@sz -0.4 mul \@hshift sub)
             (! \@sz \@altan mul \@sz -0.4 mul \@hshift sub)
             (! 0 \@sz 0.6 mul \@hshift sub)
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\rightangleprism@nodes}
%    \begin{macrocode}
\def\rightangleprism@nodes{%
  \edef\@sz{\POE@key@raprismsize\space 0.5 mul }%
  \edef\@ht{\POE@dict{OEangle 0.5 mul sin modA mul} }%
  \newOptexpComp{ {\@ht neg \@ht \@sz sub} {1 0} trans {NewPlaneInt}
                  {\@ht neg 0} {1 1} refl {NewPlaneInt}
                  {\@ht 0} {1 -1} refl {NewPlaneInt}
                  {\@ht dup \@sz sub } {1 0} trans {NewPlaneInt} \POE@key@n }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rightangleprism@comp}
%    \begin{macrocode}
\def\rightangleprism@comp{%
  \edef\@sz{\POE@key@raprismsize\space 0.5 mul }%
  \edef\@ht{\POE@dict{OEangle 0.5 mul sin modA mul} }%
  \pspolygon(! \@sz neg \@ht \@sz sub)
            (! \@sz \@ht \@sz sub)
            (! 0 \@ht)%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsubsection{Fiber Optics}
%
% \begin{macro}{\optfiber@iii}
%    \begin{macrocode}
\def\optfiber@iii{%
   \edef\@f@cnt{\POE@key@fiberloops\space}%
   \edef\@f@r{\POE@key@fiberloopradius\space}%
   \edef\@f@sep{\POE@key@fiberloopsep\space}%
   \parametricplot[plotpoints=200,style=Fiber]{0}{1}{%
      t 360 mul \@f@cnt mul sin \@f@r mul \@f@sep \@f@cnt 1 sub mul t 0.5 sub mul add
      1 t 360 mul \@f@cnt mul cos sub \@f@r mul
   }%
   \pnode(! \@f@sep \@f@cnt 1 sub mul -0.5 mul 0){\oenodeIn{}}
   \pnode(! \@f@sep \@f@cnt 1 sub mul 0.5 mul 0){\oenodeOut{}}
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optmzm@ref}
%    \begin{macrocode}
\def\optmzm@ref{%
  \pst@OptexpVerb{\POE@key@optmzmsize\space dup 0.8 mul /@@x ED 0.5 mul /@@y ED }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optmzm@comp}
%    \begin{macrocode}
\def\optmzm@comp{%
  \def\@wd{\POE@key@optmzmsize\space 0.8 mul }%
  \def\@ht{\POE@key@optmzmsize\space 0.5 mul }%
  \bgroup
    \ifPOE@usefiberstyle
      \psset{style=Fiber}
    \fi
    \psline(! \@wd neg 0)(! \@wd -0.7 mul 0)(! \@wd -0.4 mul \@ht 0.6 mul)%
           (! \@wd 0.4 mul \@ht 0.6 mul)(! \@wd 0.7 mul 0)(! \@wd 0)%
           (! \@wd 0.7 mul 0)(! \@wd 0.4 mul \@ht -0.6 mul)%
           (! \@wd -0.4 mul \@ht -0.6 mul)(! \@wd -0.7 mul 0)%
  \egroup
  \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optfilter@ref}
%    \begin{macrocode}
\def\optfilter@ref{%
  \pst@OptexpVerb{\POE@key@filtersize\space 0.5 mul dup /@@y ED /@@x ED }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optfilter@comp}
%    \begin{macrocode}
\def\optfilter@comp{%
  \edef\@sz{\POE@key@filtersize\space 0.5 mul }%
  \def\filter@curve{%
    \parametricplot[plotstyle=curve,arrows=c-c]{-1}{1}{%
      t \@sz mul 0.7 mul t Pi mul RadtoDeg 90 add cos 0.2 \@sz mul mul}%
  }%
  \psframe[dimen=outer](! \@sz neg dup)(! \@sz dup)
  \ifx\POE@key@filtertype\POE@str@filtertype@bandpass
    \psline(! -0.3 \@sz mul -0.65 \@sz mul)%
           (! 0.3 \@sz mul -0.35 \@sz mul)%
    \psline(! -0.3 \@sz mul 0.35 \@sz mul)%
           (! 0.3 \@sz mul 0.65 \@sz mul)%
    \rput(! 0 -0.5 \@sz mul){\filter@curve}
    \rput(0, 0){%
      \ifPOE@usefiberstyle
        \psset{style=Fiber}
      \fi
      \filter@curve}
    \rput(! 0 0.5 \@sz mul){\filter@curve}
  \else\ifx\POE@key@filtertype\POE@str@filtertype@bandstop
    \psline(! -0.3 \@sz mul -0.15 \@sz mul)%
           (! 0.3 \@sz mul 0.15 \@sz mul)%
    \rput(! 0 -0.5 \@sz mul){%
      \ifPOE@usefiberstyle
        \psset{style=Fiber}
      \fi
      \filter@curve}
      \rput(0, 0){\filter@curve}
      \rput(! 0 0.5 \@sz mul){%
        \ifPOE@usefiberstyle
          \psset{style=Fiber}
        \fi
        \filter@curve}
  \else\ifx\POE@key@filtertype\POE@str@filtertype@lowpass
    \psline(! -0.3 \@sz mul -0.15 \@sz mul)%
           (! 0.3 \@sz mul 0.15 \@sz mul)%
    \psline(! -0.3 \@sz mul 0.35 \@sz mul)%
           (! 0.3 \@sz mul 0.65 \@sz mul)%
    \rput(! 0 -0.5 \@sz mul){%
      \ifPOE@usefiberstyle
        \psset{style=Fiber}
      \fi
      \filter@curve}
      \rput(0, 0){\filter@curve}
      \rput(! 0 0.5 \@sz mul){\filter@curve}
  \else\ifx\POE@key@filtertype\POE@str@filtertype@highpass
    \psline(! -0.3 \@sz mul -0.15 \@sz mul)%
           (! 0.3 \@sz mul 0.15 \@sz mul)%
    \psline(! -0.3 \@sz mul -0.65 \@sz mul)%
           (! 0.3 \@sz mul -0.35 \@sz mul)%
    \rput(! 0 0.5 \@sz mul){%
      \ifPOE@usefiberstyle
        \psset{style=Fiber}
      \fi
      \filter@curve}
      \rput(0, 0){\filter@curve}
      \rput(! 0 -0.5 \@sz mul){\filter@curve}
  \fi\fi\fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optamp@nodes}
%    \begin{macrocode}
\def\optamp@nodes{%
  \edef\@sz{\POE@key@optampsize\space 0.5 mul }%
  \edef\@xl{0.75 sqrt \@sz mul }%
  \pnode(!\@xl neg 0){\oenodeIn{}}
  \pnode(!\@xl 0){\oenodeOut{}}  
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optamp@comp}
%    \begin{macrocode}
\def\optamp@comp{%
  \edef\@sz{\POE@key@optampsize\space 0.5 mul }%
  \edef\@xl{0.75 sqrt \@sz mul }%
  \pspolygon(! \@xl 0)(! \@xl neg \@sz)(! \@xl neg \@sz neg)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\polcontrol@comp}
%    \begin{macrocode}
\def\polcontrol@comp{%
   \edef\@sz{\POE@key@polcontrolsize\space}%
   \ifPOE@usefiberstyle
      \psset{style=Fiber}
   \fi
   \multips(! -2 \@sz mul \@sz)(! 2 \@sz mul 0){3}{\pscircle(0,0){\POE@key@polcontrolsize}}
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optisolator@ref}
%    \begin{macrocode}
\def\optisolator@ref{%
  \pst@OptexpVerb{\POE@key@isolatorsize\space dup 0.8 mul /@@x ED 0.5 mul /@@y ED }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optisolator@comp}
%    \begin{macrocode}
\def\optisolator@comp{%
  \edef\@ht{\POE@key@isolatorsize\space 0.5 mul }%
  \edef\@wd{\POE@key@isolatorsize\space 0.8 mul }%
  \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
  \psline[style=IsolatorArrow]{->}(! \@wd neg 0.6 mul 0)(!\@wd 0.6 mul 0)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optfiberpolarizer@ref}
%    \begin{macrocode}
\def\optfiberpolarizer@ref{%
  \pst@OptexpVerb{\POE@key@fiberpolsize\space dup 0.8 mul /@@x ED 0.5 mul /@@y ED }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optfiberpolarizer@comp}
%    \begin{macrocode}
\def\optfiberpolarizer@comp{%
  \edef\@ht{\POE@key@fiberpolsize\space 0.5 mul }%
  \edef\@wd{\POE@key@fiberpolsize\space 0.8 mul }%
  \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
  \psline(! \@wd neg 0.2 mul \@ht neg)(!\@wd 0.2 mul \@ht)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optswitch@ref}
%    \begin{macrocode}
\def\optswitch@ref{%
  \pst@OptexpVerb{\POE@key@switchsize\space 0.5 mul dup /@@y ED /@@x ED }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optswitch@comp}
%    \begin{macrocode}
\def\optswitch@comp{%
  \edef\@sz{\POE@key@switchsize\space 0.5 mul }%
%    \end{macrocode}
% storing the linewidth of the object allows for some aesthetic fine tuning 
%    \begin{macrocode}
  \pstVerb{tx@Dict begin /@lw \getCLW def end}%
  \bgroup
    \ifPOE@usefiberstyle
      \psset{style=Fiber}
    \fi
    \psline[arrows=-](! \@sz neg 0)(! \@sz -0.6 mul @lw sub 0)%
    \psline[arrows=-](! \@sz 0.6 mul 0)(! \@sz 0)%
  \egroup
  \ifx\POE@key@switchstyle\POE@str@closed%
    \bgroup
      \ifPOE@usefiberstyle
        \psset{style=Fiber}
      \fi
      \psdot[dotsize=3\pslinewidth](! \@sz 0.6 mul 0)%
      \psdot[dotsize=3\pslinewidth](! \@sz -0.6 mul 0)%
      \psline[arrows=-, linewidth=1.5\pslinewidth](! \@sz -0.6 mul @lw)(! \@sz 0.6 mul @lw)%      
    \egroup
  \else
    \psline[arrows=-, linewidth=1.5\pslinewidth](! \@sz -0.6 mul @lw add @lw)(! \@sz 0.6 mul dup)%
    \pscircle(! \@sz -0.6 mul 0){\pslinewidth}%
    \psdot[dotsize=3\pslinewidth](! \@sz 0.6 mul 0)%
  \fi
  \psframe[dimen=outer](! \@sz neg dup)(! \@sz dup)%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fiberdelayline@ref}
%    \begin{macrocode}
\def\fiberdelayline@ref{%
  \pst@OptexpVerb{\POE@key@fdlsize\space dup 0.8 mul /@@x ED 0.5 mul /@@y ED }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fiberdelayline@comp}
%    \begin{macrocode}
\def\fiberdelayline@comp{%
  \def\@wd{\POE@key@fdlsize\space 0.8 mul }%
  \def\@ht{\POE@key@fdlsize\space 0.5 mul }%
  \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
  \psline[style=FdlArrow](! \@wd -0.3 mul \@ht -1.5 mul)(! \@wd 0.3 mul \@ht 1.2 mul CLW \pst@number\psyunit div 5 mul add)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optcoupler@nodes}
%    \begin{macrocode}
\def\optcoupler@nodes{%
  \edef\@sz{\POE@key@couplersize\space}%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@align\POE@str@top
    \def\@yshift{\@sep neg }%
  \else\ifx\POE@key@align\POE@str@bottom
    \def\@yshift{\@sep\space}%
  \else
    \def\@yshift{0 }%
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \pnode(! \@sz -0.5 mul \@yshift \@sep add){\oenode{}{1}}
    \pnode(! \@sz -0.5 mul \@yshift \@sep sub){\oenode{}{2}}
    \pnode(! \@sz 0.5 mul \@yshift \@sep add){\oenode{}{3}}
    \pnode(! \@sz 0.5 mul \@yshift \@sep sub){\oenode{}{N}}
  \else
    \pnode(! \@sz neg \getCLW 0.3 mul add \@yshift \@sep add){\oenode{}{1}}
    \pnode(! \@sz neg \getCLW 0.3 mul add \@yshift \@sep sub){\oenode{}{2}}
    \pnode(! \@sz \getCLW 0.3 mul sub \@yshift \@sep add){\oenode{}{3}}
    \pnode(! \@sz \getCLW 0.3 mul sub \@yshift \@sep sub){\oenode{}{N}}
  \fi
  \pnode(! 0 \@yshift){\oenodeCenter{}}
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optcoupler@comp}
%    \begin{macrocode}
\def\optcoupler@comp{%
  \edef\@sz{\POE@key@couplersize\space}%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@align\POE@str@top
    \def\@yshift{\@sep neg }%
  \else\ifx\POE@key@align\POE@str@bottom
    \def\@yshift{\@sep\space}%
  \else
    \def\@yshift{0 }%
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \psline[style=Fiber](\oenode{}{1})(\oenode{}{3})
    \psline[style=Fiber](\oenode{}{2})(\oenode{}{N})
  \else\ifx\POE@key@couplertype\POE@str@couplertype@elliptic
    \psellipse[dimen=outer](!0 \@yshift)(! \@sz \@sz 0.4 mul)
  \else\ifx\POE@key@couplertype\POE@str@couplertype@rectangular
    \psframe[dimen=outer](!\@sz neg \@yshift \@sz 0.4 mul sub )%
                         (!\@sz \@yshift \@sz 0.4 mul add)
  \else\ifx\POE@key@couplertype\POE@str@couplertype@crossswitch
    \psframe[dimen=outer](!\@sz neg \@yshift \@sz sub )%
                         (!\@sz \@yshift \@sz add)
    \edef\@csz{\POE@key@couplersize\space 0.5 mul }
    \psline(! \@csz neg dup)(! \@csz dup)
    \psline(! \@csz neg \@csz)(! \@csz dup neg)
  \fi\fi\fi\fi
  \ifPOE@variable
    \psline[style=VariableCoupler](!\@sz -0.5 mul \@sz neg \@yshift add)(!\@sz 0.5 mul \@sz \@yshift add)
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmcoupler@nodes}
%    \begin{macrocode}
\def\wdmcoupler@nodes{%
  \edef\@sz{\POE@key@couplersize\space}%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@align\POE@str@center
      \edef\@sep{0 }%
    \fi
  \fi
  \ifx\POE@key@align\POE@str@top
    \def\@yshift{\@sep neg }%
  \else\ifx\POE@key@align\POE@str@bottom
    \def\@yshift{\@sep }%
  \else
    \def\@yshift{0 }%
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \pnode(! \@sz -0.5 mul \@yshift \@sep add){\oenode{}{1}}
    \pnode(! \@sz -0.5 mul \@yshift \@sep sub){\oenode{}{2}}
    \pnode(! \@sz 0.5 mul 0){\oenode{}{N}}
  \else
    \pnode(! \@sz neg \getCLW 0.3 mul add \@yshift \@sep add){\oenode{}{1}}
    \pnode(! \@sz neg \getCLW 0.3 mul add \@yshift \@sep sub){\oenode{}{2}}
    \pnode(! \@sz \getCLW 0.3 mul sub 0){\oenode{}{N}}
  \fi
  \pnode(! 0 \@yshift){\oenodeCenter{}}
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmcoupler@comp}
%    \begin{macrocode}
\def\wdmcoupler@comp{%
  \edef\@sz{\POE@key@couplersize\space}%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@align\POE@str@center
      \edef\@sep{0 }%
    \fi
  \fi
  \ifx\POE@key@align\POE@str@top
    \def\@yshift{\@sep neg }%
  \else\ifx\POE@key@align\POE@str@bottom
    \def\@yshift{\@sep\space}%
  \else
    \def\@yshift{0 }%
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@elliptic
    \psellipse[dimen=outer](!0 \@yshift)(! \@sz \@sz 0.4 mul)
  \else\ifx\POE@key@couplertype\POE@str@couplertype@rectangular
    \psframe[dimen=outer](!\@sz neg \@yshift \@sz 0.4 mul sub )%
                         (!\@sz \@yshift \@sz 0.4 mul add)
  \else\ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@align\POE@str@top
      \psline[style=Fiber](\oenode{}{1})(\oenodeOut{})
      \psline[style=Fiber](! \pst@optexpdict /N@\oenodeOut{} @GetCenter end \tx@UserCoor \POE@key@couplersep\space sub)(\oenode{}{2})
    \else
      \psline[style=Fiber](\oenode{}{2})(\oenodeOut{})
      \ifx\POE@key@aling\POE@str@bottom
        \psline[style=Fiber](! \pst@optexpdict /N@\oenodeIn{} @GetCenter end \tx@UserCoor \POE@key@couplersep\space sub)(\oenode{}{1}) 
      \fi
    \fi
  \fi\fi\fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmsplitter@nodes}
%    \begin{macrocode}
\def\wdmsplitter@nodes{%
  \edef\@sz{\POE@key@couplersize\space}%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@align\POE@str@center
      \edef\@sep{0 }%
    \fi
  \fi
  \ifx\POE@key@align\POE@str@top
    \def\@yshift{\@sep neg }%
  \else\ifx\POE@key@align\POE@str@bottom
    \def\@yshift{\@sep }%
  \else
    \def\@yshift{0 }%
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \pnode(! \@sz -0.5 mul 0){\oenode{}{1}}
    \pnode(! \@sz 0.5 mul \@yshift \@sep add){\oenode{}{2}}
    \pnode(! \@sz 0.5 mul \@yshift \@sep sub){\oenode{}{N}}
  \else
    \pnode(! \@sz neg \getCLW 0.3 mul add 0){\oenode{}{1}}
    \pnode(! \@sz \getCLW 0.3 mul sub \@yshift \@sep add){\oenode{}{2}}
    \pnode(! \@sz \getCLW 0.3 mul sub \@yshift \@sep sub){\oenode{}{N}}
  \fi
  \pnode(! 0 \@yshift){\oenodeCenter{}}
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmsplitter@comp}
%    \begin{macrocode}
\def\wdmsplitter@comp{%
  \edef\@sz{\POE@key@couplersize\space}%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@align\POE@str@center
      \edef\@sep{0 }%
    \fi
  \fi
  \ifx\POE@key@align\POE@str@top
    \def\@yshift{\@sep neg }%
  \else\ifx\POE@key@align\POE@str@bottom
    \def\@yshift{\@sep\space}%
  \else
    \def\@yshift{0 }%
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@elliptic
    \psellipse[dimen=outer](!0 \@yshift)(! \@sz \@sz 0.4 mul)
  \else\ifx\POE@key@couplertype\POE@str@couplertype@rectangular
    \psframe[dimen=outer](!\@sz neg \@yshift \@sz 0.4 mul sub )%
                         (!\@sz \@yshift \@sz 0.4 mul add)
  \else\ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@align\POE@str@top
      \psline[style=Fiber](\oenodeIn{})(\oenode{}{2})
      \psline[style=Fiber](! \pst@optexpdict /N@\oenodeIn{} @GetCenter end \tx@UserCoor \POE@key@couplersep\space sub)(\oenode{}{N})
    \else
      \psline[style=Fiber](\oenodeIn{})(\oenode{}{N})
      \ifx\POE@key@align\POE@str@bottom
        \psline[style=Fiber](! \pst@optexpdict /N@\oenodeIn{} @GetCenter end \tx@UserCoor \POE@key@couplersep\space sub)(\oenode{}{2})
      \fi
    \fi
  \fi\fi\fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\fibercollimator@nodes}
%    \begin{macrocode}
\def\fibercollimator@nodes{%
   \def\@sz{\POE@key@fibercolsize\space 0.5 mul }%
   \pnode(!\@sz neg 0){\oenodeIn{}}
   \newOptexpComp{ {\@sz neg 0} {0 1} trans {NewPlaneInt} 1 }%
   \pnode(!\@sz 0){\oenodeOut{}}
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\fibercollimator@comp}
%    \begin{macrocode}
\def\fibercollimator@comp{%
   \def\@sz{\POE@key@fibercolsize\space 0.5 mul }%
   \pspolygon(! \@sz neg \getCLWH add \@sz neg)(!\@sz 0)(!\@sz neg \getCLWH add \@sz)
}%
%    \end{macrocode}
% \end{macro}
%
%</stylefile> 
%
% \subsection{The Postscript Header file}
% \makeatletter
%% Copied this definition from doc.sty and changed it not to add a
%% backslash to the Postscript procedure name in the index.
% \def\SpecialIndex@#1#2{%
%    \@SpecialIndexHelper@#1\@nil
%    \def\@tempb{ }%
%    \ifcat \@tempb\@gtempa
%       \special@index{\quotechar\space\actualchar
%                      \string\verb\quotechar*\verbatimchar
%                      \quotechar\bslash\quotechar\space\verbatimchar#2}%
%    \else
%      \def\@tempb##1##2\relax{\ifx\relax##2\relax
%           \def\@tempc{\special@index{\quotechar##1\actualchar
%                       \string\verb\quotechar*\verbatimchar
%                       \quotechar\bslash\quotechar##1\verbatimchar#2}}%
%         \else
%           \def\@tempc{\special@index{##1##2\actualchar
%                        \string\verb\quotechar*\verbatimchar##1##2\verbatimchar#2}}%
%         \fi}%
%      \expandafter\@tempb\@gtempa\relax
%      \@tempc
%    \fi}
% \makeatother
%<*prolog>
%    \begin{macrocode}
/tx@OptexpDict 70 dict def
tx@OptexpDict begin
%    \end{macrocode}
% \begin{macro}{strcat}
%    \begin{macrocode}
% Concatenate two strings.
/strcat {
    exch 2 copy
    length exch length add
    string dup dup 5 2 roll
    copy length exch
    putinterval
} bind def
%    \end{macrocode}
% \end{macro}
% \begin{macro}{nametostring}
%    Convert a literal name to string.
%    \begin{macrocode}
/nametostring {
    dup length string cvs
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{calcNodes}
% XB YB  XA YA XG YG are on the stack.
%    \begin{macrocode}
/calcNodes {
    /YG exch def /XG exch def
    /ay YG 3 -1 roll sub def
    /ax XG 3 -1 roll sub def
    /by exch YG sub def
    /bx exch XG sub def
    /a ax ay Pyth def
%    \end{macrocode}
% This is stored for external use.
%    \begin{macrocode}
    /modA a def
    /b bx by Pyth def
    /cx ax a div bx b div add def
    /cy ay a div by b div add def
    /c@tmp cx cy Pyth def
    /c ax bx add ay by add Pyth def
    /OEangle c dup mul a dup mul sub b dup mul sub -2 a b mul mul div Acos def
%    \end{macrocode}
% If $c=0$, then set the coordinates of the vector manually
% depending on the dotproduct (and thus, if 'a' and 'b'
% are parallel or antiparallel.
%    \begin{macrocode}
    c 0 eq {
      ax bx mul ay by mul add 0 gt {
%    \end{macrocode}
% If $\text{dotprod} > 0$ then a and b are parallel.
%    \begin{macrocode}
        /cx ax def
        /cy ay def
      }{
%    \end{macrocode}
% else a and b are antiparallel
%    \begin{macrocode}
        /cx ay def
        /cy ax neg def
      } ifelse
      /c@tmp a def
    } if
    /X@A XG cx c@tmp div add def
    /Y@A YG cy c@tmp div add def
    /X@B XG cx c@tmp div sub def
    /Y@B YG cy c@tmp div sub def
%    \end{macrocode}
% chirality:
% test the order of the input points as a input angle $> 90°$
% doesn't really make sense.
% So if chir $<= 0$ exchange the calculated coordinates of 
% A and B and otherwise leave it as is
%    \begin{macrocode}
    /chirality ax by mul ay bx mul sub def
    chirality 0 le {
      Y@A X@A 
      /X@A X@B def
      /Y@A Y@B def
      /X@B exch def
      /Y@B exch def
    }if
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{segLen}
% Calculate the height a1 of a pole cap. The circle radius and the height are on the stack.
%    \begin{macrocode}
/segLen {
    dup mul neg exch abs dup 3 1 roll dup mul add sqrt sub
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{leftConvex}
% Calculate some parameters for the left plane of a convex lens.
% Defines /a1 as the pole height and /ArcL which are used later in the code.
%
%
% height R1 -> y |R1| alpha\textunderscore bottom alpha\textunderscore top R1
%    \begin{macrocode}
/leftConvex {
   /R1 exch def /h exch def
   /a1  R1 h segLen def
   0 R1 abs
   R1 a1 sub neg dup
   h exch atan exch
   h neg exch atan
   /ArcL /arc load def
   R1
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{leftConcave}
% Analogous to /leftConvex.
% height R1 -> y |R1| alpha\textunderscore bottom alpha\textunderscore top R1
%    \begin{macrocode}
/leftConcave {
   /R1 exch def /h exch def
   /a1 R1 h segLen def
   0 R1 abs
   R1 neg a1 sub dup
   h exch atan exch
   h neg exch atan
   /ArcL /arcn load def
   /a1 0.5 a1 mul def
   R1
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{rightConvex}
% Analogous to /leftConvex, /a2 and /ArcR are defined
% height R2 -> y |R2| alpha\textunderscore bottom alpha\textunderscore top R2
%    \begin{macrocode}
/rightConvex {
   /R2 exch def /h exch def
   /a2 R2 h segLen def
   0 R2 abs
   R2 a2 sub dup
   h neg exch atan exch
   h exch atan
   R2
   /ArcR /arc load def
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{rightConcave}
% Analogous to /rightConvex
% height R2 -> y |R2| alpha\textunderscore bottom alpha\textunderscore top R2
%    \begin{macrocode}
/rightConcave {
   /R2 exch def /h exch def
   /a2 R2 h segLen def
   0 R2 abs
   R2 a2 add dup
   h neg exch atan exch
   h exch atan
   /ArcR /arcn load def
   /a2 0.5 a2 mul def
   R2
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{mwNode}
% Calculate the center between two nodes 
% x1 y1 x2 y2 -> (x1+x2)/2 (y1+y2)/2
%    \begin{macrocode}
/mwNode {
    exch 3 1 roll add 2 div 3 1 roll add 2 div exch
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{FiberAngleB}
% Calculate angle of a line from nodeA to nodeB. nodeA and nodeB must be given as literal names
% nodeB nodeA -> angle
%    \begin{macrocode}
/FiberAngleB {%
    @GetCenter 3 -1 roll @GetCenter exch 3 1 roll sub 3 1 roll sub atan
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{FiberAngleA}
% Calculate angle of line from nodeB to nodeA
% nodeB nodeA -> angle
%    \begin{macrocode}
/FiberAngleA {%
    FiberAngleB 180 add
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{ExtNode}
%    \begin{macrocode}
/ExtNode {%
    @@x0 @xref @@x mul add 
    @@y0 @yref @@y mul add 
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetInternalNodeNames}
% Push all internal node names of (basicnodename) on the stack.
% (basicnodename) reverse GetInternalNodeNames
%    \begin{macrocode}
/GetInternalNodeNames {
    /reverse exch def
    (N@) exch strcat 1 {
%    \end{macrocode}
% counter and name on stack
% \begin{macrocode}
      2 copy dup 3 string cvs 3 -1 roll exch strcat dup
      tx@NodeDict exch known {%
        reverse {
          4 1 roll pop
        } {
          exch 2 add 1 roll
        } ifelse
      } {
        reverse {
          pop pop pop (N) strcat
        } {
          pop pop exch (N) strcat exch 1 roll
        } ifelse
        exit
      } ifelse
      1 add
    } loop
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetInternalBeamNodes}
% (basicnodename) reverse -> x\_n y\_n \ldots x\_1 y\_1 (if reverse = false)
%    \begin{macrocode}
/GetInternalBeamNodes {
    [ 3 1 roll GetInternalNodeNames ]
    { @GetCenter } forall
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{InitOptexpComp}
% Initialize some global variables for positioning of external nodes
% This is called at the beginning of every component
%    \begin{macrocode}
/InitOptexpComp {%
    /@@x 0 def
    /@@y 0 def
    /@@x0 0 def
    /@@y0 0 def
    /@xref 0 def
    /@yref 0 def
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{ExchCoor}
% xa ya xb yb ExchCoor true/false
%    \begin{macrocode}
/ExchCoor {
    exch 4 -1 roll 2 copy 
    gt {
      pop pop pop pop false
    } {
%    \end{macrocode}
% xB > xA
%    \begin{macrocode}
        eq 3 1 roll gt and
%    \end{macrocode}
% $xA == xB$ and $yA < yB$
%    \begin{macrocode}
        { false } { true } ifelse
    } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
%
% Added for version 3.0
%
% \begin{macro}{NewTempNodeComp}
% \{x y\} \{dx dy\} Name \{scaling procedure\}
%    \begin{macrocode}
/NewTempNodeComp {
  /sc ED
  dup cvn
  6 dict dup 3 1 roll def begin
      /ambiguous false def
      /name ED
      {0 0} exch 3 -1 roll exec
      gsave
          translate
          /CompMtrx CM def
      grestore
      /N 1 def
      /n 1 def
      5 dict dup dup /P@1 ED /P@N ED
      begin
          /mode trans def
          {} NewPlaneInt
      end
      /adjustRel true def
  end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NewNodeComp}
%    \begin{macrocode}
/NewNodeComp {
    [ 5 1 roll trans {NewPlaneInt} 1 5 3 roll false NewOptexpComp
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NewCurvedInt}
%    \begin{macrocode}
/NewCurvedInt {
    2 copy 5 3 roll exec 3 -1 roll exec VecAdd 5 -1 roll exec /Y ED /X ED
    exch exec 3 -1 roll exec 2 copy tx@Dict begin Pyth end /R ED /RY ED /RX ED
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NewPlaneInt}
%    \begin{macrocode}
/NewPlaneInt {
    dup 3 -1 roll exec 3 -1 roll exec /DY ED /DX ED
    exch exec 3 -1 roll exec /Y ED /X ED
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NewCompInt}
% Must be called within NewOptexpComp
% The plane has several attributes:
% \{x y\} are the coordinates of the node on the respective plane that is used
%       for unexpanded beams.
% \{...\} in case of a simple plane, this contains \{dx dy\} which is the relative
%       vector that defines the line representing the plane.
%       For curved surfaces, this procedure contains more values.
% type  Integer, characterizes if a surface is reflective or transmittent.
%       To avoid confusion you should use the parameters designed for that
%       (/refl and /trans)
% Name  String, Is the name of the new plane. It is expanded by an 'P@'
% \{New..Int\} Should contain the matching procedure for proper handling of the
%       variable procedure content \{...\}. Can be \{NewPlaneInt\} or \{NewCurvedInt\}
%
% \{ x y \} \{dx dy / rx ry\} mode CompName Name \{New..Int\} \{scaling proc\}
%    \begin{macrocode}
/NewCompInt {
  /scl ED
  /next ED
  dup (P@) exch strcat cvn
  5 dict dup
  3 1 roll def
  begin
    3 -1 roll
    /mode ED
    4 -1 roll dup 5 -1 roll
    {scl} next
  end
%    \end{macrocode}
% store a new node /N@NameX, with X=1..N this node always represents the intersection of an untilted and unshifted incoming beam
% on the optical axis with the respective interface
%    \begin{macrocode}
  3 1 roll strcat exch exec scl ToVec exch @NewNode 
} bind def
%    \end{macrocode}
% \end{macro}
% 
% Define some constants.
%    \begin{macrocode}
/refl 0 def /trans 1 def
/desc 0 def /asc 1 def /amb 2 def
%    \end{macrocode}
% 
% \begin{macro}{@NewNode}
% \{ x y \} NodeName
%    \begin{macrocode}
/@NewNode {
    tx@NodeDict begin (N@) exch strcat cvn false exch 10 {InitPnode } NewNode end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% About the design:
% NewOptexpComp creates a new dictionary that contains everything needed
% for an optical component. It contains the following variables:
% /n             -> refractive index (is usually 1)
% /CompMtrx      -> current matrix to store the planes correctly
% /name          -> name of the component
% /N             -> number of planes
% /P@1 ... /P@N  -> planes used for the 'ray tracing'
%
% \begin{macro}{NewOptexpComp}
% [ \{ x y \} \{ dx dy / rx ry\} type \{New..Int\} refrIndex CompName \{scaling proc\} amb
%    \begin{macrocode}
/NewOptexpComp {
  3 1 roll /sc ED 
  dup cvn
  gsave
  10 dict dup 3 1 roll def begin
  /name ED
  /ambiguous ED
  tx@Dict begin
%    \end{macrocode}
% set scaling for all planes
%    \begin{macrocode}
    STV {CP T} stopped pop
  end
  /CompMtrx CM def
  grestore
%    \end{macrocode}
% count the planes and save their number
%    \begin{macrocode}
  counttomark dup 4 idiv dup /N ED 4 mul eq { 1 } if /n ED
  1 N eq {
%    \end{macrocode}
% only a single plane is specified
%    \begin{macrocode}
      ambiguous { 4 copy name (C) 3 -1 roll {sc} NewCompInt } if
      4 copy name (1) 3 -1 roll {sc} NewCompInt
      name (N) 3 -1 roll {sc} NewCompInt
  }{
      ambiguous {
        name (C) 3 -1 roll {sc} NewCompInt
        /N N 1 sub def
      } if
      N -1 1 { %
        dup N eq { pop (N) }{3 string cvs} ifelse
        exch name 3 1 roll {sc} NewCompInt
      } for
  } ifelse
  end
  pop
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetPlaneVec}
% PlaneNumber CompName -> PlaneVec
%    \begin{macrocode}
/GetPlaneVec {
    cvn load begin
        PlaneName cvn load begin
            currentdict /RX known {
              RX RY CompMtrx dtransform CM idtransform
              neg exch
            } {
              DX DY CompMtrx dtransform CM idtransform
            } ifelse
        end
    end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetPlaneCenter}
% PlaneNumber CompName -> NodeCenter
% or
% \PSproc{Plane} -> NodeCenter
%    \begin{macrocode}
/GetPlaneCenter {
    dup type /stringtype eq not {
      dup xcheck not {
%    \end{macrocode}
% ambiguous
%    \begin{macrocode}
        0 get (C) exch
      } {
        exec pop pop pop
      } ifelse
    } if
    cvn load begin
      PlaneName cvn load begin
        currentdict /RX known {
          X RX sub Y RY sub
        } {
          X Y
        } ifelse
        CompMtrx transform CM itransform
      end
    end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TransformInVec}
% InVec is relative to the connection between first and second components
% transform to absolute coordinates
% Plane2 Plane1 \PSproc{InVec} -> \PSproc{InVec'}
%    \begin{macrocode}
/TransformInVec {
    3 1 roll
    GetPlaneCenter 4 2 roll
    GetPlaneCenter 5 -2 roll
    @ABVect
    3 -1 roll exec 2 copy 6 2 roll
    0 eq exch 0 eq and not {
%    \end{macrocode}
% invec != (0,0)
%    \begin{macrocode}
      exch atan matrix rotate dtransform
    } {
      4 2 roll pop pop
    } ifelse
    ToVec
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TransformStartPos}
% Startpos is relative to the connection between first and second components
% transform to absolute coordinates and shift by first plane center
% Plane2 Plane1 \PSproc{StartPos} -> \PSproc{StartPos'+Plane1Center}
%    \begin{macrocode}
/TransformStartPos {
    exec 2 copy 6 2 roll 0 eq exch 0 eq and not  % SPx SPy P2 P1 neq00
    3 1 roll GetPlaneCenter 4 2 roll % SPx SPy X1 Y1 neq00 P2
    GetPlaneCenter 5 2 roll % SPx SPy X2 Y2 X1 Y1 neq00
    {% SP != (0,0)    SPx SPy X2 Y2 X1 Y1
      2 copy 8 2 roll % X1 Y1 SPx SPy X2 Y2 X1 Y1
      @ABVect exch atan matrix rotate dtransform
      VecAdd
    } {
      6 2 roll pop pop pop pop
    } ifelse
    ToVec
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetNearestPlane}
% X Y CompName -> PlaneNumber
%    \begin{macrocode}
/GetNearestPlane {
  3 copy 1 exch GetPlaneCenter @ABDist /dist ED /nearestPlane 1 def % X Y CompName
  dup cvn load /N get 2 1 3 -1 roll {
%    \end{macrocode}
% iterate through plane 2 to plane N of CompName 
%    \begin{macrocode}
    4 copy exch GetPlaneCenter @ABDist dup dist lt {
      /dist ED /nearestPlane ED
    } {
      pop pop
    } ifelse
  } for
  pop pop pop nearestPlane
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PushAmbCompPlanesOnStack}
% Components which do not have an unambiguous behaviour (beamslitter, can
% transmit and reflect) like lenses (transmission only) or mirrors (reflection
% only), must be evaluated to see which mode should be used.  Argument is
% [(name) draw], draw is a boolean which is true if the inner beams should be
% drawn.
%    \begin{macrocode}
/PushAmbCompPlanesOnStack {
  currentdict /outToPlane undef
  PN PlaneNum eq not {
%    \end{macrocode}
% not the last plane, there should be another one on the stack
%    \begin{macrocode}
    exch dup 3 1 roll % plane ambcomp plane
    dup xcheck not {
%    \end{macrocode}
% the next component is also an ambcomp, use its center point as reference.
%    \begin{macrocode}
      0 get (C) exch
    } {
%    \end{macrocode}
% otherwise use the plane node
%    \begin{macrocode}
      exec pop pop pop
    } ifelse
    [ 3 1 roll ] cvx /outToPlane ED
%    \end{macrocode}
% outToPlane is \{(PN) (compName)\}
%    \begin{macrocode}
  } if
%    \end{macrocode}
% the old plane number, without counting the additional planes of the current ambcomp
%    \begin{macrocode}
  /PlaneNumTmp PlaneNum def
  aload pop /draw ED /name ED
  name cvn load /N get /N ED
  currentdict /Curr known {
    /CurrTmp /Curr load def
    /CurrVecTmp /CurrVec load def
  } {
    /CurrTmp /CurrLow load def
    /CurrVecTmp /CurrVecLow load def
  } ifelse
%    \end{macrocode}
% CurrTmp is the current point of the beam on the previous plane, CurrVecTmp its outgoing vector.
%    \begin{macrocode}
  1 N eq {
%    \end{macrocode}
% only a single interface
%    \begin{macrocode}
    [ (C) name 1 
    PN 1 eq PN PlaneNum eq or {
%    \end{macrocode}
% its the first or last comp
%    \begin{macrocode}
      trans
    } {
%    \end{macrocode}
% somewhere in the middle, check the mode (trans or refl)
%    \begin{macrocode}
      CurrVecTmp (C) name GetPlaneVec NormalVec outToPlane GetPlaneCenter (C) name GetPlaneCenter @ABVect SProd
      0 lt { trans } { refl } ifelse % mode
    } ifelse
    true ] cvx
  } {
%    \end{macrocode}
% three interfaces
%    \begin{macrocode}
    PN 1 eq {
%    \end{macrocode}
% first component
%    \begin{macrocode}
      [ (C) name
      nforce 0 eq { name cvn load /n get } { nforce } ifelse
      trans draw ] cvx
%    \end{macrocode}
% now check which is the outgoing plane
%    \begin{macrocode}
      name /outToPlane load GetNextPlane
      [ exch name 1 trans draw ] cvx exch
      /PlaneNumTmp PlaneNumTmp 1 add def
    } {
      CurrTmp name GetNearestPlane /nextPlane ED
%    \end{macrocode}
% check if mode is trans or refl
%    \begin{macrocode}
      CurrVecTmp nextPlane name GetPlaneVec NormalVec
      (C) name GetPlaneCenter nextPlane name GetPlaneCenter @ABVect 2 copy 6 2 roll SProd 
      0 lt { trans }{ refl } ifelse
      3 1 roll ToVec /CurrVecTmp ED
      [ nextPlane name
      connectplanes {
        1
      }{
        nforce 0 eq { name cvn load /n get } { nforce } ifelse
      } ifelse
%    \end{macrocode}
% always draw to first interface
%    \begin{macrocode}
      5 -1 roll true ] cvx
      PN PlaneNum eq {
%    \end{macrocode}
% its the last comp, just put the center plane on the stack
%    \begin{macrocode}
        [ (C) name
        nforce 0 eq { name cvn load /n get } { nforce } ifelse
        trans draw ] cvx exch
        /PlaneNumTmp PlaneNumTmp 1 add def
      } {
%    \end{macrocode}
% check the mode
%    \begin{macrocode}
        [ (C) name
        connectplanes {
          1
        } {
          nforce 0 eq { name cvn load /n get } { nforce } ifelse
        } ifelse
        CurrVecTmp (C) name GetPlaneVec NormalVec outToPlane GetPlaneCenter (C) name GetPlaneCenter @ABVect SProd
        0 lt { trans } { refl } ifelse % mode
        draw ] cvx exch
%    \end{macrocode}
% now check which is the outgoing plane
%    \begin{macrocode}
        name /outToPlane load GetNextPlane
        [ exch name 1 trans draw ] cvx 3 1 roll
        /PlaneNumTmp PlaneNumTmp 2 add def
      } ifelse
    } ifelse
  } ifelse
  /PlaneNum PlaneNumTmp def
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetNextPlane}
% \PSstring{comp} \PSproc{outToPlane} $\longmapsto$ \PSvar{PlaneNumber}
%    \begin{macrocode}
/GetNextPlane {
  2 copy (C) 3 -1 roll % (CompName) {outToPlane} {outToPlane} (C) (CompName)
  GetPlaneCenter 3 -1 roll exec GetPlaneCenter 4 2 roll 4 copy @ABVect /VecY ED /VecX ED @ABDist /centerDist ED
  /sprod 1 def % (CompName) {outToPlane}
  exch dup 3 1 roll cvn load /N get 1 1 3 -1 roll {% (CompName) {outToPlane} n
%    \end{macrocode}
% iterate through all planes of CompName
%    \begin{macrocode}
    3 copy 3 -1 roll 2 copy% (CompName) {outToPlane} n {outToPlane} n (CompName) n (CompName)
    GetPlaneVec VecX VecY 4 2 roll NormalVec VecX VecY SProd dup sprod lt 
    5 2 roll % sprod bool {outToPlane} n (CompName)
    GetPlaneCenter 3 -1 roll exec GetPlaneCenter @ABDist centerDist lt and
    { /sprod ED /nextPlane ED } { pop pop } ifelse
  } for
  pop pop nextPlane
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TraceBeam}
% [ CompN ... Comp1 \PSproc{options} \PSproc{start point} \PSvar{beamangle}
% -> Yn Xn drawToN? ... Y1 X1 drawTo1? Y0 X0
%    \begin{macrocode}
/TraceBeam {
  AngToVec /InVec ED /StartPoint ED
  /oldbeaminsidelast currentdict /beaminsidelast known { beaminsidelast } { false } ifelse def
%    \end{macrocode}
% preset options
%    \begin{macrocode}
  /nmul 1 def
  /nadd 0 def
  /nforce 0 def
%    \end{macrocode}
% execute options
%    \begin{macrocode}
  exec
  /startinside startinside beaminsidefirst or def
  /stopinside stopinside beaminsidelast or def
  counttomark /N ED
  PrearrangePlanes
  PushAllPlanesOnStack
  beamangleabs not {
    2 copy /InVec load TransformInVec
  } {
    /InVec load
  } ifelse
  /CurrVec ED
  custombeam currentdict /lastBeamPoint known and {
    /lastBeamPoint load /Curr ED
  }{
    2 copy /StartPoint load  TransformStartPos /Curr ED
  } ifelse
  counttomark /PlaneNum ED 
%    \end{macrocode}
% Init the refractive index
%    \begin{macrocode}
  /n1 1 def
  /PN 1 def
  { 
%    \end{macrocode}
% iterate over all planes
%    \begin{macrocode}
    dup xcheck not {
%    \end{macrocode}
% array, not executable
%    \begin{macrocode}
      PushAmbCompPlanesOnStack
    } if
    %% {PlaneNumber CompName n mode draw}
    exec
    /draw ED
    /Mode ED
    3 1 roll % n PlaneNumber CompName
    cvn load begin % comp dict
      PlaneName cvn load begin % plane dict, n on stack
        X Y
        CompMtrx transform CM itransform % n1 X Y
        2 copy ToVec 4 1 roll % {X Y} n1 X Y
        currentdict /RX known { RX RY } { DX DY	} ifelse
        CompMtrx dtransform CM idtransform  % {X Y} n1 X Y DX DY
        Mode 6 -1 roll % {X Y} X Y DX DY mode n1
        Curr CurrVec % {X Y} X Y DX DY mode n1 X0 Y0 X_in Y_in
        currentdict /RX known 
      end
    end
%% {Xp Yp} Xp Yp dXp dYp trans/refl n2 X0 Y0 X_in Y_in curved?
    12 -1 roll /CurrCenter ED
    5 1 roll % curved? X0 Y0 X_in Y_in
    connectplanes PN 2 ge and {
      CurrVec CurrCenter CurrCenterTmp ModeTmp currentdict /relAngle known { relAngle } { 0 } ifelse connectPlanes
      /relAngle ED
    } if
    5 -1 roll
    { CurvedInterface }{ PlainInterface } ifelse
    PN 1 eq {
      pop pop
      /draw beaminsidefirst oldbeaminsidelast xor def
    } {
      ToVec /CurrVec ED
    } ifelse
    2 copy
    ToVec /Curr ED 
    draw
    counttomark 3 roll
    /CurrCenterTmp /CurrCenter load def
    /lastBeamPoint /Curr load def
    /lastVec /CurrVec load def
    /ModeTmp Mode def
    PN PlaneNum eq {
      exit
    } {
      CurrVec 0 eq exch 0 eq and {
%    \end{macrocode}
% last refraction was total internal reflection, exit!
%    \begin{macrocode}
        PlaneNum PN sub {pop} repeat
        exit
      } if
      /PN PN 1 add def
    } ifelse
  } loop
  currentdict /CurrVec undef
  currentdict /Curr undef
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{Drawbeam}
% [ CompN ... Comp1 \PSproc{options} \PSproc{start point} \PSproc{input vector}
%    \begin{macrocode}
/Drawbeam {
  counttomark 3 eq {
%    \end{macrocode}
% first ray misses the next interface
%    \begin{macrocode}
    pop pop pop
  }{
    pop 5 copy 3 -1 roll pop ArrowA pop pop pop pop % go to Startpoint
    counttomark 3 idiv -1 2 {
      pop {
        lineto
      }{
        moveto
      } ifelse
    } for
    {CP 4 2 roll ArrowB lineto pop pop } {moveto} ifelse
%    \end{macrocode}
% remove [
%    \begin{macrocode}
    pop
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{sign}
%    \begin{macrocode}
/sign {
    0 ge { 1 } { -1 } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TraceWideBeam}
% Stroke an extendend beam. Only rearranges the input parameters and calls Drawbeam twice, for the upper
% and lower beam.
% [ CompN ... Comp1 \PSproc{options} \PSproc{start point up} \PSproc{input vector up} \PSproc{start point low} \PSproc{input vector low}
%    \begin{macrocode}
/TraceWideBeam {
%    \end{macrocode}
% correct rotation of input vectors
%    \begin{macrocode}
  5 -1 roll dup 6 1 roll 3 1 roll % {opt} {sup} {inup} {opt} {slow} {inlow}
  counttomark 6 sub /numComp ED
  numComp 7 add 6 roll numComp 1 add copy % {opt} {sup} {inup} {opt} {slow} {inlow} [ CompN .. Comp1 [ CompN .. Comp1
  numComp 1 add 2 mul 6 add numComp 1 add roll % [ CompN .. Comp1 {opt} {sup} {inup} {opt} {slow} {inlow} [ CompN .. Comp1
  numComp 1 add 3 add -3 roll % [ CompN .. Comp1 {opt} {sup} {inup} [ CompN .. Comp1 {opt} {slow} {inlow}
  currentdict /lastBeamPointLow known {
    /lastBeamPointLow load /lastBeamPoint ED
  } if
  TraceBeam
  /lastBeamPoint load /lastBeamPointLow ED
  /lastVec load /lastVecLow ED
  currentdict /lastBeamPoint undef
  currentdict /lastBeamPointUp known {
    /lastBeamPointUp load /lastBeamPoint ED
  } if
  counttomark 1 add dup numComp 4 add add exch roll
  TraceBeam
  /lastBeamPoint load /lastBeamPointUp ED
  /lastVec load /lastVecUp ED
  lastBeamPointUp lastBeamPointLow @ABVect lastVecUp lastVecLow 3 -1 roll add 3 1 roll add exch
  4 -1 roll mul 3 1 roll mul sub 0 gt {
%    \end{macrocode}
% swap upper and lower beam points for next beam
%    \begin{macrocode}
    /lastBeamPointUp load /lastBeamPointLow load /lastBeamPointUp ED /lastBeamPointLow ED
  } if
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{FillWideBeam}
% Fill a wide beam. This must have an own procedure, because all segments
% of the beam must be filled separately.
% 
% [ CompN ... Comp1 \PSproc{options} \PSproc{start point up} \PSvar{beamangle\_up} \PSproc{start point low} \PSvar{beamangle\_low} 
%    \begin{macrocode}
/FillWideBeam {
  AngToVec /InvecLow ED /StartLow ED 
  AngToVec /InvecUp ED /StartUp ED 
%    \end{macrocode}
% preset options
%    \begin{macrocode}
  currentdict /fillBeam known not { /fillBeam {gsave fill grestore} def } if
  /DrawnSegm 0 def
  /nmul 1 def
  /nadd 0 def
  /nforce 0 def
%    \end{macrocode}
% execute user options
%    \begin{macrocode}
  exec
  /startinside startinside beaminsidefirst or def
  /stopinside stopinside beaminsidelast or def
  PrearrangePlanes
  PushAllPlanesOnStack
  beamangleabs not {
    2 copy /InvecLow load TransformInVec /CurrVecLow ED
    2 copy /InvecUp load TransformInVec /CurrVecUp ED
  } {
    /InvecLow load /CurrVecLow ED
    /InvecUp load /CurrVecUp ED
  } ifelse
  custombeam currentdict /lastBeamPointLow known currentdict /lastBeamPointUp known and and {
    /lastBeamPointLow load /CurrLow ED
    /lastBeamPointUp load /CurrUp ED
  } {
    2 copy /StartLow load TransformStartPos /CurrLow ED
    2 copy /StartUp load TransformStartPos /CurrUp ED
  } ifelse
  counttomark /PlaneNum ED /n1 1 def
  /CurrR false def
  /PN 1 def
  {
    dup xcheck not {
%    \end{macrocode}
% array, not executable
%    \begin{macrocode}
      PushAmbCompPlanesOnStack
    } if
    exec
    /draw ED
    /Mode ED
    3 1 roll cvn load begin % comp dict
      PlaneName cvn load begin % plane dict
        X Y CompMtrx transform CM itransform
        2 copy ToVec 4 1 roll
        currentdict /RX known {
          RX RY 
        } {
          DX DY
        } ifelse
        CompMtrx dtransform CM idtransform 4 copy
        Mode 10 -1 roll % {X Y} X Y DX DY X Y DX DY mode n1
        6 copy 
        currentdict /RX known
      end
    end
    /curved ED
    /oldn1 n1 def % {X Y} X Y DX DY X Y DX DY mode n1 X Y DX DY mode n1
    17 -1 roll /CurrPCenter ED
%    \end{macrocode}
% new upper vector and intersection point
%    \begin{macrocode}
    CurrUp CurrVecUp
    connectplanes PN 2 ge and {
      CurrVecUp CurrPCenter CurrPCenterTmp ModeTmp currentdict /relAngleUp known { relAngleUp } { 0 } ifelse connectPlanes
      /relAngleUp ED
    } if
    2 copy ToVec /OldVecUp ED
    curved { CurvedInterface } { PlainInterface } ifelse
    /CurrUp load /OldUp ED
    ToVec /CurrVecUp ED
    ToVec /CurrUp ED
    /n1 oldn1 def
%    \end{macrocode}
% new lower vector and intersection point
%    \begin{macrocode}
    CurrLow CurrVecLow
    connectplanes PN 2 ge and {
      CurrVecLow CurrPCenter CurrPCenterTmp ModeTmp currentdict /relAngleLow known { relAngleLow } { 0 } ifelse connectPlanes
      /relAngleLow ED
    } if
    2 copy ToVec /OldVecLow ED
    curved { CurvedInterface } { PlainInterface } ifelse
    /CurrLow load /OldLow ED
    ToVec /CurrVecLow ED
    ToVec /CurrLow ED
%    \end{macrocode}
% lower done
%    \begin{macrocode}
    /OldR CurrR def
    curved {
      tx@Dict begin Pyth end /CurrR ED
    } {
      pop pop /CurrR false def
    } ifelse
%    \end{macrocode}
% radius done, X Y still on stack
%    \begin{macrocode}
    OldR type /realtype eq {
      /CurrCenter load /OldCenter ED
    } if
    curved {
      ToVec /CurrCenter ED
    } {
      pop pop
      /CurrCenter false def
    } ifelse
%    \end{macrocode}
% center done
%    \begin{macrocode}
    PN 1 gt {
      draw {
        /DrawnSegm dup load 1 add def
        OldUp moveto CurrUp lineto
        curved {
          CurrCenter CurrUp CurrLow 
          4 copy 3 -1 roll eq 3 1 roll eq and {
            6 {pop} repeat
          } {
            TangentCrosspoint
            CurrLow CurrR arct
          } ifelse
        } {
          CurrLow lineto
        } ifelse
        OldLow lineto
        OldR type /booleantype eq not {
%    \end{macrocode}
% previous interface was also curved
%    \begin{macrocode}
          OldCenter OldLow OldUp
          4 copy 3 -1 roll eq 3 1 roll eq and {
            6 {pop} repeat
          } {
            TangentCrosspoint
            OldUp OldR arct
          } ifelse
        } {
          OldUp lineto
        } ifelse
      } if
      Mode refl eq draw and
      draw not DrawnSegm 0 gt and or {
        fillBeam newpath
        /DrawnSegm 0 def
      } if
    } {
%    \end{macrocode}
% PN == 1
%    \begin{macrocode}
      /CurrVecUp /OldVecUp load def
      /CurrVecLow /OldVecLow load def
    } ifelse
    PN PlaneNum eq {
      DrawnSegm 0 gt { fillBeam newpath } if
      exit
    } {
      CurrVecUp 0 eq exch 0 eq and CurrVecLow 0 eq exch 0 eq and or {
%    \end{macrocode}
% last refraction was total internal reflection, exit!
%    \begin{macrocode}
        PlaneNum PN sub {pop} repeat
        DrawnSegm 0 gt { fillBeam newpath } if	
        exit
      } if
      /PN PN 1 add def
    } ifelse
    /CurrPCenterTmp /CurrPCenter load def
    /ModeTmp Mode def
  } loop
  CurrUp CurrLow @ABVect CurrVecUp CurrVecLow 3 -1 roll add 3 1 roll add exch
  4 -1 roll mul 3 1 roll mul sub 0 gt {
%    \end{macrocode}
% swap upper and lower beam points for next beam
%    \begin{macrocode}
    /lastBeamPointUp /CurrLow load def
    /lastBeamPointLow /CurrUp load def
  } {
    /lastBeamPointLow /CurrLow load def
    /lastBeamPointUp /CurrUp load def
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{isAmp}
% Check if 'compname' is ambiguous (i.e. a beamsplitter)
% (compname) -> bool
%    \begin{macrocode}
/isAmb { 
    cvn load /ambiguous get
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{PrearrangePlanes}
% [ CompN .. Comp1 PrearrangePlanes -> [ desc/asc CompN .. desc/asc Comp1 
%    \begin{macrocode}
/PrearrangePlanes {
  counttomark /N ED
  /CompA ED dup /CompB ED
  CompA isAmb {
%    \end{macrocode}
% first component is ambiguous
%    \begin{macrocode}
    amb dup CompA
  } {
    CompB isAmb {
%    \end{macrocode}
% only second component is ambiguous
%    \begin{macrocode}
      1 CompA GetPlaneCenter (C) CompB GetPlaneCenter @ABDist
      (N) CompA GetPlaneCenter (C) CompB GetPlaneCenter @ABDist
    } {
%    \end{macrocode}
% none is ambiguous
%    \begin{macrocode}
      1 CompA GetPlaneCenter 1 CompB GetPlaneCenter (N) CompB GetPlaneCenter true OrderNodes exch pop
      (N) CompA GetPlaneCenter 1 CompB GetPlaneCenter (N) CompB GetPlaneCenter true OrderNodes exch pop % dist1 distN
    } ifelse
    le { desc } { asc } ifelse dup CompA
  } ifelse
  counttomark 2 roll
  2 1 N {
    /i ED exch /CompB ED %
    CompB isAmb not {
      dup desc eq { 1 } { dup amb eq { (C) }{ (N) } ifelse } ifelse CompA GetPlaneCenter
      1 CompB GetPlaneCenter
      (N) CompB GetPlaneCenter false OrderNodes dup dup
%    \end{macrocode}
% check if we have a NodeIfc
%    \begin{macrocode}
      4 -1 roll CompA exch 5 -1 roll CompB exch
      i 2 eq {
%    \end{macrocode}
% check also the first plane
%    \begin{macrocode}
        4 copy 4 2 roll AdjustRelRot
      } if
      AdjustRelRot
    } {
      pop amb dup
    } ifelse
    CompB /CompA CompB def
    counttomark 2 roll
  } for pop
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{AdjustRelRot}
% CompA desc/asc CompB desc/asc
%    \begin{macrocode}
/AdjustRelRot {
  exch dup cvn load /adjustRel known {
    dup dup 4 2 roll isAmb { exch pop (C)}{ desc eq {(N)}{1} ifelse } ifelse exch GetPlaneCenter 5 3 roll
    exch dup 3 1 roll isAmb { pop (C)}{ desc eq {1}{(N)} ifelse } ifelse exch GetPlaneCenter
    @ABVect exch atan exch
    cvn load begin
      adjustRel {
        matrix rotate CompMtrx matrix concatmatrix /CompMtrx ED
        /adjustRel false def
      } {
        pop
      } ifelse
    end
  } {
    pop pop pop pop
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PushAllPlanesOnStack}
% [ desc/asc CompN .. desc/asc Comp1 PushAllPlanesOnStack -> \PSproc{PlaneNumber CompName n mode draw}
% n is the refractive index after the respective interface,
% but draw determines if the connection to this interface is drawn
%    \begin{macrocode}
/PushAllPlanesOnStack {
  counttomark 2 div cvi /numComp ED
  1 1 numComp {
%    \end{macrocode}
% iterate over all components
%    \begin{macrocode}
    /last false def
    /first false def
    dup 1 eq {
      /first true def pop beaminsidefirst
    } {
      numComp eq {
        beaminsidelast
        /last true def
      } {
        beaminside
      } ifelse
    } ifelse /drawinside ED
    load dup /ambiguous get {
      /name get drawinside [ 3 1 roll ]
      counttomark 1 roll pop
    } {
      begin % comp dict
        desc eq {
          N N -1 1 1
        } {
          1 1 1 N N
        } ifelse % start start inc stop stop
        first startinside not and {
%    \end{macrocode}
% first comp and we do not start inside
%    \begin{macrocode}
          5 -2 roll % inc stop stop start start
          pop pop % inc stop stop
          2 copy 5 2 roll
        } if
        5 1 roll % stop start start inc stop
        {
%    \end{macrocode}
% iterate over all planes
%    \begin{macrocode}
          3 1 roll 2 copy 5 -1 roll % stop start stop start i
          dup 3 1 roll % stop start stop i start i
          eq first not and {
%    \end{macrocode}
% always draw the line to the first plane of a component
%    \begin{macrocode}
            true
          } {
%    \end{macrocode}
% the other beams depend on some options
%    \begin{macrocode}
            drawinside
          } ifelse % on stack: stop i draw?
          exch dup 4 -1 roll eq connectplanes or {% draw i i stop
%    \end{macrocode}
% after the last component plane we have always air
%    \begin{macrocode}
            1 
          }{
%    \end{macrocode}
% otherwise the respective refractive index of the component
%    \begin{macrocode}
            nforce 0 eq { n } {nforce} ifelse
          } ifelse % draw i refrIndex
          exch dup N eq {
            pop (N)
          } {
            3 string cvs
          } ifelse exch
          3 1 roll name % refrIndex draw (i) name
          4 1 roll % name refrIndex draw (i)
          dup PlaneName load /mode get % name refrIndex draw i mode
          3 1 roll 5 1 roll % i name refrIndex mode draw
          [ 6 1 roll ] cvx counttomark 1 roll
          last {
            custombeam stopinside not and
            custombeam not beaminsidelast not and or {
              exit
            } if
          } if
        } for pop pop
      end
    } ifelse
  } for
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PlaneName}
% Construct the plane name from PlaneNum. This must be called within a dict of a
% optexpcomp, because the last node ends with (N) instead of the number.
% PlaneNum -> (P@PlaneNum)
%    \begin{macrocode}
/PlaneName {
  dup N eq {
    pop (N)
  } {
    3 string cvs
  } ifelse
  (P@) exch strcat
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{OrderNodes}
% A B1 BN dist? OrderNodes -> desc/asc distance?
%    \begin{macrocode}
/OrderNodes {
   /dist ED
   6 -2 roll 2 copy 8 2 roll
   @ABDist 5 1 roll @ABDist 2 copy gt {
       pop asc exch
   } {
       exch pop desc exch
   } ifelse
   dist not {
       pop
   } if
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{NormalVec}
% Construct a normal plane vector such that $n \times(-in) > 0$
% X\_in Y\_in X\_plane Y\_plane NormalVec -> X\_norm Y\_norm
%    \begin{macrocode}
/NormalVec {
  neg exch 2 copy 6 2 roll SProd 0 gt {
    -1 mul exch -1 mul exch
  } if
  NormalizeVec
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{SProd}
% Scalar product
% ax ay bx by SProd -> val
%    \begin{macrocode}
/SProd {
    3 -1 roll mul 3 1 roll mul add
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{VecAngle}
% Angle between two vectors
% $\cos(\alpha) = \frac{ab}{|a||b|}$
%
% ax ay bx by -> angle
%    \begin{macrocode}
/VecAngle {
    4 copy 4 copy SProd 5 1 roll tx@Dict begin Pyth 3 1 roll Pyth end mul div Acos
    5 2 roll mul 4 1 roll 3 -1 roll mul 3 -1 roll sub 0 le {-1}{1} ifelse mul
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{VecAdd}
% ax ay bx by VecAdd ax+bx ay+by
%    \begin{macrocode}
/VecAdd {
    3 -1 roll add 3 1 roll add exch
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{ToVec}
% X Y -> \PSproc{X Y}
%    \begin{macrocode}
/ToVec {
    [ 3 1 roll ] cvx
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{AngToVec}
% angle -> \PSproc{X Y}
%    \begin{macrocode}
/AngToVec {
    dup cos exch sin ToVec
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NormalizeVec}
% X Y NormalizeVec X' Y' (with $X^2 + Y^2 = 1$)
%    \begin{macrocode}
/NormalizeVec {
  2 copy
  tx@Dict begin
    Pyth
  end
  dup 3 1 roll div 3 1 roll div exch
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{@ABVect}
% Shorthand definition for \PSvar{ABVect} procedure of the \nxLPack{pst-eucl} package.
%    \begin{macrocode}
/@ABVect { tx@EcldDict begin ABVect end } bind def
%    \end{macrocode}
% \end{macro}
%
% Shorthand definition for \PSvar{ABDist} procedure of the \nxLPack{pst-eucl} package.
% \begin{macro}{@ABDist}
%    \begin{macrocode}
/@ABDist { tx@EcldDict begin ABDist end } bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{@InterLines}
%    \begin{macrocode}
/@InterLines { [ 0 0 11 3 roll tx@EcldDict begin InterLines end counttomark 4 eq { 5 2 roll pop pop pop } { 3 -1 roll pop } ifelse } bind def
% 
% \begin{macro}{@GetCenter}
%    \begin{macrocode}
/@GetCenter { dup type /stringtype eq { cvn } if tx@NodeDict begin load GetCenter end } bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{RefractVec}
% see \url{http://en.wikipedia.org/wiki/Snell%27s_law#Vector_form}
%
% X\_in Y\_in X\_norm Y\_norm n1 n2 RefractVec -> X\_out Y\_out
%    \begin{macrocode}
/RefractVec {
  div /n ED 4 2 roll NormalizeVec /Yin ED /Xin ED /Ynorm ED /Xnorm ED
  n 1 eq {
    Xin Yin
  }{
    /costheta1 Xnorm Ynorm Xin neg Yin neg SProd def
    1 n dup mul 1 costheta1 dup mul sub mul sub
    dup 0 lt {
%    \end{macrocode}
% would be total internal reflection, stop
%    \begin{macrocode}
      pop 0 0
    } {
      sqrt /costheta2 ED
      n Xin mul n Yin mul n costheta1 mul costheta2 sub dup Xnorm mul exch Ynorm mul VecAdd
    } ifelse
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{ReflectVec}
% X\_in Y\_in X\_norm Y\_norm ReflectVec -> X\_out Y\_out
%    \begin{macrocode}
/ReflectVec {
  /Ynorm ED /Xnorm ED NormalizeVec /Yin ED /Xin ED
  /costheta1 Xnorm Ynorm Xin neg Yin neg SProd def
  Xin Yin 2 costheta1 mul dup Xnorm mul exch Ynorm mul VecAdd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{CurvedInterface}
% X\_p Y\_p X\_r Y\_r trans/refl n2 X0 Y0 X\_in Y\_in CurvedInterface -> X' Y' X\_out Y\_out
%    \begin{macrocode}
/CurvedInterface {
  /Yin ED /Xin ED /Y0 ED /X0 ED /n2 ED /mode ED
  2 copy /Yr ED /Xr ED 
  tx@Dict begin Pyth end /radius ED /Yp ED /Xp ED
  /X0n X0 Xp sub def /Y0n Y0 Yp sub def
  n2 1 gt { /n2 n2 nmul mul nadd add def } if
  tx@EcldDict begin
    X0n Y0n 2 copy 2 copy Xin 3 -1 roll add Yin 3 -1 roll add
    2 copy 6 2 roll EqDr radius InterLineCircle
  end
  4 copy
  0 eq 3 {exch 0 eq and} repeat {
%    \end{macrocode}
% all coordinates are zero, missed circle, stop
%    \begin{macrocode}
    PlaneNum PN sub 4 add {pop} repeat
    exit
  } if
  4 copy
%    \end{macrocode}
% which of the two intersection points to take? 
%    \begin{macrocode}
  Xr neg Yr neg 2 copy
  8 -2 roll @ABDist %dist from first point
  5 1 roll @ABDist % dist1 dist2
  gt {
%    \end{macrocode}
% take second point
%    \begin{macrocode}
    4 2 roll
  } if pop pop
  Xp Yp VecAdd
  2 copy Xp Yp 4 2 roll @ABVect exch neg Xin Yin 4 2 roll NormalVec Xin Yin 4 2 roll
%    \end{macrocode}
% on stack: crossing point, in vector, and normal vector
%    \begin{macrocode}
  mode trans eq {
    n1 n2 RefractVec
  } {
    ReflectVec
  } ifelse /n1 n2 def
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PlainInterface}
% Xp Yp dXp dYp trans/refl n2 X0 Y0 X\_in Y\_in PlainInterface -> X' Y' X\_out Y\_out
%    \begin{macrocode}
/PlainInterface {%
  /Yin ED /Xin ED /Y0 ED /X0 ED /n2 ED /mode ED /dYp ED /dXp ED /Yp ED /Xp ED
  n2 1 gt { /n2 n2 nmul mul nadd add def } if
  Xp Yp Xp dXp add Yp dYp add X0 Y0 X0 Xin add Y0 Yin add @InterLines Xin Yin
  Xin Yin dXp dYp NormalVec
  mode trans eq {%
    n1 n2 RefractVec
  } {%
    ReflectVec
  } ifelse /n1 n2 def
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TangentCrosspoint}
% Xp Yp Xt1 Yt1 Xt2 Yt2
%    \begin{macrocode}
/TangentCrosspoint {
    4 copy 4 copy 14 -2 roll 2 copy% Xt1 Yt1 Xt2 Yt2 Xt1 Yt1 Xt2 Yt2 Xp Yp Xp Yp
    6 2 roll @ABVect neg exch% Xt1 Yt1 Xt2 Yt2 Xt1 Yt1 Xt2 Yt2 Xt1 Yt1 Xp Yp -(Yt2 -Yp) (Xt2-Xp)
    6 2 roll @ABVect neg exch% Xt1 Yt1 Xt2 Yt2 Xt1 Yt1 Xt2 Yt2 -(Yt2-Yp) (Xt2-Xp) -(Yt1-Yp) (Xt1-Xp)
    8 -2 roll VecAdd 10 2 roll % Xt1-(Yt1-Yp) Yt1+(Xt1-Xp) Xt1 Yt1 Xt2 Yt2 Xt2 Yt2 -(Yt2-Yp) (Xt2-Xp)
    VecAdd % Xt1-(Yt1-Yp) Yt1+(Xt1-Xp) Xt1 Yt1 Xt2 Yt2 Xt2-(Yt2-Yp) Yt2+(Xt2-Xp)
    @InterLines
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NearestNodeTmp}
% {NodeB} CompA -> shortest distance, planenum
%    \begin{macrocode}
/NearestNodeTmp {
  (N@) exch strcat exch /NodeB ED
  /dist -1 def
  1 {% name and counter on stack
    2 copy % name cnt name cnt 
    3 string cvs strcat dup % name cnt (namecnt) (namecnt)
    tx@NodeDict exch known {%
      @GetCenter 2 copy
      NodeB @ABDist % name cnt X Y dist
      dist 0 lt {% init /dist
        /dist ED
        ToVec /node ED
      } {
        dup dist lt {
          /dist ED
          ToVec /node ED
        } {
          pop pop pop
        } ifelse
      } ifelse
      1 add % increment counter
    } {% the last node
      pop pop (N) strcat
      @GetCenter 2 copy
      NodeB @ABDist
      dup dist lt {
        /dist ED
        ToVec /node ED
      } {
        pop pop pop
      } ifelse
      exit
    } ifelse
  } loop
  dist /node load
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NearestNode}
% CompA/NodeA CombB/NodeB -> Coordinates of nodeA or the node of CompA which is nearest to nodeB
%    \begin{macrocode}
/NearestNode {
  dup xcheck not { nametostring } if /CompB ED
  dup xcheck not {% CompA
    nametostring /CompA ED
    /CompB load dup xcheck not {% CompB
      /mindist -1 def
      [ exch false GetInternalNodeNames ] 
      { @GetCenter ToVec
        CompA NearestNodeTmp 
        exch dup mindist gt mindist 0 ge and { pop pop }{ /mindist ED /minnodeA ED } ifelse
      } forall
      minnodeA
    } {
      CompA NearestNodeTmp exch pop exec
    } ifelse
  } {% else, it is a node and we already have the appropriate coordinates on the stack
    exec
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{RelFiberAngle}
% Calculate start angle of \cs{pccurve} from CompA to CompB
%
% $@@X_B$ $@@Y_B$ $@@X_A$ $@@Y_A$ A B $\quad\longmapsto\quad$ angleA
%    \begin{macrocode}
/RelFiberAngle {
  dup xcheck not { nametostring } if /CompB ED
  dup xcheck not { nametostring } if /CompA ED
  /CompA load xcheck {
    /CompB load xcheck {
%    \end{macrocode}
%  both parameters are nodes, so the angle is that of the direct connection line.
%    \begin{macrocode}
      @ABVect exch atan
    } {
%    \end{macrocode}
% B is a component, and A is a node: the angle at node A is calculated through the reference nodes of component B
%    \begin{macrocode}
      4 copy @ABVect 6 2 roll pop pop % C-N C
      (N@) CompB strcat dup dup (Center) strcat @GetCenter 6 -2 roll 4 2 roll @ABVect% C-N name name C-Center
      4 2 roll % C-N C-Center name name
      (A) strcat exch (B) strcat
      @GetCenter 3 -1 roll @GetCenter @ABVect 2 copy exch atan % C-N CenterB-B refB-refA angle
      7 3 roll 2 copy % refB-refA angle C-N C-Center C-Center
      9 -2 roll %  angle C-N C-Center C-Center refB-refA
      SProd 0 gt 5 1 roll SProd 0 gt xor { 180 add } if
    } ifelse
  } {
%    \end{macrocode}
% A is a component, B is insignificant
%    \begin{macrocode}
    4 2 roll pop pop
    (N@) CompA strcat dup dup (Center) strcat @GetCenter 
    6 -2 roll @ABVect 4 2 roll
    (TrefA) strcat exch (TrefB) strcat
    @GetCenter 3 -1 roll @GetCenter @ABVect 2 copy exch atan
    5 1 roll SProd 0 gt { 180 add } if
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{restoreBeamPoints}
%    \begin{macrocode}
/restoreBeamPoints {
    tx@OptexpDict dup /TmpLastBeamPointLow known { 
        /lastBeamPointLow /TmpLastBeamPointLow load def 
        /TmpLastBeamPointLow undef 
    } { 
        /lastBeamPointLow undef 
    } ifelse
    tx@OptexpDict dup /TmpLastBeamPointUp known {
        /lastBeamPointUp /TmpLastBeamPointUp load def 
        /TmpLastBeamPointUp undef 
    } { 
        /lastBeamPointUp undef 
    } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{rearrangeSingleBeamPoints}
% rearrange points of single beam
%
% [ A [ B -> [ B A
%    \begin{macrocode}
/rearrangeSingleBeamPoints {
  counttomark dup 2 add -1 roll pop % [ A B cnt
  dup counttomark 2 sub eq not { % [ A B cnt cnt!=counttomark % not the first beam
    4 1 roll pop pop pop 3 sub % [ A B cnt-3
  } if
  counttomark 1 sub exch roll
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{rearrangeWideBeamPoints}
% rearrange points of wide beam
%
%[ A [ B [ C [ D -> [ C A [ D B
%    \begin{macrocode}
/rearrangeWideBeamPoints {
  counttomark 1 add -1 roll pop % [ A [ B [ C D
  counttomark /t ED t 1 add -1 roll pop % [ A [ B C D
  counttomark t eq { % B is empty, first beam
    counttomark 1 add 1 [ 3 1 roll roll % [ C [ D
  } {
    counttomark 1 add -1 roll pop % [ A B C D
    counttomark t sub /@rest ED
%    \end{macrocode}
% check if first point of C/D is the same as last point of A/B
% due to symmetry, need to check only D and B
%    \begin{macrocode}
    t @rest 2 idiv add -3 roll 6 copy pop 3 -1 roll pop
    3 -1 roll sub abs 1e-5 lt 3 1 roll sub abs 1e-5 lt and { % same points
      t @rest 2 idiv add 3 roll	
      pop pop pop t 2 idiv -3 roll pop pop pop
      /t t 6 sub def
    } {
      t @rest 2 idiv add 3 roll
    } ifelse
    t t 2 idiv roll % [ A B D C
    counttomark t 2 idiv roll % [ C A B D
    counttomark 2 idiv t 2 idiv roll % [ C A D B
    counttomark 2 idiv 1 add 1 [ 3 1 roll roll
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{getsubnode}
% subname node/name  -> coordinates
%    \begin{macrocode}
/getsubnode {
  dup xcheck {
      exch pop exec
  } {
      nametostring (N@) exch strcat
      exch nametostring strcat
      @GetCenter
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{connectPlanes}
% Vec Vec Center CenterTemp mode relangle
%    \begin{macrocode}
/connectPlanes {
  /relAngleTmp ED
  PN 2 eq {
%    \end{macrocode}
% initialize relAngle, the angle between plane connection and input vector
%    \begin{macrocode}
    pop @ABVect NormalizeVec 4 2 roll VecAngle /relAngleTmp ED
  } if
  PN 3 ge {
    trans eq {
%    \end{macrocode}
% previous plane was transmittive, recalculate the input vector
%    \begin{macrocode}
      @ABVect NormalizeVec 4 2 roll pop pop % remove Vec from stack
      relAngleTmp matrix rotate dtransform
      4 2 roll pop pop
    } {
%    \end{macrocode}
% else, the previous plane was reflective, recalculate relAngle
%    \begin{macrocode}
      @ABVect NormalizeVec 4 2 roll VecAngle /relAngleTmp ED
    } ifelse
  } if
  relAngleTmp
} bind def
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
end % tx@OptexpDict
%    \end{macrocode}
%</prolog> 
% \Finale
% \endinput
%
%<*indexstyle>
headings_flag       1		% headings yes
heading_prefix   "\\textbf{" 	% boldfont
heading_suffix   "}\n"		% newline
quote		'"'
level		'!'
actual          '='
preamble
  "\\begin{theindex}\n"
item_1
  "\\par\\leavevmode\\hangindent10pt\\makebox[15pt][l]{ -- }"
item_01
  "\\par\\leavevmode\\hangindent10pt\\makebox[15pt][l]{ -- }"
item_x1
  "\\par\\leavevmode\\hangindent10pt\\makebox[15pt][l]{ -- }"
item_2
  "\\par\\leavevmode\\hangindent20pt\\makebox[30pt][l]{ -- -- }"
item_12
  "\\par\\leavevmode\\hangindent20pt\\makebox[30pt][l]{ -- -- }"
item_x2
  "\\par\\leavevmode\\hangindent20pt\\makebox[30pt][l]{ -- -- }"
%</indexstyle>
