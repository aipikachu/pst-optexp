% \iffalse meta-comment
%
% Copyright (C) 2007-2011 by Christoph Bersch <usenet@bersch.net>
% -------------------------------------------------------
% 
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.2
% of this license or (at your option) any later version.
% The latest version of this license is in:
%
%    http://www.latex-project.org/lppl.txt
%
% and version 1.2 or later is part of all distributions of LaTeX 
% version 1999/12/01 or later.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{pst-optexp.dtx}
%</driver>
%<stylefile>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<stylefile>\ProvidesPackage{pst-optexp}
%<*stylefile>
    [2011/12/05 v3.0beta Optical experimental setups with PSTricks]
%</stylefile>
%
%<*driver>
\documentclass[a4paper, DIV=9, oneside, toc=index]{scrreprt}
\usepackage{doc}
\setcounter{IndexColumns}{2}
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage{lmodern} 
\usepackage{amsfonts, amsmath, marvosym} 
\usepackage{bera}
\providecommand*\mainlang{}
\usepackage[ngerman, english,\mainlang]{babel} 
\usepackage{prettyref}
\usepackage[dvipsnames,x11names,svgnames]{xcolor} 
\usepackage{array,booktabs,tabularx} 
\usepackage{ragged2e} 
\usepackage{nicefrac}
\usepackage{pst-func} 
\usepackage{pst-optexp} 
\usepackage{pst-circ}
\usepackage[makeindex]{splitidx} 
\usepackage{etoolbox}
\usepackage{hypdoc} 
\hypersetup{colorlinks=true, urlcolor=black,
  linkcolor=pdflinkcolor, breaklinks,
  linktocpage=true} 
\usepackage{breakurl}
\definecolor{DOrange}{rgb}{1,.4,.2}%
\colorlet{pdflinkcolor}{DOrange}
\usepackage{pst-tree}
\newcommand{\poeTR}[1]{\TR{\ttfamily\color{DOrange}#1}}
\usepackage{showexpl} 
\undef{\cs}
\undef{\cmd}
\usepackage{ltxdockit}
\makeatletter\renewcommand*\SX@Info{}\makeatother
\definecolor{colKeys}{rgb}{0,0,0}
\definecolor{colIdentifier}{rgb}{0,0,0}
\colorlet{colComments}{green!60!black}
\definecolor{colString}{rgb}{0,0.5,0} 
\newlength{\codeoverhang}
\setlength{\codeoverhang}{0.5\marginparwidth+0.5\marginparsep}
\lstset{%
  language=[LaTeX]TeX, identifierstyle=\color{colIdentifier}, %
  keywordstyle=\color{colKeys}, %
  keywordstyle = [21]\color{DOrange}, %
  stringstyle=\color{colString}, %
  commentstyle=\color{colComments}, %
  float=hbp,%
  basicstyle=\ttfamily\small, %
  columns=flexible, %
  tabsize=4, %
  extendedchars=true, %
  showspaces=false, %
  showstringspaces=false, %
  breaklines=true, %
  breakautoindent=true, %
  captionpos=b, %
  xleftmargin=1em, %
  prebreak = {\raisebox{-1ex}[\ht\strutbox]{\kern0.5ex \Large\Righttorque}},
  rulecolor=\color{black!20}, %
  texcsstyle = [20]\color{DOrange}, %
  moretexcs = [20]{lens, optbox, oenode, oenodeIn, oenodeExt, oenodeOut,
    oenodeRefA, oenodeRefB, oenodeTrefA, oenodeTrefB, oenodeLabel,
    oenodeRotref, oenodeBeam, oenodeBeamUp, oenodeBeamLow,
    oenodeCenter, optplate, optretplate, pinhole, crystal,optdetector,
    optdiode, doveprism, polarization, mirror, beamsplitter, optgrating,
    optprism, rightangleprism, pentaprism, optdipole, optripole,
    optfiber, optamp, optmzm, optfilter, polcontrol, optisolator,
    optswitch, fiberdelayline, optfiberpolarizer, fibercollimator,
    optcoupler, wdmcoupler, wdmsplitter, drawbeam, drawwidebeam,
    drawfiber, frontlayer, backlayer, newOptexpDipole,
    newOptexpTripole, newOptexpFiberDipole}, %
  explpreset={%
    escapeinside={*}{*}, pos=l, width=-99pt, hsep=5mm, overhang=\codeoverhang,
    varwidth, vsep=\bigskipamount, rframe={}}}
\lstset{
  literate={ö}{{\"o}}1
           {ä}{{\"a}}1
           {ü}{{\"u}}1
}
\colorlet{sectioncolor}{DOrange}
\addtokomafont{sectioning}{\color{sectioncolor}}
\addtokomafont{subsection}{\Large}
\addtokomafont{subsubsection}{\Large}
\usepackage[automark,nouppercase]{scrpage2}
\pagestyle{scrheadings}
\clearscrheadings
\clearscrplain
\ohead{\pagemark}
\ihead{\headmark}
\ofoot[\pagemark]{}
\automark[subsection]{section}
\setheadsepline{.4pt}[\color{DOrange}]
\setheadwidth[0pt]{text}
\setfootwidth[0pt]{text}
%%
\makeatletter
\renewcommand*\l@section{\bprot@dottedtocline{1}{1.5em}{3.0em}}
\renewcommand*\l@subsection{\bprot@dottedtocline{2}{3.8em}{4.0em}}
\newrobustcmd*{\fnurl}[1][]{\hyper@normalise\ltd@fnurl{#1}}
\def\ltd@fnurl#1#2{\footnote{#1\hyper@linkurl{\Hurl{#2}}{#2}}}
\makeatother
%%
\usepackage{csquotes}
\MakeAutoQuote{«}{»}
\colorlet{spot}{sectioncolor}
\newpsstyle{Refline}{linecolor=gray!60}
\makeatletter
\renewenvironment*{changelog}
  {\list{}{%
     \setlength{\leftmargin}{0pt}%
     \setlength{\itemsep}{0pt}%
     \renewcommand*{\makelabel}[1]{##1\hss}%
     \raggedright\changelogfont}%
   \def\release##1##2{%
     \@release{##1}{##2}%
     \list{}{%
       \setlength{\leftmargin}{1.5em}%
       \setlength{\itemindent}{-1.5em}%
       \setlength{\itemsep}{0pt}%
       \setlength{\parsep}{0pt}%
     }%
     \samepage
     \begingroup
     \def\item{\endgroup\item\@itempenalty\z@}}%
   \def\endrelease{\endlist}%
   \def\@release##1##2{%
     \begingroup
     \changeloglabelfont
     \item\relax
     \ltd@pdfbookmark{##1}{##1 (##2)}%
     ##1\quad##2\par\nobreak
     \endgroup}
   \def\see##1{%
     \leaders\hbox{$\m@th\mkern4.5mu\hbox{.}\mkern4.5mu$}%
     \hfill\makebox[3em][l]{\ref{##1}}}}
  {\endlist}
\makeatother

\renewcommand*{\verbatimfont}{\ttfamily}
\renewcommand*{\displayverbfont}{\ttfamily}
\renewcommand*{\marglistfont}{\spotcolor\sffamily\small}
\renewcommand*{\margnotefont}{\sffamily\small}
\renewcommand*{\optionlistfont}{\spotcolor\sffamily\displayverbfont}
\renewcommand*{\ltxsyntaxfont}{\ttfamily}
\renewcommand*{\ltxsyntaxlabelfont}{\spotcolor\displayverbfont}
\renewcommand*{\changelogfont}{\normalfont}
\renewcommand*{\changeloglabelfont}{\spotcolor\sffamily\bfseries}

\makeatletter
%% an idea from GL to provide links inside the listings to the pst-optexp commands: 
%% <https://groups.google.com/groups/search?as_umsgid=4d89ee49%240%2418590%24426a74cc%40news.free.fr>
\providerobustcmd*\ifrefundefined [1]{%
  \begingroup%
    \csname @safe@activestrue\endcsname%
    \expandafter\endgroup\csname @\ifcsname r@#1\endcsname second\else first\fi oftwo\endcsname
}% \ifrefundefined
\def\lsthk@OutputBox@H@@k{%
    \begingroup%
      \let\lst@UM\@empty%
      \edef\@tempc{cmd:\detokenize\expandafter{\the\lst@token }}%\edef
      \ifrefundefined{\@tempc}%
    \endgroup%
    \sethyperlistings%
}% \lsthk@OutputBox@H@@k
\def\sethyperlistings {\global\let \hyperlistingsreference =\@tempc
     \endgroup \aftergroup \dohyperlistings }% after \hbox
\def\dohyperlistings {\def\lst@alloverstyle ##1{\hyperlistings ##1}}
\def\hyperlistings{%
    \setbox\@tempboxa\hbox%
    \bgroup%
      \rlap{\hypersetup {linkcolor=.}\relax\fboxrule\z@%
      \hyperref[\hyperlistingsreference]{\boxframe{\wd\@tempboxa}{\ht\@tempboxa}{\dp\@tempboxa}}}%
      \unhbox\@tempboxa%
    \egroup%
}% \hyperlistings
\let\lsthk@OutputBox\lsthk@OutputBox@H@@k
\makeatother
\DeclareRobustCommand\lsb{{\normalfont\ttfamily[}}
\makeatletter
\def\ltd@optionlist{%
  \let\optitem\POE@optitem
  \let\styleitem\POE@styleitem
  \let\valitem\POE@valitem
  \let\choitem\POE@choitem
  \let\boolitem\POE@boolitem
  \let\intitem\POE@intitem
  \let\numitem\POE@numitem
  \let\psnumitem\POE@psnumitem
  \let\poeitem\ltd@item}

\def\POE@optitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@optitem@i}
    {\booltrue{@tempswa}\POE@optitem@i}}
\newcommand*{\POE@optitem@i}[3][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{#3}{}}
    {\ltd@option{#2}{#2}{#3}{\ltd@textverb{#1}}}}%

\def\POE@styleitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@styleitem@i}
    {\booltrue{@tempswa}\POE@styleitem@i}}
\newcommand*{\POE@styleitem@i}[2][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLstyle{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{psstyle}}{}}
    {\ltd@option{#2}{#2}{\prm{psstyle}}{\ltd@textverb{#1}}}}%

\def\POE@valitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@valitem@i}
    {\booltrue{@tempswa}\POE@valitem@i}}
\newcommand*{\POE@valitem@i}[3][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{#3}}{}}
    {\ltd@option{#2}{#2}{\prm{#3}}{\ltd@textverb{#1}}}}%

\def\POE@choitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@choitem@i}
    {\booltrue{@tempswa}\POE@choitem@i}}
\newcommand*{\POE@choitem@i}[3][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\ltd@verblist{#3}}{}}
    {\ltd@option{#2}{#2}{\ltd@verblist{#3}}{\ltd@textverb{#1}}}}%

\def\POE@boolitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@boolitem@i}
    {\booltrue{@tempswa}\POE@boolitem@i}}
\newcommand*{\POE@boolitem@i}[2][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\ltd@verblist{true,false}}{}}
    {\ltd@option{#2}{#2}{\ltd@verblist{true,false}}{\ltd@textverb{#1}}}}%

\def\POE@intitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@intitem@i}
    {\booltrue{@tempswa}\POE@intitem@i}}
\newcommand*{\POE@intitem@i}[2][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{int}}{}}
    {\ltd@option{#2}{#2}{\prm{int}}{\ltd@textverb{#1}}}}%

\def\POE@numitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@numitem@i}
    {\booltrue{@tempswa}\POE@numitem@i}}
\newcommand*{\POE@numitem@i}[2][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{num}}{}}
    {\ltd@option{#2}{#2}{\prm{num}}{\ltd@textverb{#1}}}}%

\def\POE@psnumitem{%
  \@ifstar
    {\boolfalse{@tempswa}\POE@psnumitem@i}
    {\booltrue{@tempswa}\POE@psnumitem@i}}
\newcommand*{\POE@psnumitem@i}[2][]{%
  \ifbool{@tempswa}{\label{prm:#2}}{}%
  \xLkeyword{#2}%
  \ifblank{#1}
    {\ltd@option{#2}{#2}{\prm{psnum}}{}}
    {\ltd@option{#2}{#2}{\prm{psnum}}{\ltd@textverb{#1}}}}%

\def\ltd@cmditem@ii#1#2{%
  \ltd@itemsave
  \ifhmode
    \itemsep-\topsep
  \else
    \ltd@itembreak
  \fi
  \item[#1]%
  \ltd@itemrest
  \ifblank{#2}{}{\label{cmd:#2}}%
  \begingroup
  \ltd@syntaxsetup
  \ltxsyntaxfont
  \let\@tempa\@empty
  \ltd@parseargs}


\let\plainllap\llap
\newrobustcmd\macro@llap[1]{{\global\let\llap\plainllap
 \setbox0=\hbox\bgroup \macro@font\small\saved@macroname\egroup
 \ifdim\wd0>30mm
    \hbox to\z@ \bgroup\hss \hbox to30mm{\unhcopy0\hss}\egroup
    \edef\@tempa{\hskip\dimexpr\the\wd0-30mm}\global\everypar\expandafter{\the\expandafter\everypar
                                                                           \@tempa \global\everypar{}}%
 \else \llap{\unhbox0}\fi}}
 \AtBeginEnvironment{macro}{\let\llap\macro@llap}
\makeatother

\newcommand*{\PSstring}[1]{{\normalfont\small\ttfamily(#1)}}
\newcommand*{\PSname}[1]{{\normalfont\small\ttfamily/#1}}
\newcommand*{\PSproc}[1]{{\normalfont\small\ttfamily\textbraceleft #1\textbraceright}}
\newcommand*{\PSvar}[1]{{\normalfont\small\ttfamily #1}}
\newcommand*{\PSop}[1]{{\normalfont\small\ttfamily\color{DOrange}\hskip 3pt #1\hskip 3pt}}

\newcommand*{\nodename}[1]{\emph{#1}}
\newcommand*{\param}[1]{\normalfont\texttt{#1}}
\newcommand*{\paramvalue}[1]{\texttt{#1}}
\newcommand*{\styleshape}[1]{\texttt{#1}}
\newcommand{\docindex}[1]{\sindex[doc]{#1|hyperpage}}
\makeatletter
\def\xLcs#1{\docindex{#1=\nxLcs{#1}}\docindex{\POEindexMacro!#1=\nxLcs{#1}}}
\def\Lcs#1{\nxLcs{#1}\xLcs{#1}}
\def\nxLcs#1{\texttt{\textbackslash#1}}

\def\LPack#1{\texttt{#1}\docindex{#1=\texttt{#1}}\docindex{\POEindexPackage!#1=\texttt{#1}}}
\def\nxLPack#1{\texttt{#1}}

\def\Lkeyword{\@ifstar{\Lkeyword@nobm}{\Lkeyword@bm}}
\def\Lkeyword@nobm#1{\texttt{#1}\xLkeyword{#1}}
\def\Lkeyword@bm#1{\hyperref[prm:#1]{\Lkeyword@nobm{#1}}}
\def\xLkeyword#1{\docindex{#1=\texttt{#1}}\docindex{\POEindexKeyword!#1=\texttt{#1}}}
\def\nxLkeyword#1{\texttt{#1}}

\def\xLoption#1{\docindex{#1=\texttt{#1}}\docindex{\POEindexOption!#1=\texttt{#1}}}
\def\Loption#1{\texttt{#1}\xLoption{#1}}
\def\nxLoption#1{\texttt{#1}}

\def\Lstyle#1{\texttt{#1}\xLstyle{#1}}
\def\xLstyle#1{\docindex{#1=\texttt{#1}}\docindex{\POEindexStyle!#1=\texttt{#1}}}
\def\nxLstyle#1{\texttt{#1}}

\def\Ldipole#1{\nxLcs{#1}\xLdipole{#1}}
\def\xLdipole#1{\docindex{#1=\nxLcs{#1}}\docindex{\POEindexDipoles!#1=\nxLcs{#1}}}

\def\Ltripole#1{\nxLcs{#1}\xLtripole{#1}}
\def\xLtripole#1{\docindex{#1=\nxLcs{#1}}\docindex{\POEindexTripoles!#1=\nxLcs{#1}}}

\def\Lfdipole#1{\nxLcs{#1}\xLfdipole{#1}}
\def\xLfdipole#1{\docindex{#1=\nxLcs{#1}}\docindex{\POEindexFiberDipoles!#1=\nxLcs{#1}}}

\def\Lfmultipole#1{\nxLcs{#1}\xLfmultipole{#1}}
\def\xLfmultipole#1{\docindex{#1=\nxLcs{#1}}\docindex{\POEindexFiberMultipoles!#1=\nxLcs{#1}}}
\makeatother

\newcommand{\dipoledesc}[1]{%
  \xLdipole{#1}%
  \cmditem{#1}[options](in)(out)%
  \cmditem*{#1}[options](in)(out){label}%
}
\newcommand{\tripoledesc}[1]{%
  \xLtripole{#1}%
  \cmditem{#1}[options](in)(center)(out)%
  \cmditem*{#1}[options](in)(center)(out){label}%
}

\newcommand{\fiberdipoledesc}[1]{%
  \xLfdipole{#1}%
  \cmditem{#1}[options](in)(out)%
  \cmditem*{#1}[options](in)(out){label}%
}

\newenvironment*{pssyntax}
  {\list{}{\small
     \setlength{\labelsep}{0pt}%
     \setlength{\leftmargin}{10pt}%
     \item[]}}
  {\endlist}

\newcommand{\psarglistfont}{\small}
\newenvironment*{psarglist}
  {\list{}{%
     \setlength{\labelwidth}{10pt}%
     \setlength{\labelsep}{0pt}%
     \setlength{\leftmargin}{0pt}%
     \setlength{\itemsep}{\parsep}%
     \setlength{\parsep}{0pt}%
     \renewcommand*{\makelabel}[1]{\hss\psarglistfont##1}}}
  {\endlist}

\makeatletter
\renewenvironment{theglossary}{\GlossaryParms \let\item\@idxitem \ignorespaces}{}
\makeatother
\def\psargitem#1{\item[#1]\hfill\par\nobreak}

\addtopsstyle{Fiber}{linecolor=DOrange,linewidth=1.5\pslinewidth}
\addtopsstyle{Beam}{linewidth=1.5\pslinewidth}
\EnableCrossrefs
\CodelineIndex
%%\OnlyDescription
\begin{document}
  \DocInput{pst-optexp.dtx}
  \begin{otherlanguage}{english}
    \printindex[idx]
  \end{otherlanguage}
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \GetFileInfo{pst-optexp.dtx}
%
% \DoNotIndex{\@,\g@addto@macro,\newif,\gdef,\xdef,\newcounter,\or,\ifcase,\\}
% \DoNotIndex{\newcommand,\newenvironment,\def,\edef,\let,\if,\ifx,\else,\fi,\@ifnextchar}
% \DoNotIndex{\space,\relax,\nr,\val,\ignorespaces,\ifdim,\ifcat,\@nil,\@none,\@empty}
% \DoNotIndex{\PackageError,\PackageWarning,\advance,\csname,\endcsname,\bgroup,\egroup}
% \DoNotIndex{\expandafter,\@@comp,\@postcode}
% \DoNotIndex{\psset}
% \DoNotIndex{\@wd,\@sz,\@ht,\@yshift,\@step,\@xl,\@sep,\@r,\@dp,\@altan,\@extpostcode}
% \DoNotIndex{\@f@cnt,\@f@r,\@f@sep,\@hshift,\@bs@wd,\@c@caxisL,\@cnt,\@pstfalse,\@psttrue}
% \DoNotIndex{\@th,\@rL,\@rR,\i,\long,\optexp@nodeA,\optexp@nodeB}
% \DoNotIndex{\POE@temp,\POE@tempa,\POE@tempb,\POE@tempc,\POE@tempd}
% \DoNotIndex{\POE@getref@b,\POE@getref@c,\POE@getref@l,\POE@getref@r,\POE@getref@t}
% \DoNotIndex{\the,\toks@}
% 
% \newif\ifGERMAN  \GERMANfalse
% \newif\ifENGLISH \ENGLISHfalse
% \iflanguage{ngerman}{\GERMANtrue}{%
%   \iflanguage{german}{\GERMANtrue}{\GERMANfalse}}
% \iflanguage{english}{\ENGLISHtrue}{\ENGLISHfalse}
%
% \ifGERMAN
%   \newrefformat{sec}{Kap.\,\ref{#1}}
%   \newrefformat{l}{Zeile\,\ref{#1}}
%   \newindex[Quelltextindex]{idx}
%   \newindex[Dokumentationsindex]{doc}
%   \newcommand{\POEindexPackage}{Paket}
%   \newcommand{\POEindexMacro}{Makro}
%   \newcommand{\POEindexKeyword}{Schlüsselwort}
%   \newcommand{\POEindexOption}{Option}
%   \newcommand{\POEindexStyle}{Stil}
%   \newcommand{\POEindexDipoles}{Zweipol}
%   \newcommand{\POEindexTripoles}{Dreipol}
%   \newcommand{\POEindexFiberDipoles}{Faserzweipol}
%   \newcommand{\POEindexFiberMultipoles}{Fasermultipol}
% \fi
% \ifENGLISH
%   \newrefformat{sec}{Sec.~\ref{#1}} 
%   \newrefformat{l}{Line~\ref{#1}}
%   \newindex[Code index]{idx}
%   \newindex[Documentation index]{doc}
%   \newcommand{\POEindexPackage}{Package}
%   \newcommand{\POEindexMacro}{Macro}
%   \newcommand{\POEindexKeyword}{Keyword}
%   \newcommand{\POEindexOption}{Option} 
%   \newcommand{\POEindexStyle}{Style}
%   \newcommand{\POEindexDipoles}{Dipoles}
%   \newcommand{\POEindexTripoles}{Tripoles}
%   \newcommand{\POEindexFiberDipoles}{Fiber dipoles}
%   \newcommand{\POEindexFiberMultipoles}{Fiber multipoles}
% \fi
%
% \newcommand*{\sizeexplanation}[2][1.6]{% 
%   \ifGERMAN 
%     Die Höhe #2, die Breite ist \opt{#1} mal die Höhe. Mit
%     dem \opt{xunit} oder \opt{yunit} Parameter kann dieses Verhältnis
%     geändert werden.
%   \fi
%   \ifENGLISH
%     The height of the #2, the width is \opt{#1} times the
%     height. Use the \opt{xunit} or \opt{yunit} parameter to change this
%     relation.
%   \fi
% }%
% \newcommand{\refstringexplanation}{%
%   \ifGERMAN
%   Analog zum Referenzpunkt von \nxLcs{rput}, kann jede Kombination von
%   \opt{c} (mittig), \opt{t} (oben), \opt{b} (unten), \opt{l} (links) und
%   \opt{r} (rechts) sein.
%   \fi
%   \ifENGLISH
%   Like the reference point of \nxLcs{rput}, can be any comination of
%   \opt{c} (center), \opt{t} (top), \opt{b} (bottom), \opt{l} (left), and
%   \opt{r} (right).
%   \fi}
%
% \newcommand*{\linewidthexplanation}[2]{% 
% \ifGERMAN
% Die Linienbreite #1. Diese könnte ebenfalls über den
% \opt{linewidth} Parameter gesetzt werden. Mit diesem Parameter kann
% aber die Linienbreite aller #2 global eingestellt werden.
% \fi
% \ifENGLISH
% The linewidth of the #1. This could be defined also with the
% generic \opt{linewidth} option. But this parameter allows setting
% globally the linewidth of all #2.
% \fi
% }%
%
% \makeatletter
% \renewcommand\maketitle{%
% \thispagestyle{empty}%
% \begin{titlepage}
% \begin{pspicture}(1.6in,0.685in)(10,21.7)
%   \psframe[fillstyle=solid,linecolor=lightgray,fillcolor=lightgray,linestyle=solid](0,-5.75)(21.5,10)
%   \psframe[fillstyle=solid,linecolor=Orange!85!Red,fillcolor=Orange!85!Red,linestyle=solid](0,10)(21.5,10.5)
%   \psframe[fillstyle=solid,linecolor=Orange!85!Red,fillcolor=Orange!85!Red,linestyle=solid](0,21.1)(21.5,21.2)
%   \rput[lb](3,22){\Huge\sffamily\color{Orange!65!Red}\psscalebox{2}{\textbf{PSTricks}}}
%   \rput[lb](3,14.1){\parbox{15cm}{\sffamily\RaggedRight\bfseries\huge\@title}}
%   \rput[lb](3,7.6){\parbox{13cm}{\sffamily\@date}}
%   \rput[lb](3,-2.6){\parbox[b]{17cm}{\sffamily\RaggedRight 
%     ~\hfill\makebox[7cm][l]{\ifGERMAN Paketautor:\fi\ifENGLISH Package author:\fi}\\
%     ~\hfill\makebox[7cm][l]{%
%       \bfseries\tabular[t]{@{}l@{}}\@author\endtabular}}}
%  \rput[C](11,4){\bgImage}%
%  \end{pspicture}%
% \end{titlepage}}
% \makeatother
% 
% \ifGERMAN
%   \title{\texttt{pst-optexp}\\ Optische Versuchsaufbauten\\[0.5ex] \small \fileversion}
% \fi
% \ifENGLISH
%   \title{\texttt{pst-optexp}\\ Drawing optical experimental setups\\[0.5ex] \small \fileversion}
% \fi
% \author{Christoph Bersch}
% \date{\filedate}
% \def\bgImage{\psset{unit=1.3}
% \begin{pspicture}[showgrid=false](-0.2,0.1)(8.2,5.3)
%   \pnode(0,3){M1}
%   \pnode(8,3){M2}
%   \pnode(8,0.5){In}
%   \pnode(6.5,0.5){Min}
%   \pnode(6.5,3){Pin}
%   \pnode(4.5,3){Min2}
%   \pnode(1.5, 0.5){Mout}
%   \pnode(1.5,3){Pout}
%   \pnode(3.5,3){Mout2}
%   \pnode(0,0.5){Out}
%   \definecolor[ps]{bl}{rgb}{tx@addDict begin Red Green Blue end}%
%   \addtopsstyle{Beam}{linecolor=bl, linejoin=1}
%   \psset{mirrortype=extended, mirrordepth=0.15}
%   \newpsstyle{ExtendedMirror}{linestyle=none, hatchwidth=0.5\pslinewidth, hatchsep=1.2\pslinewidth,%
%                 fillstyle=hlines}%
%   \begin{optexp}
%   \mirror[mirrorwidth=4, mirrorradius=10.4](M2)(M1)(M2){}
%   \mirror[mirrorwidth=4, mirrorradius=10.4](M1)(M2)(M1){}
%   \mirror(In)(Min)(Pin){}
%   \optprism[n=1.85, addtoOptComp={linewidth=1.5\pslinewidth}](Min)(Pin)(Min2){}
%   \mirror[compshift=-0.4](Pin)(Min2)(Pin){}
%   \mirror[compshift=0.4](Pout)(Mout2)(Pout){}
%   \optprism[n=1.85, compshift=0.15, linewidth=1.5\pslinewidth](Mout2)(Pout)(Mout){}
%   \mirror(Pout)(Mout)(Out){}
%  \multido{\i=0+1}{40}{%
%    \pstVerb{%
%       \i\space 650 400 sub 39 div mul 400 add 
%       tx@addDict begin wavelengthToRGB end }%
%     \drawbeam[nadd=-0.002 \i\space mul]{(In)}{3-5}{2}{1}{6-8}{(Out)}
%  }%
%   \newpsstyle{Beam}{linecolor=red}
%   \backlayer{%
%     \psline[style=Beam,ArrowInside=->, linewidth=2\pslinewidth, arrowinset=0](In)(\oenodeIn{3})(\oenodeOut{4})
%   }
%   \drawbeam[beamangle=0.29,beampos=0.1, arrows=<-, linewidth=2\pslinewidth, arrowinset=0]{([Xnodesep=-0.2]Out)}{8}{7}
% \end{optexp}
% \rput(4,4.5){%
%   \psframe[fillstyle=solid,fillcolor=gray!70](-0.1, -0.6)(0.1, 0.7)
%   \multido{\r=-0.5+0.1}{12}{%
%     \psline[linewidth=0.5\pslinewidth](-0.1,\r)(0.1,\r)
%   }%
% }%
% \end{pspicture}}
%
% \maketitle
% 
% \clearpage
% \tableofcontents
% \clearpage
% 
% \ifGERMAN
%   \chapter{Einführung}
% \fi
% \ifENGLISH
%   \chapter{Introduction}
% \fi
%
% \ifGERMAN
%   \section{Über das Paket}
%   \LPack{pst-optexp} ist ein PSTricks-Paket zum Skizzieren optischer
%   Versuchsaufbauten. Dafür werden viele unterschiedliche Freistrahl- und
%   Faseroptische Komponenten bereitgestellt.
% \fi 
% \ifENGLISH
%   \section{About the package}
%   The package \LPack{pst-optexp} is a collection of optical components
%   that facilitate easy sketching of optical experimental
%   setups. Mechanisms for proper alignment of different components are
%   provided internally. This way the user does not have to care for proper
%   orientation of the elements. Macros for convenient definition of new 
%   user-defined components are also provided.
% \fi
%
% \ifGERMAN
%   \section{Anforderungen}
%   \LPack{pst-optexp} Version 3.0 benötigt \LaTeX{} und aktuelle Versionen der
%   Pakete \LPack{pst-node}, \LPack{pstricks-add}, \LPack{multido},
%   \LPack{pst-eucl} und \LPack{environ}.
%
%   Alle PSTricks-Pakete machen regen Gebrauch von Postscript, so dass der
%   typische Arbeitsfluss \opt{latex}, \opt{dvips} und ggf. \opt{ps2pdf}
%   umfasst. Es gibt viele alternative Methoden um die Dokumente zu
%   kompilieren.\fnurl{http://tug.org/PSTricks/main.cgi?file=pdf/pdfoutput}
% \fi
% \ifENGLISH
%   \section{Requirements}
%   \LPack{pst-optexp} version 3.0 requires \LaTeX{} and recent versions of
%   \LPack{pst-node}, \LPack{pstricks-add}, \LPack{multido},
%   \LPack{pst-eucl}, and \LPack{environ}. 
%
%   All PSTricks package heavily rely on the Postscript language so that the
%   typical workflow involves \opt{latex}, \opt{dvips}, and \opt{ps2pdf}. Of
%   course there are several alternative ways to compile your
%   documents.\fnurl{http://tug.org/PSTricks/main.cgi?file=pdf/pdfoutput} 
% \fi
%
% \ifGERMAN
%   \section{Verbreitung und Installation}
%   Dieses Paket ist auf
%   CTAN\fnurl{http://mirror.ctan.org/graphics/pstricks/contrib/pst-optexp}
%   erhältlich und in \TeX Live and MiK\TeX{} enthalten.
% 
%   Das \LPack{pst-optexp} Paket umfasst die zwei Hauptdateien
%   \texttt{pst-optexp.ins} und \texttt{pst-optexp.dtx}. Durch Aufrufen
%   von \texttt{latex pst-optexp.ins} werden die beiden folgenden
%   Dateien erzeugt:
%   \begin{itemize}
%   \item \texttt{pst-optexp.pro}: die Postscript Prologdatei
%   \item \texttt{pst-optexp.sty}: die \LaTeX{} Stildatei
%   \end{itemize}
%   Speichern Sie diese Dateien in einem Verzeichnis der Teil Ihres
%   lokalen \TeX-Baums ist.
% 
%   Vergessen Sie nicht \texttt{texhash} aufzurufen um den Baum zu
%   aktualisieren. MiK\TeX{}-Benutzer müssen die Dateinamen-Datenbank
%   (FNDB) aktualisieren.
% 
%   Detailliertere Information finden Sie in der Dokumentation Ihrer
%   \LaTeX-Distribution über die Installation in den lokalen
%   \TeX{}-Baum.
% \fi
% \ifENGLISH
%   \section{Distribution and installation}
%   This package is available on
%   CTAN\fnurl{http://mirror.ctan.org/graphics/pstricks/contrib/pst-optexp} and
%   is included in \TeX Live and MiK\TeX.
% 
%   The \LPack{pst-optexp} package consists of the two main files
%   \texttt{pst-optexp.ins} and \texttt{pst-optexp.dtx}.
%   \begin{itemize}
%   \item \texttt{pst-optexp.pro}: the Postscript prolog file
%   \item \texttt{pst-optexp.sty}: the \LaTeX{} style file
%   \end{itemize}
%   Save the files in a directory which is part of your local \TeX{} tree.
% 
%   Do not forget to run \texttt{texhash} to update this tree. For MiK\TeX{}
%   users, do not forget to update the file name database (FNDB).
% 
%   For more detailed information see the documentation of your personal
%   \LaTeX{} distribution on installing packages to your local \TeX{}
%   system.
% \fi
%
% \ifGERMAN\section{Lizenz}\fi
% \ifENGLISH\section{License}\fi
% \ifGERMAN
% Es wird die Erlaubnis gewährt, dieses Dokument zu kopieren, zu verteilen
% und\slash oder zu modifizieren, unter den Bestimmungen der \LaTeX{} Project
% Public License, version
% 1.3.\fnurl{http://www.ctan.org/tex-archive/macros/latex/base/lppl.txt}. Diese
% Paket wird vom Autor betreut (author-maintained).
% \fi
% \ifENGLISH
% Copyright \textcopyright\ 2007--2011 Christoph Bersch. Permission is granted
% to copy, distribute and\slash or modify this software under the terms of the
% \LaTeX{} Project Public License, version
% 1.3.\fnurl{http://www.ctan.org/tex-archive/macros/latex/base/lppl.txt} This
% package is author-maintained.
% \fi
%
% \ifGERMAN
%   \section{Abwärtskompatibilität}
% \fi
% \ifENGLISH
%   \section{Backward compatibility}
% \fi 
% \ifGERMAN Version 3.0 hat erhebliche fortgeschrittenere
%   Funktionalität hinzugefügt, die es zu schwierig machte zur
%   Vorgängerversion 2.1 vollständig abwärtskompatibel zu
%   bleiben. Insbesondere war die Funktionsweise des \Lcs{drawbeam}
%   Makros grundlegend falsch konzipiert, so dass ein Wechsel zur neuen
%   Funktionalität so schnell wie möglich erfolgen musste.
%
% \begin{optionlist}
%   \optitem[new]{namingscheme}{old, new} In Version 2.x musste
%   spezielle Komponentenknoten über ihren expliziten Namen angesprochen
%   werden. Wenn Sie nur das alte Namensschema benötigen, da Sie direkt
%   auf die Knoten zugegriffen haben, so genügt es
%   \nxLkeyword{namingscheme=old} zu verwenden, die Paketoption
%   \nxLoption{compat} wird dann nicht benötigt. Seit Version 3.0 werden
%   Makros für den Zugriff auf die Komponentenknoten bereitgestellt, so
%   dass das eigentlichen Namensschema unerheblich ist.
% \end{optionlist}
% \fi
% \ifENGLISH
% Version 3.0 introduced a lot of advanced features which made it too
% difficult to maintain full backward compatibility with version
% 2.x. Especially the \Lcs{drawbeam} macro was broken by design, so that
% it was best to drop the old flaw as early as possible.
%
% \begin{optionlist}
%   \optitem[new]{namingscheme}{old, new} In version 2.x special
%   component nodes had to be accessed by their explicit name. If you
%   only need the old naming scheme, because you accessed internal nodes
%   directly, then you can only set \nxLkeyword{namingscheme=old} and do
%   not need to use the \nxLoption{compat} option. Since version 3.0
%   explicit macros are provided to access all special component nodes,
%   so that the actual naming scheme does not matter.
% \end{optionlist}
% \fi
% 
% \ifGERMAN
%   \section{Danksagung}
% \fi
% \ifENGLISH
%   \section{Acknowledgements}
% \fi
% \ifGERMAN\fi
% \ifENGLISH
% I thank all the people of the PSTricks mailinglist for the continuous help,
% especially Herbert Vo\ss. Thanks also to Christine Römer, which convinced my
% with her article in the german DTK to provide a german translation of the
% documentation, and Philipp Lehman, whose documentation style of the biblatex
% package is wonderful.
% \fi
%
% \ifGERMAN
%   \chapter{Grundlegende Ideen}
%   Dieses Kapitel zeigt die grundlegenden Ideen, die in diesem Paket
%   stecken. Angefangen von elementaren Beispielen, bis hin zu größeren
%   Aufbauten wird die angedachte Vorgehensweise für das Erstellen von
%   umfassenden Experimentskizzen erläutert. Eine vollständige Referenz aller
%   Macros und Optionen finden Sie in 
%   \prettyref{sec:general}--\ref{sec:connecting}.
% \fi
% \ifENGLISH
%   \chapter{Basic ideas}
% \fi
%
% \ifGERMAN
% \section{Konzeptionsüberblick}
% \fi
% \ifENGLISH
% \section{Concept overview}
% \fi
%
% \ifGERMAN
%   \subsection{Die Komponenten}
%   Ein Versuchsaufbau besteht aus Komponenten, die miteinander verbunden
%   werden. Eine Komponente wird anhand ihrer Referenzknoten platziert, im
%   folgenden Beispiel wird die Linse mittig auf die Verbindungslinie zwischen
%   den Knoten \texttt{(A)} und \texttt{(B)} gesetzt:
%\iffalse
%<*ignore>
%\fi
\begin{LTXexample}
\begin{pspicture}[showgrid=true](3,2)
  \pnode(0,1){A}\pnode(3,1){B}
  \lens(A)(B)
\end{pspicture}
\end{LTXexample}
%\iffalse
%</ignore>
%\fi 
%
% Diese Positionierung kann anhand von unterschiedlichen Parametern, wie
% z.B. \Lkeyword{abspos} beinflusst werden (siehe dazu \prettyref{sec:rotshift}
% und \prettyref{sec:positioning}).
%\iffalse
%<*ignore>
%\fi
\begin{LTXexample}
\begin{pspicture}[showgrid=true](3,2)
  \pnode(0,1){A}\pnode(3,1){B}
  \lens[abspos=0.5](A)(B)
\end{pspicture}
\end{LTXexample}
%\iffalse
%</ignore>
%\fi 
%
% Die Komponenten lassen sich allgemein in zwei Kategorien unterteilen: Die Freistrahl-Komponenten und die faseroptischen Komponenten. Diese unterscheiden sich nur bezüglich ihrer Verbindungsmöglichkeiten (Faserverbindungen (\prettyref{sec:intro-fiber-conn}) oder Lichtstrahlen (\prettyref{sec:intro-freeray-conn})).
% \fi
% \ifENGLISH
%   \subsection{The components}
% \fi
%
% \ifGERMAN
%   \subsection{Beschriftungen}
%   Jede Komponente hat eine optionale Beschriftung, die relativ zur Komponente platziert werden kann.
%\iffalse
%<*ignore>
%\fi
\begin{LTXexample}
\begin{pspicture}[showgrid=true](3,2)
  \pnode(0,1){A}\pnode(1,1){B}
  \lens(A)(B){lens}
  \optbox[endbox, labeloffset=0](B)(A){box}
\end{pspicture}
\end{LTXexample}
%\iffalse
%</ignore>
%\fi 
% \fi
% \ifENGLISH
%   \subsection{Labels}
% \fi
%
% \ifGERMAN
%   \subsection{Freistrahl-Verbindungen}
% \fi
% \ifENGLISH
%   \subsection{Freeray connections}
% \fi \label{sec:intro-freeray-conn}
% \ifGERMAN
% Freistrahlkomponenten können mit Lichtstrahlen verbunden werden. 
% \fi
%
% \ifGERMAN
%   \subsection{Faserverbindungen}
% \fi
% \ifENGLISH
%   \subsection{Fiber connections}
% \fi \label{sec:intro-fiber-conn}
%
% \ifGERMAN
%   \section{Schritt-für-Schritt-Beispiele}
% \fi
% \ifENGLISH
%   \section{Step-by-step examples}
% \fi
%
% \iffalse
%<*ignore>
% \fi
% \begingroup
% \catcode`\*=13
% \def*{}%
\psset{unit=1.5}
\begin{LTXexample}[pos=t, vsep=10mm, numbers=left, numberstyle=\footnotesize]
\begin{pspicture}(0,-0.3)(5,2.3)
  \pnode(0,1){In}\pnode(3.5,1){Out}*\label{l:ex1-nodes}*
  \lens[lensradius=-0.7, lenswidth=0.1, abspos=1](In)(Out){concave}*\label{l:ex1-l1}*
  \lens[lensradius=2.3, lensheight=1.3, abspos=2.6](In)(Out){convex}*\label{l:ex1-l2}*
  \optbox[endbox, labeloffset=0](In)(Out){CCD}*\label{l:ex1-box}*
  \newpsstyle{Beam}{linecolor=green, fillstyle=solid, fillcolor=green, opacity=0.2}*\label{l:ex1-style}*
  \drawwidebeam[beamwidth=0.2]{(In)}{1}{2}{3}*\label{l:ex1-beam}*
\end{pspicture}
\end{LTXexample}
% \endgroup
% \iffalse
%</ignore>
% \fi 
% \ifGERMAN 
% Im diesem ersten Beispiel wird das automatische
% Raytracing durch unterschiedliche Linsen gezeigt. 
%
% In \prettyref{l:ex1-nodes} werden die beiden Referenzknoten definiert,
% anhand derer die Komponenten positioniert werden. Die beiden Linsen
% (\prettyref{l:ex1-l1}--\ref{l:ex1-l2}) werden absolut positioniert,
% der Parameter \Lkeyword{abspos} gibt den Abstand vom ersten Referenzknoten
% \prm{in} an. Ein negative Linsenradius \Lkeyword{lensradius} ergibt eine
% konkave Linse (\prettyref{l:ex1-l1}), ein positiver Linsenradius eine
% konvexe Linse (\prettyref{l:ex1-l2}). Die dritte Komponente ist eine
% Box (\prettyref{l:ex1-box}), deren eine Seite mit der Option
% \Lkeyword{endbox} auf den Referenzknoten \prm{out} gelegt wird. Die
% Beschriftung wird mittig in die Box gesetzt
% (\opt{labeloffset=0}). Zuletzt wird ein grüner Lichtstrahl gezeichnet
% (\prettyref{l:ex1-beam}), dessen Füllung etwas transparent ist
% (\prettyref{l:ex1-style}). Die Anfangsbreite des Strahls wird mit dem
% Parameter \Lkeyword{beamwidth} vorgegeben, der weitere Strahlverlauf wird nur
% durch die optischen Eigenschaften der Linsen bestimmt.
% \fi
% \ifENGLISH\fi
%
% \begingroup
% \catcode`\*=13
% \def*{}%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[hsep=8mm, numbers=left, numberstyle=\footnotesize]
\begin{pspicture}(3.2,5)
  \pnode(0,3){In}\pnode(1,3){BS}\pnode(3,3){M1}*\label{l:ex2-nodes1}*
  \pnode(1,5){M2}\pnode(1,1){PD}*\label{l:ex2-nodes2}*
  \psset{mirrortype=extended, mirrordepth=0.2, bsstyle=plate, dettype=diode}*\label{l:ex2-set}*
  \begin{optexp}*\label{l:ex2-begin}*
    \beamsplitter[compname=BS](In)(BS)(PD)*\label{l:ex2-bs}*
    \mirror[compname=M1](BS)(M1)(BS)*\label{l:ex2-m1}*
    \mirror[compname=M2, variable](BS)(M2)(BS)*\label{l:ex2-m2}*
    \lens[compname=L](BS)(PD)*\label{l:ex2-l}*
    \optdetector[compname=Det](BS)(PD)*\label{l:ex2-det}*
    \addtopsstyle{Beam}{fillstyle=solid, fillcolor=green!20!white, beamwidth=0.2}*\label{l:ex2-style}*
    \drawwidebeam{(In)}{BS}{M1}{BS}{M2}{BS}{L}{Det}*\label{l:ex2-beam}*
  \end{optexp}
\end{pspicture}
\end{LTXexample}
% \endgroup
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% In dem zweiten Beispiel werden neben Linsen auch reflektierende
% Elemente (Spiegel) sowie Elemente eingesetzt, die sowohl
% transmittieren als auch reflektieren (Strahlteiler).
%
% Wir beginnen wieder indem wir die Referenzknoten definieren
% (\prettyref{l:ex2-nodes1}--\ref{l:ex2-nodes2}). Nun werden ein paar
% Einstellungen gesetzt (\prettyref{l:ex2-set}): das Aussehen der
% Spiegel, des Strahlteilers und des Detektors. Nun werden der Reihe
% nach alle Komponenten platziert, die reflektierenden benötigen drei
% Referenzknoten, den Eingangsknoten, den Knoten an dem die
% reflektierende Grenzfläche ist und den Ausgangsknoten. Nun wird noch
% das Aussehen des Lichtstrahls definiert (\prettyref{l:ex2-style}) und
% der Strahl gezeichnet (\prettyref{l:ex2-beam}). 
%
% Diese Mal haben wir den Komponenten Namen gegeben (\Lkeyword{compname}) die
% beim Raytracing anstatt der automatisch vergebenen Nummern verwendet
% werden können. Dies erleichtert die Nachverfolgung des Strahlenganges.
% 
% Alle Komponenten und Strahlen wurden zusätzlich in eine
% \Lkeyword{optexp}-Umgebung gekapselt. Innerhalb dieser werden alle
% Lichtstrahlen hinter die Komponenten gelegt, sodass diese nicht
% verdeckt werden.
% \fi
% \ifENGLISH\fi
%
% \iffalse
%<*ignore>
% \fi
% \begingroup
% \catcode`\*=13
% \def*{}%
\begin{LTXexample}[pos=t, vsep=10mm, numbers=left, numberstyle=\footnotesize]
\begin{pspicture}(-0.2,-0.3)(7.7,2.4)
  \pnode(1,1){Laser}\pnode(3,1){PcOut}*\label{l:ex3-nodes1}*
  \pnode(4.5,1){MzmOut}\pnode(6.5,1){Osa}
  \pnode([offset=1]Osa){Pd}*\label{l:ex3-nodes2}*
  \psset{optboxwidth=1.2, usefiberstyle}*\label{l:ex3-set}*
  \optbox[endbox, labeloffset=0](Osa)(Laser){Laser}*\label{l:ex3-laser}*
  \polcontrol(Laser)(PcOut){PC}*\label{l:ex3-pc}*
  \optmzm(PcOut)(MzmOut){MZM}*\label{l:ex3-mzm}*
  \wdmsplitter[align=bottom](MzmOut)(Pd)(Osa){99/1}*\label{l:ex3-cpl}*
  \optdetector[dettype=diode]([Xnodesep=-0.1]Pd)(Pd)*\label{l:ex3-det}*
  \optbox[endbox, labeloffset=0](Laser)(Osa){OSA}*\label{l:ex3-osa}*
\end{pspicture}
\end{LTXexample}
% \endgroup
% \iffalse
%</ignore>
% \fi
% 
% \ifGERMAN
% Das dritte Beispiel zeigt eine einfache Skizze mit faseroptischen Komponenten.
%
% Bezüglich der Positionierung verhalten diese sich identisch zu den
% vorher gezeigten Freistrahl-Komponenten, aber die Verbindung mit
% «Fasern» wird anders gehandhabt. Üblicherweise werden die Komponenten
% direkt mit den verwendeten Referenzknoten verbunden. 
%
% Die Referenzknoten werden in
% \prettyref{l:ex3-nodes1}--\ref{l:ex3-nodes2} definiert, anschließend
% allgemeine Einstellungen festgelegt (\prettyref{l:ex3-set}).
% \fi
% \ifENGLISH\fi
%
% \iffalse
%<*ignore>
% \fi
% \begingroup
% \catcode`\*=13
% \def*{}%
\begin{LTXexample}[numbers=left, numberstyle=\footnotesize]
\begin{pspicture}(0.5,0)(2.2,4)
  \pnode(0,1){In}\pnode(1,1){BS}\pnode(2,1){G}\pnode(1,4){Out}
  \beamsplitter(G)(BS)(Out)
  \optgrating(BS)(G)(BS)
  \lens[lens=2 2 1.5, compshift=0.1, n=2.25](BS)(Out)
  \pinhole[phwidth=0.05, innerheight=0.05, position=0.8, compshift=0.18](BS)(Out)
  \optplane(Out)(1, 0){Out}
  \addtopsstyle{Beam}{linestyle=none, beamwidth=0.2, fillstyle=solid}
  \drawwidebeam[fillcolor=red!25!white]{(In)}{1}{2}{1}{3}{4}
  \drawwidebeam[fillcolor=red!50!white, beamangle=-5]{2}{1}{3}{4}{Out}
\end{pspicture}
\end{LTXexample}
% \endgroup
% \iffalse
%</ignore>
% \fi
% 
% \chapter{Concept and general behavior}\label{sec:general}
% 
% This section introduces into the basic concepts of the package design and
% explains the parameters and commands which are supported by most optical
% objects.
% 
% \subsection{Concept}
% 
% The objects provided by \LPack{pst-optexp} can be differentiated into
% two different categories: free-ray and fiber-optical objects.
% 
% The free-ray units are subdivided in two different kinds: dipoles which
% require two reference points for alignment and do not alter the
% direction of passing light beams (e.g. lenses and retardation plates)
% and tripoles which work in reflection and require three reference points
% (mirrors, gratings, beamsplitters etc.).
% 
% For free-ray setups one usually has a few straight light paths in which
% several different objects are to be arranged. In this case it is very
% convenient to define only two nodes for each light path. The objects are
% placed on this light path using the different positioning parameters
% (see \prettyref{sec:positioning}) of the package. After having arranged
% everything, the beams themselves are drawn (see \prettyref{sec:connecting}).
% 
% The fiber-optical objects can be classified as dipoles, tripoles and quadrupoles
% which have a corresponding number of fiber connections. Their handling differs
% in some aspects from the free-ray objects. The fiber optics are directly
% connected to the reference nodes. Every input and output fiber can be flexibly
% customized for each object (see \prettyref{sec:styles}). Positioning of the
% fiber dipoles is handled equivalently to the free-ray dipoles. Tripoles and
% quadrupoles can be found only as different coupler types. Their positioning
% mechanisms are a bit more involved and explained in the respective section
% (\prettyref{sec:coupler}).
% 
% Some hybrid dipoles (optbox, detector etc.) can be used both as
% fiber-optical or free-ray elements. 
% 
% \subsection{Using psstyles}\label{sec:styles}
%
% \subsection{Object names}\label{sec:namingobj}
% All objects of a \nxLPack{pst-optexp} sketch are numbered
% automatically in increasing order by their definition in the code. The
% objects as well as their special nodes can be accessed via this
% number.
% 
% \begin{optionlist}
%   \valitem{compname}{string} Assigns a name to an object, which can
%   then be referenced both by this name and by its number. The
%   parameter can be assigned only directly within a
%   \nxLPack{pst-optexp} object and should be unique within one
%   \nxLkeyword{pspicture} environment.
% \iffalse
%<*ignore>
% \fi
\ifGERMAN
\begin{LTXexample}
\begin{pspicture}(2,2)
  \optbox[compname=MyBox](0,1)(2,2)
  \psdot[linecolor=red](\oenodeIn{MyBox}) % Verwende den Namen
  \psdot[linecolor=blue](\oenodeOut{1})   % Verwende die Nummer
  \psdot[linecolor=green](\oenodeCenter{})% Nimm die letzte Komponente
\end{pspicture}
\end{LTXexample}
\fi\ifENGLISH
\begin{LTXexample}
\begin{pspicture}(2,2)
  \optbox[compname=MyBox](0,1)(2,2)
  \psdot[linecolor=red](\oenodeIn{MyBox})% use the compname
  \psdot[linecolor=blue](\oenodeOut{1})  % use the number
  \psdot[linecolor=green](\oenodeCenter{})  % the last component
\end{pspicture}
\end{LTXexample}
\fi
% \end{optionlist}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% \subsection{Spezielle Komponentenknoten}
% \fi
% \ifENGLISH
% \subsection{Special component nodes}
% \fi\label{sec:objnodes}
% 
% \ifGERMAN
% Jedes \nxLPack{pst-optexp} Objekt stellt mehrere spezielle Knoten zur
% Verfügung, die mit dessen Geometrie und Positionierung zusammenhängen. Diese
% Knoten stehen für weitere Verwendung zur Verfügung.
%
% Sie sollten immer die dafür vorgesehenen Makros verwenden um auf die
% Knotennamen zuzugreifen.
% \fi
% \ifENGLISH
% Every \nxLPack{pst-optexp} object of an experimental setup provides
% several special nodes which are related to its geometry and
% positioning. They can be accessed and used for related positioning and
% drawing.
%
% You should always use the dedicated macros to access these node names.
% \fi
% \begin{ltxsyntax}
%   \cmditem{oenode}{node}{name} 
%
% \ifGERMAN
% Das ist das grundlegende Makro mit dem auf die Knotennamen einer Komponente
% zugegriffen werden kann. Das erste Argument \prm{node} ist der Bezeichner des
% angeforderten Knotens. Das zweite Argument \prm{name} ist der Name der
% Komponente (gemäß \prettyref{sec:namingobj}). Ist dieses leer so wird das
% zuletzt definierte Objekt verwendet.
%
% Für viele der Knoten wird ein eigenes Makro bereitgestellt, das Sie dann auch
% verwenden sollten, da sich die Namenskonventionen ändern könnten. Die Makros
% stellen sicher, dass Sie immer die passenden Knotennamen erhalten. Daher sind
% die verfügbaren Bezeichner auch nicht aufgelistet.
% \fi
% \ifENGLISH
% This is the basic command to access any node associated with a certain
% object. The first argument \prm{node} is the identifier of the requested
% node. The second argument \prm{name} is the name of the target object
% (according to \prettyref{sec:namingobj}). If it is left empty, the last
% defined component is used.
%
% For most special nodes an appropriate macro is provided, which you are
% strongly advised to use, because the naming conventions may change. Using the
% macros makes sure, that you always get the correct node names. Therefore, the
% available identifiers are not listed explicitely.
% \fi
% \end{ltxsyntax}
%
% \begin{optionlist}
%   \boolitem[false]{showoptdots} 
%   \ifGERMAN 
%   Markiert einige der speziellen Komponentenknoten: die schwarzen Punkte sind
%   die normalen und die schwarzen Kreuze die transformierten Referenzknoten
%   (\prettyref{sec:refnode}), der rote Punkt ist der Mittelpunktknoten
%   (\prettyref{sec:centernode}) und das rote Kreuz der Beschriftungsknoten
%   (\prettyref{sec:labelnode}).
%   \fi
%   \ifENGLISH 
%   Draw some special component nodes for debugging: The black points are the
%   normal and the black crosses are the transformed reference nodes
%   (\prettyref{sec:refnode}), the red point is the center node
%   (\prettyref{sec:centernode}), and the red cross is the label node
%   (\prettyref{sec:labelnode}).
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
\mirror[showoptdots, angle=10, beam](0,1)(1.9,1)(1.9,0)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsubsection{Referenzknoten}\fi
% \ifENGLISH\subsubsection{Reference nodes}\fi
% \label{sec:refnode}
%
% \begin{ltxsyntax}
%   \cmditem{oenodeRefA}{obj}
%   \cmditem{oenodeRefB}{obj}
%
%  \ifGERMAN
%  Die Eingangs- und Ausgangs-Referenzknoten.
%
%  Das sind die ursprünglichen Knoten, die für die Positionierung der Komponente
%  benutzt wurden, \nxLcs{oenodeRefA} ist der erste und \nxLcs{oenodeRefB} der
%  letzte Knoten. Lediglich bei den Faserkoppler (\prettyref{sec:coupler}) hängt
%  die Zuordnung von dem \Lkeyword{align} Parameter ab.
%  Eine vollständige Liste finden Sie in \prettyref{sec:overview-refnode}.
%  \fi
%  \ifENGLISH
%  The input and output reference nodes.
%
%  These are the original nodes which were used for the component positioning.
%  \nxLcs{oenodeRefA} is the first node and \nxLcs{oenodeRefB} the last
%  node. Only for the couplers (\prettyref{sec:coupler}) it depends on the
%  \Lkeyword{align} parameter. For a complete list of possible reference nodes, see
%  \prettyref{sec:overview-refnode}.
%  \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, linerange={1-5, 7-7}]
\begin{pspicture}(5,1)
\pnode(0.5,0.5){A}\pnode(4.5,0.5){B}
\optbox(A)(B)
\psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
\psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
\psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%   \cmditem{oenodeTrefA}{obj}
%   \cmditem{oenodeTrefB}{obj}
%
%   \ifGERMAN
%   Die transformierten Eingangs- und Ausgangs-Referenzknoten.
%
%   Das sind die Referenzknoten nachdem sie zusammen mit der Komponente gemäß
%   der \Lkeyword{compshift} und \Lkeyword{angle} Parameter transformiert wurden.
%   \fi
%   \ifENGLISH
%   The transformed input and output reference nodes.
%
%   These are the input and output reference nodes which are transformed
%   together with the component according to the \Lkeyword{compshift} and
%   \Lkeyword{angle} parameters.
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, linerange={1-7,9-9}]
\begin{pspicture}(5,1.8)
\pnode(0.5,0.5){A}\pnode(4.5,0.5){B}
\optbox[compshift=0.5, angle=10](A)(B)
\psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
\psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
\psdot(\oenodeTrefA{})\uput[90](\oenodeTrefA{}){TrefA}
\psdot(\oenodeTrefB{})\uput[90](\oenodeTrefB{}){TrefB}
\psline[style=Refline](\oenodeTrefA{})(\oenodeTrefB{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
%
% \ifGERMAN
% \subsubsection{Mittelpunktknoten}
% \fi
% \ifENGLISH
% \subsubsection{Center node}
% \fi\label{sec:centernode}
% \begin{ltxsyntax}
%   \cmditem{oenodeCenter}{obj}
% 
% \ifGERMAN
% Dieser Knoten liegt, bis auf wenige Ausnahmen, im Mittelpunkt der Komponente.
% \fi
% \ifENGLISH
% This node lays, except for a few components, in the center of the component.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-4, 6-6}]
\begin{pspicture}(3,1)
\pnode(0,0.5){A}\pnode(3,0.5){B}
\optbox(A)(B)
\psdot(\oenodeCenter{})
\psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \ifGERMAN
% \subsubsection{Beschriftungsknoten}
% \fi
% \ifENGLISH
% \subsubsection{Label node}
% \fi\label{sec:labelnode}
%
% \begin{ltxsyntax}
%   \cmditem{oenodeLabel}{obj}
%
%   \ifGERMAN
%   Auf diesen Knoten wird die Beschriftung platziert. Der Knoten ist auch
%   verfügbar wenn keine Beschriftung angegeben wurde. Für \xLkeyword{labeloffset}\nxLkeyword{labeloffset=0}
%   ist dieser Knoten identisch mit dem Mittelpunktsknoten
%   (\prettyref{sec:centernode}).
%   \fi
%   \ifENGLISH
%   The component label is placed at this node. It is also available
%   if no label was specified. The label node is identical with the center
%   node for \xLkeyword{labeloffset}\nxLkeyword{labeloffset=0}.
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-4,6-6}]
\begin{pspicture}(3,1.5)
\pnode(0,1){A}\pnode(3,1){B}
\optbox(A)(B)
\psdot(\oenodeLabel{})
\psline[style=Refline](\oenodeTrefA{})(\oenodeTrefB{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
%
% \ifGERMAN
% \subsubsection{Externe Knoten}
% \fi
% \ifENGLISH
% \subsubsection{External nodes}
% \fi\label{sec:extnode}
%
% \begin{ltxsyntax}
%   \cmditem{oenodeExt}{obj}
%
% \ifGERMAN
% Ein externer Knoten kann an unterschiedliche Positionen entlang des
% Komponentenrandes gesetzt werden. Dieser wird nur für den externen Zugriff
% definiert, und beineinflusst in keiner Weise die Komponente.
% \fi
% \ifENGLISH
% An external node can be placed at different positions along the component
% boundary. It gets defined only for external usage and does not affect the
% component in any way.
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \valitem{extnode}{refstring}
% \ifGERMAN
% Bestimmt die Positionierung des externen Knotens. \refstringexplanation Nicht
% jede Komponente unterstützt alle möglichen Kombinationen, die möglichen
% Positionen jeder Komponente sind in \prettyref{sec:overview-extnode}
% zusammengefasst.
% \fi
% \ifENGLISH
% Set the position of the external node. \refstringexplanation Not all
% components support any possible combination. The allowed positions of each
% component are listed in \prettyref{sec:overview-extnode}.
% \fi
%
% \begin{pspicture}(6,2.5) 
%   \addtopsstyle{Beam}{beaminside=false, arrows=->, arrowinset=0, arrowscale=1.5}
%    \psset{optboxheight=1.5, optboxwidth=2.5}\ttfamily
%    \pnode(0,1.25){A}\pnode(6,1.25){B}
%    \optbox[beam, extnode=tl](A)(B)
%    \psdot(\oenodeExt{})\uput[135](\oenodeExt{}){tl}
%    \backlayer{%
%      \optbox[extnode=t](A)(B)\psdot(\oenodeExt{})\uput[90](\oenodeExt{}){t}
%      \optbox[extnode=tr](A)(B)\psdot(\oenodeExt{})\uput[90](\oenodeExt{}){tr}
%      \optbox[extnode=r](A)(B)\psdot(\oenodeExt{})\uput[45](\oenodeExt{}){r}
%      \optbox[extnode=br](A)(B)\psdot(\oenodeExt{})\uput[-90](\oenodeExt{}){br}
%      \optbox[extnode=b](A)(B)\psdot(\oenodeExt{})\uput[-90](\oenodeExt{}){b}
%      \optbox[extnode=bl](A)(B)\psdot(\oenodeExt{})\uput[-90](\oenodeExt{}){bl}
%      \optbox[extnode=l](A)(B)\psdot(\oenodeExt{})\uput[135](\oenodeExt{}){l}
%      \optbox[extnode=c](A)(B)\psdot(\oenodeExt{})\uput[180](\oenodeExt{}){c}
%    }
% \end{pspicture}
%
% \boolitem[true]{globalnoderef}
% \ifGERMAN
% Die Bezeichnung von «oben» (\opt{t}) den anderen Positionierungsparametern von
% \Lkeyword{extnode} können global oder relativ zur Komponente betrachtet werden.
%
% In dem folgenden Beispiel ist der externe Knoten immer «oben rechts» platziert
% unabhängig von der relativen Anordnung der Referenzknoten
% (\Lkeyword{globalnoderef}\opt{=true}). In dem darauffolgenden Beispiel ist die
% Positionierung relativ zur Verbindung zwischen Eingangs- und
% Ausgangsreferenzknoten (\Lkeyword{globalnoderef}\opt{=false}).
% \fi
% \ifENGLISH 
% The definition of «top» (\opt{t}) and the other \Lkeyword{extnode} refstring
% parameters can be global or relative to the component.
%
% In the next example the external node is always placed «top right»,
% independent of the actual ordering of the reference nodes
% (\Lkeyword{globalnoderef}\opt{=true}). In the following example the position is relative
% to the connection from input to output reference node
% (\Lkeyword{globalnoderef}\opt{=false}).
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(-2,-2)(2,2)
  \psset{extnode=tr, endbox, optboxwidth=1, optboxheight=0.6, dotscale=1.5}
  \multido{\i=0+45}{8}{%
    \optbox[label=0 . . relative](0,0)(1;\i){\i}
    \psdot(\oenodeExt{})
  }
\end{pspicture}
\end{LTXexample}
\begin{LTXexample}
\begin{pspicture}(-2,-2)(2,2)
  \psset{globalnoderef=false, extnode=tr, endbox, optboxwidth=1, optboxheight=0.6, dotscale=1.5}
  \multido{\i=0+45}{8}{%
    \optbox[label=0 . . relative](0,0)(1;\i){\i}
    \psdot(\oenodeExt{})
  }%
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \ifGERMAN
% \subsubsection{Grenzflächenknoten}
% \fi
% \ifENGLISH
% \subsubsection{Interface nodes}
% \fi\label{sec:ifcnode}
% \begin{ltxsyntax}
%   \cmditem{oenodeIfc}{num}{obj}
%   \cmditem{oenodeIn}{obj}
%   \cmditem{oenodeOut}{obj}
%   
%   \ifGERMAN
%   Der Grenzflächenknoten \prm{num}, wobei \prm{num} eine Ganzzahl zwischen
%   \opt{1} und \opt{N} ist. Der letzte Knoten ist immer \opt{N}. Der Knoten
%   \prm{1} ist Eingangsknoten, und sollte immer über \nxLcs{oenodeIn}
%   angesprochen werden. Der Knoten \opt{N} ist der Ausgangsknoten und sollte
%   immer über \nxLcs{oenodeOut} angesprochen werden.
%
%   «Eingang» und «Ausgang» können nur anhand einer relativen Orientierung
%   definiert werden. Per Definition ist der Eingangsknoten derjenige zu dem ein
%   Lichtstrahl ausgehend vom Eingangsreferenzknoten \Lcs{oenodeRefB}
%   verläuft. Analog dazu ist die Definition der Ausgangsknotens. Diese
%   Bezeichnung kann nur für die Faserkoppler (\ref{sec:coupler}) und
%   Strahlteiler (\ref{cmd:beamsplitter}) nicht angewendet werden.
%
%   \nxLcs{oenodeIn} ist äquivalent zu \nxLcs{oenodeIfc\{1\}} und
%   \nxLcs{oenodeOut} ist äquivalent zu \nxLcs{oenodeIfc\{N\}}. Die Eingangs-
%   und Ausgangsknoten sollten über die explizit bereitgestellten Makros
%   angesprochen werden, \nxLcs{oenodeIfc} sollte nur für die weiteren
%   Grenzflächenknoten, sofern vorhanden, verwendet werden.
%   \fi
%   \ifENGLISH
%   The interface node \prm{num}, where the number is in the range \opt{1\ldots
%     N}. The last node is always defined as \opt{N}. The interface node \prm{1}
%   is the input node, and should always be accessed via \nxLcs{oenodeIn}, the
%   interface node \prm{N} is the output node and should be accessed via
%   \nxLcs{oenodeOut}.
%
%   Here, «input» and «output» can define only relative orientations. The input
%   node is by definition the node to which a beam coming from the input
%   reference node (\Lcs{oenodeRefA}) is connected to. Accordingly is the
%   definition of the output node. This definition breaks down only for the
%   fiber couplers (\ref{sec:coupler}) and beamsplitter
%   (\ref{cmd:beamsplitter}).
%
%   \nxLcs{oenodeIn} is equivalent to \nxLcs{oenodeIfc\{1\}} and
%   \nxLcs{oenodeOut} is equivalent to \nxLcs{oenodeIfc\{N\}}. You should use
%   the \nxLcs{oenodeIfc} macro only to access the nodes which are not the input
%   and output nodes as for those explicit macros are provided.
%   \fi
% \end{ltxsyntax}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(2.8,3) 
  \pentaprism[pentaprismsize=1.3](0,1.5)(1.5,1.5)(1.5,0)
  \drawbeam[arrows=->, arrowinset=0, arrowscale=1.5]{(0,1.5)}{}{(1.5,0)}
  \psdot(\oenodeIn{})\uput[135](\oenodeIn{}){1}
  \psdot(\oenodeIfc{2}{})\uput[0](\oenodeIfc{2}{}){2}
  \psdot(\oenodeIfc{3}{})\uput[90](\oenodeIfc{3}{}){3}
  \psdot(\oenodeOut{})\uput[-45](\oenodeOut{}){N}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% In \prettyref{sec:overview-ifcnode} finden Sie eine vollständige Liste aller
% Komponenten mit ihren Grenzflächenknoten.
% \fi
% \ifENGLISH
% See \prettyref{sec:overview-ifcnode} for a complete list of all
% components with their interface nodes.
% \fi
%
% \ifGERMAN
% \subsubsection{Referenzknoten für die Rotation}
% \fi
% \ifENGLISH
% \subsubsection{Rotation reference node}
% \fi\label{sec:rotrefnode}
% \begin{ltxsyntax}
%   \cmditem{oenodeRotref}{obj}
%
%   \ifGERMAN 
%   Der Referenzknoten um den eine Komponente mit \Lkeyword{angle} gedreht
%   wird. Die Position des Knotens wird mit dem \Lkeyword{rotateref} Parameter
%   definiert und kann dieselben Werte annehmen wie der externe Knoten
%   (\prettyref{sec:extnode}). Eine vollständige Liste der möglichen Positionen
%   finden Sie in \prettyref{sec:overview-extnode}.
%   \fi
%   \ifENGLISH
%   The node around which a component is rotated by \Lkeyword{angle}. The
%   position of the node is specified with the \Lkeyword{rotateref}
%   parameter. The position which can be defined are equal to those of the
%   external nodes (\prettyref{sec:extnode}). See
%   \prettyref{sec:overview-extnode} for possible rotation reference nodes of
%   all components.
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, linerange={1-2, 6-7, 11-12}]
\begin{pspicture}(0,0.1)(12,1.8) 
  \optbox[angle=20](0.5,1)(4.5,1)
  \psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
  \psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
  \psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
  \psdot(\oenodeRotref{})\uput[-90](\oenodeRotref{}){Rotref}
  \optbox[angle=20, rotateref=bl](7.5,1)(11.5,1)
  \psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
  \psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
  \psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
  \psdot(\oenodeRotref{})\uput[-90](\oenodeRotref{}){Rotref}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
%
% \ifGERMAN
% \subsection{Spezielle Strahlknoten}
% \fi
% \ifENGLISH
% \subsection{Special beam nodes}
% \fi\label{sec:beamnode}
%
% \ifGERMAN
% Die Endknoten des letzten \Lcs{drawbeam} oder \Lcs{drawwidebeam} Kommandos
% können verwendet werden, wenn \Lkeyword{savebeampoints} auf \opt{true} gesetzt.
% ist.
% \fi
% \ifENGLISH
% The end points of the most recent \Lcs{drawbeam} or \Lcs{drawwidebeam} command can
% be accessed if \Lkeyword{savebeampoints} is set to \opt{true}.
% \fi
% \begin{ltxsyntax}
%   \cmditem{oenodeBeam}
%
%   \ifGERMAN
%   Der Endknoten des letzten \Lcs{drawbeam} Kommandos.
%   \fi
%   \ifENGLISH
%   Access the end point of the most recent \Lcs{drawbeam} command.
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(0,0)(3,2) 
  \pnode(0,1){A}\pnode(1.6,1){B}
  \optbox[endbox](A)(B)
  \drawbeam[beaminsidelast=false]{(A)}{1}
  \psdot(\oenodeBeam)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%   \cmditem{oenodeBeamUp}
%   \cmditem{oenodeBeamLow}
%
%   \ifGERMAN
%   Der obere («upper») und untere («lower») Endknoten des letzten \Lcs{drawwidebeam} Kommandos.
%   \fi
%   \ifENGLISH
%   Access the upper or lower end point of the most recent \Lcs{drawwidebeam} command.
%   \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(0,0)(3,2) 
  \pnode(0,1){A}\pnode(3,1){B}
  \lens[abspos=1, lensradius=-2](A)(B)
  \addtopsstyle{Beam}{%
    fillstyle=solid, fillcolor=green, opacity=0.3}
  \drawwidebeam[beamwidth=0.5]{(A)}{}{(B)}
  \psdot(\oenodeBeamUp)\psdot(\oenodeBeamLow)
  \uput[90](\oenodeBeamUp){\rput[rb](0,0){BeamUp}}
  \uput[-90](\oenodeBeamLow){\rput[rt](0,0){BeamLow}}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% Beachten Sie, dass «oben» («upper») und «unten» («lower») bezüglich der
% Ausbreitungsrichtung des Strahls definiert ist. Ein Randstrahl der als «upper»
% startet can zu «lower» werden, wenn er den anderen Randstrahl kreuzt. Das wird
% in dem folgenden Beispiel erläutert:
% \fi
% \ifENGLISH
% Note, that «upper» and «lower» is defined with respect to the propagation
% direction of the beam. A marginal beam which started as «upper» can change to «lower»
% if it crosses the other marginal beam. This is shown in the following example,
% where the marginal rays exchange their roles:
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(0,0)(3,2) 
  \pnode(0,1){A}\pnode(3,1){B}
  \lens[abspos=1](A)(B)
  \addtopsstyle{Beam}{%
    fillstyle=solid, fillcolor=green, opacity=0.3}
  \drawwidebeam[beamwidth=0.5]{(A)}{}
  \psdot(\oenodeBeamUp)\psdot(\oenodeBeamLow)
  \uput[90](\oenodeBeamUp){\rput[rb](0,0){BeamUp}}
  \uput[-90](\oenodeBeamLow){\rput[rt](0,0){BeamLow}}
  \drawwidebeam[beamwidth=0.5, skipconn=1]{(A)}{}{(B)}
  \psdot(\oenodeBeamUp)\psdot(\oenodeBeamLow)
  \uput[90](\oenodeBeamUp){\rput[rb](0,0){BeamUp}}
  \uput[-90](\oenodeBeamLow){\rput[rt](0,0){BeamLow}}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
%
% \ifGERMAN
% Die Strahlknoten können nur innerhalb der \env{pspicture}-Umgebung verwendet
% werden, in der sie definiert wurden. Um auf bestimmte Strahlknoten von
% außerhalb zugreifen zu können müssen diese explizit umbenannt werden:
% \fi
% \ifENGLISH
% The beam nodes can be accessed only within the \env{pspicture} environment
% they where defined in. If you want to use one of these nodes from outside, you
% must explicitely rename them:
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{lstlisting}
\pnode(\oenodeBeam){MyBeamNode}
\end{lstlisting}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
% Desweiteren werden die Endknoten durch \Lkeyword{stopinside}
% beeinflusst. Siehe \prettyref{sec:custombeam} für weitere Details.
% \fi
% \ifENGLISH
% The end points are also affected by \Lkeyword{stopinside}. See
% \prettyref{sec:custombeam} for further details.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(0,0)(3,2) 
  \pnode(0,1){A}\pnode(1.6,1){B}
  \optbox[endbox](A)(B)
  \psset{beaminsidelast=false}
  \drawbeam[linecolor=red, beampos=0.3]{(A)}{1}
  \psdot(\oenodeBeam)
  \drawbeam[stopinside]{(A)}{1}
  \psdot(\oenodeBeam)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \ifGERMAN
%   \chapter{Komponenten-Referenz}
% \fi
% \ifENGLISH
%   \chapter{Component reference}
% \fi
% 
% This chapter contains detailed information about all components and related
% options. It is divided into three parts:
% \begin{itemize}
% \item Section \ref{sec:generalparam} introduces all parameters which are
%   generic to most of the components.
% \item Section \ref{sec:freeraycomp} explains in detail all free-ray
%   components, reflective and transmittive. The free-ray components
%   differ from the fiber-optical ones with respect to their ray-tracing
%   capabilities, but they can also be connected with fibers.
% \item Section \ref{sec:fibercomp} describes all fiber-optical
%   components, which can be used with fiber connections only. They must
%   not obey any refraction or reflection law.
% \end{itemize}
%
% Often the parameter types are self-explanatory, but in some cases a clear
% distinction is needed, e.g. between \prm{num} and
% \prm{psnum}. Table~\ref{tab:paramref} explains some commonly used names.
%
% Parts in the parameter types which are indicated by square brackets are optional.
%
% \vspace*{\floatsep}
% \noindent\begin{minipage}{\textwidth}\centering
% \begin{tabularx}{0.9\linewidth}{>{\itshape}lX} \toprule
%   Name & \ifENGLISH description\fi\ifGERMAN Beschreibung\fi\\ \midrule
%   num & \ifENGLISH float number\fi\ifGERMAN Gleitkommazahl\fi \\ 
%   int & \ifENGLISH integer number\fi\ifGERMAN Ganzzahl\fi\\ 
%   dimen & \ifENGLISH dimension\fi\ifGERMAN Länge\fi\\
%   psstyle & \ifENGLISH custom graphics parameter configuration defined with \Lcs{newpsstyle}\fi
%             \ifGERMAN Benutzer-definierte Parameterkonfiguration definiert mit \Lcs{newpsstyle}\fi\\
%   psnum & \ifENGLISH Postscript code that evaluates to a number\fi
%           \ifGERMAN Postscript-Kode der zu einer Zahl auswertet\fi\\
%   refstring & \refstringexplanation\\ \bottomrule
% \end{tabularx}
% \ifGERMAN
% \captionof{table}{Parametertypen die in den Parameterdefinitionen verwendet werden.}
% \fi
% \ifENGLISH
% \captionof{table}{Parameter types used in the parameter reference.}
% \fi
% \label{tab:paramref}
% \end{minipage}
%
% \newpage
% \section{General parameters}\label{sec:generalparam}
% 
% Some general parameters which can be used for all objects.
%
% \subsection{Component appearance}\label{sec:appearance}
%
% \begin{optionlist}
% \styleitem{OptComp} 
% \vspace*{-\itemsep}
% \item[\smash{\begin{tabular}[t]{@{}r}\opt{newOptComp}\\\opt{addtoOptComp}\end{tabular}}]
% \xLkeyword{newOptComp}\xLkeyword{addtoOptComp}
% \ifGERMAN
% Bestimmt das Aussehen aller optischen Komponenten. Die üblichen Parameter, wie
% z.B. \opt{linestyle}, würden auch die Verbindungen beeinflussen, die mit der
% Komponente zusammen gezeichnet werden (\Lkeyword{beam}, \Lkeyword{fiber}
% usw.). Mit \nxLkeyword{newOptComp} und \nxLkeyword{addtoOptComp} kann der Stil
% für einzelne Kompoenenten oder zusammen mit \nxLcs{newpsobject} im optionalen
% Argument verwendet werden.
% \fi
% \ifENGLISH
% Affects the appearence of all optical components. Using standard graphics
% parameters like e.g. \opt{linestyle} would change also the connections that
% are drawn together with the component (\Lkeyword{beam}, \Lkeyword{fiber}
% etc.). Use the key \nxLkeyword{newOptComp} and \nxLkeyword{addtoOptComp} to
% change the style for single components or for use with \nxLcs{newpsobject} via
% the optional argument.
% \fi
% \iffalse
%<*ignore>
% \fi
\ifGERMAN
\begin{LTXexample}[morekeywords={[21]{addtoOptComp}}]
\begin{pspicture}(2.5,4)
  \psset{beam}
  % falsch, die Strahlbreite wird auch geändert
  \mirror[linewidth=3\pslinewidth](0,3)(2,3)(2,2)
  % korrektes Ergebnis
  \mirror[addtoOptComp={linewidth=3\pslinewidth}](0,1)(2,1)(2,0)
\end{pspicture}
\end{LTXexample}
\fi\ifENGLISH
\begin{LTXexample}[morekeywords={[21]{addtoOptComp}}]
\begin{pspicture}(2.5,4)
  \psset{beam}
  % wrong, also beam width is changed
  \mirror[linewidth=3\pslinewidth](0,3)(2,3)(2,2)
  % correct result
  \mirror[addtoOptComp={linewidth=3\pslinewidth}](0,1)(2,1)(2,0)
\end{pspicture}
\end{LTXexample}
\fi
% \iffalse
%</ignore>
% \fi
% 
% \boolitem[false]{optional}
% \ifGERMAN
% Markiert eine Komponente als optional indem der Stil
% \nxLkeyword{OptionalStyle} angewendet wird.
% \fi
% \ifENGLISH
% Mark an object as optional by applying the \opt{OptionalStyle} style.
% \fi
%
% \styleitem{OptionalStyle} 
% \ifGERMAN
% Der Stil wird zusätzlich zu \nxLkeyword{OptComp} auf Komponenten angewendet,
% die als \nxLkeyword{optional} markiert sind.
% \fi
% \ifENGLISH
% This style is applied in addition to \nxLkeyword{OptComp} to components marked
% as \nxLkeyword{optional}.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{optional}}]
\begin{pspicture}(3,1.5)
\lens[optional, beam](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \ifGERMAN
% \nxLkeyword{OptionalStyle} wird nach \nxLkeyword{OptComp} angewendet, so dass
% einzelne Einstellungen überschrieben werden können.
% \fi
% \ifENGLISH
% \nxLkeyword{OptionalStyle} is applied after \nxLkeyword{OptComp} so that it
% can overwrite the general settings.
% \fi
%
% \iffalse
%<*ignore>
% \fi
\ifGERMAN
\begin{LTXexample}[morekeywords={[21]{OptComp, OptionalStyle, optional}}]
\begin{pspicture}(3,1.5)
\addtopsstyle{OptComp}{linewidth=3\pslinewidth, linecolor=red}
\newpsstyle{OptionalStyle}{linecolor=blue}
\lens(0,1)(2,1)
% Liniefarbe wird überschrieben, die Linienbreite nicht.
\lens[optional](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
\fi\ifENGLISH
\begin{LTXexample}[morekeywords={[21]{OptComp, OptionalStyle, optional}}]
\begin{pspicture}(3,1.5)
\addtopsstyle{OptComp}{linewidth=3\pslinewidth, linecolor=red}
\newpsstyle{OptionalStyle}{linecolor=blue}
\lens(0,1)(2,1)
% linecolor overwritten, linewidth kept
\lens[optional](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
\fi
% \iffalse
%</ignore>
% \fi
%
% \end{optionlist}
%
% \ifGERMAN
%   \subsection{Drehen und Verschieben}
% \fi
% \ifENGLISH
%   \subsection{Rotating and shifting}
% \fi\label{sec:rotshift}
% \ifGERMAN
% Alle Komponenten können versetzt und um verschiedene Bezugspunkte
% gedreht werden. Beachten Sie, dass mit den Komponenten auch die
% Grenzflächenknoten transformiert werden. Die transformierten
% Referenzknoten sind als eigene Knoten verfügbar (siehe
% \prettyref{sec:refnode}).
% \fi
% \ifENGLISH
% All components can be shifted and rotated around different reference
% nodes. Please note, that together with the components also their
% interface nodes are transformed. The transformed reference nodes are
% accessible as new nodes (see \prettyref{sec:refnode}).
% \fi
% 
% \begin{optionlist}
% \numitem[0]{angle}
% \ifGERMAN
% Dreht eine Komponente um den Winkel \prm{num} (in Grad).
% \fi
% \ifENGLISH
% Rotate a component by an angle \prm{num} (in degree).
% \fi
%
% \valitem[c]{rotateref}{refstring}
% \ifGERMAN
% Setzt den Bezugspunkt für die Drehung der Komponente. Bitte lesen Sie
% \prettyref{sec:rotrefnode} für eine genauere Beschreibung und entnehmen Sie
% \prettyref{sec:overview-extnode} die möglichen Bezugspunkte für alle
% Komponenten.
% \fi
% \ifENGLISH
% Set the reference point for the rotation of the component. Please see
% \prettyref{sec:rotrefnode} for a detailed explanation and
% \prettyref{sec:overview-extnode} for a list of the possible reference nodes of
% all components.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{rotateref}}]
\begin{pspicture}(3,2)
  \optbox[angle=20, beam, rotateref=l, 
            label=0 . . relative](0,1)(3,1){box}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \numitem[0]{compshift} Shift a component perpendicular to its
% reference line (see \prettyref{sec:refnode}). For reflective
% components it is shifted along the reflective interface.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-3,7-7}, morekeywords={[21]{compshift}}]
\begin{pspicture}(3,2)
  \pnode(0,1){A}\pnode(2.7,1){B}
  \lens[compshift=0.3](A)(B){L}
  \psline[style=Refline](\oenodeRefA{})(\oenodeRefB{})
  \psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
  \psdot(\oenodeRefB{})\uput[-90](\oenodeRefB{}){RefB}
\end{pspicture}
\end{LTXexample}
\begin{LTXexample}[linerange={1-3,7-7}, morekeywords={[21]{compshift}}]
\begin{pspicture}(3,2) 
  \pnode(0,1){A}\pnode(2,0){B}
  \mirror[compshift=0.3](A)(2,1)(B){mirror}
  \psline[style=Refline](\oenodeRefA{})(\oenodeRefB{}|\oenodeRefA{})(\oenodeRefB{})
  \psdot(\oenodeRefA{})\uput[-90](\oenodeRefA{}){RefA}
  \psdot(\oenodeRefB{})\uput[180](\oenodeRefB{}){RefB}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \ifGERMAN
%   \subsection{Positionierung}
% \fi
% \ifENGLISH
%   \subsection{Positioning}
% \fi\label{sec:positioning}
% \ifGERMAN
% Alle Komponenten außer den Freistrahl-Dreipolen können zwischen ihren
% beiden Referenzknoten (\Lcs{oenodeRefA} und \Lcs{oenodeRefB})
% positioniert werden.
% \fi
% \ifENGLISH
% All components but the tripoles can be positioned between their two
% reference nodes (\Lcs{oenodeRefA} and \Lcs{oenodeRefB}).
% \fi
% \begin{optionlist}
%   \numitem{position} 
%   \ifGERMAN 
%   Setzt die relative Position eines Objektes zwischen seinen beiden
%   Referenzknoten. Ist äquivalent zum \Lkeyword*{npos} Parameter von
%   \Lcs{ncput} (eine Zahl im Intervall $[0,1]$).
%   \fi
%   \ifENGLISH
%   Control the relative position of an object between its two reference
%   points. Equivalent to the \Lkeyword*{npos} parameter of \Lcs{ncput}
%   (a number in the range $[0,1]$).
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{position}}]
\begin{pspicture}(3,1.5) 
  \lens[beam, position=0.8](0,1)(3,1){L}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem{abspos}
% \ifGERMAN
% Setzt die absolute Position zwischen den beiden Referenzknoten.
% \fi
% \ifENGLISH
% Control the absolute position between the two reference nodes.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{abspos}}]
\begin{pspicture}(3,1.5) 
  \lens[beam, abspos=1](0,1)(3,1){L}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% 
% \ifGERMAN
%   \subsection{Beschriftungen}
%   Alle Komponenten können mit einer Beschriftung versehen werden,
%   deren Position und Ausrichtung genau angepasst werden kann.
% \fi
% \ifENGLISH
%   \subsection{Labels}
%   All components may have a label, which position and alignment can be
%   adjusted precisely.
% \fi
% \label{sec:labels}
%
% \begin{optionlist}
% \numitem[0.8]{labeloffset}
% \ifGERMAN Der Abstand des Referenzknotens für die Beschriftung zum Zentrum der Komponente.\fi
% \ifENGLISH The offset of the label reference node from the component center.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-2,6-6}, morekeywords={[21]{labeloffset}}]
\begin{pspicture}(3,1.8)
  \optbox[beam, labeloffset=1](0,1.5)(3,0.8){label}
  \psdot[linecolor=blue](\oenodeCenter{})
  \psdot[linecolor=red](\oenodeLabel{})
  \ncline[arrows=<->, arrowinset=0, arrowscale=1.5]{\oenodeCenter{}}{\oenodeLabel{}}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \valitem[\nxLcs{small}]{labelstyle}{macros}
% \ifGERMAN Der Schriftstil der Beschriftungen.\fi
% \ifENGLISH The textstyle that is used to typeset the label.\fi
% 
% \valitem[c]{labelalign}{refstring}
% \ifGERMAN Definiert die Ausrichtung der Beschriftung bezüglich des vorgesehenen Referenzknotens.\fi
% \ifENGLISH Defines the alignment of the label relative to the reference node.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-3,6-6}, morekeywords={[21]{labeloffset, labelalign}}]
\begin{pspicture}(3,1.8)
  \psset{beam, labeloffset=1}
  \optbox[labelalign=bl](0,1.5)(3,0.8){label}
  \psdot[linecolor=blue](\oenodeCenter{})
  \psdot[linecolor=red](\oenodeLabel{})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \numitem[0]{labelangle}
% \ifGERMAN
% Der Rotationswinkel des Referenzknotens um das Zentrum. Der Nullpunkt
% hängt sowohl von dem jeweiligen Komponententypen und dem
% Referenzsystem ab (siehe \nxLkeyword{labelref}).
% \fi
% \ifENGLISH
% The rotation angle of the reference node around the component
% center. The origin depends both on the component type and the
% reference system (see \nxLkeyword{labelref}).
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-2,4-6,25-25}, morekeywords={[21]{labelangle}}]
\begin{pspicture}(-0.3,0)(2,3.7)
  \psset{labeloffset=1, optboxwidth=1, arrowscale=1.5, arrowinset=0}
  \begin{optexp}
  \optbox[endbox, labelangle=90](1,1)(1,2){Box}
  \beamsplitter[labelangle=-90](1,2)(1,1)(2,1){BS}
  \drawbeam[arrows=->]{1}{2}{(2,1)}
  \frontlayer{%
    \psdot[linecolor=blue](\oenodeCenter{1})
    \psdot[linecolor=blue](\oenodeCenter{2})
    \psdot[linecolor=red](\oenodeLabel{1})
    \psdot[linecolor=red](\oenodeLabel{2})
  }
  \backlayer{%
    \bgroup
    \psset{style=Refline}
    \psline(\oenodeCenter{2})([offset=-1]\oenodeCenter{2})
    \psline(\oenodeCenter{2})([Xnodesep=-1]\oenodeCenter{2})
    \psarc[arrows=<-](\oenodeCenter{2}){0.7}{180}{270}
    \psline(\oenodeCenter{1})([Xnodesep=1]\oenodeCenter{1})
    \psline(\oenodeCenter{1})([offset=1]\oenodeCenter{1})
    \psarc[arrows=->](\oenodeCenter{1}){0.7}{0}{90}
    \egroup
  }
  \end{optexp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[relgrav]{labelref}{relative, relgrav, global}
% \ifGERMAN
% Wählt das Bezugssystem für \nxLkeyword{labelangle} und die Orientierung der
% Beschriftung. Das genaue Verhalten kann am besten mit den drei folgenden
% Beispielen erläutert werden.
% \fi
% \ifENGLISH
% Set the reference coordinate system for the \nxLkeyword{labelangle} and the
% orientation of the label text. The detailed behaviour is best illustrated
% looking at the following three examples.
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{label}}]
\begin{pspicture}(-2,-2)(2,2)
  \psset{endbox, optboxwidth=1, optboxheight=0.6, label=0 . . relative}
  \multido{\i=0+45}{8}{%
    \optbox(0,0)(1;\i){\i}
  }
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}[morekeywords={[21]{labelref}}]
\begin{pspicture}(-2,-2)(2,2)
  \psset{endbox, optboxwidth=1, optboxheight=0.6, labelref=relgrav}
  \multido{\i=0+72}{5}{%
    \optbox(0,0)(1;\i){\i}
  }
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}[morekeywords={[21]{labelref}}]
\begin{pspicture}(-2,-2)(2,2)
  \psset{endbox, optboxwidth=1, optboxheight=0.6, labelref=global}
  \multido{\i=0+72}{5}{%
    \optbox[labelref=global](0,0)(1;\i){\i}
  }
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \optitem{label}{\prm{offset}[ \prm{angle}[ \prm{ref string}[ \prm{labelref}]]]}
% \ifGERMAN
% Diese Option erlaubt die kompakte Definition mehrerer
% Beschriftungsparameter. Es können bis zu vier Leerzeichen-getrennte
% Argumente übergeben werden (\nxLkeyword{labeloffset},
% \nxLkeyword{labelangle}, \nxLkeyword{labelalign} und
% \nxLkeyword{labelref}). Mit einem Punkt kann eine Option übersprungen
% werden.
% \fi
% \ifENGLISH
% Allows compact definition of several label parameters. It takes up to
% four space-separated arguments (\nxLkeyword{labeloffset},
% \nxLkeyword{labelangle}, \nxLkeyword{labelalign}, and
% \nxLkeyword{labelref}). Unchanged intermediate arguments can be
% skipped with a dot.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{label}}]
\begin{pspicture}(0,0)(4,3)
  \psset{endbox, beam}
  \optbox[label=0.7](1.5,2.5)(2.5,2.5){box}
  \optbox[label=1 -45](1.5,1)(2.5,1){$-45$}
  \optbox[label=0 . . relative]%
         (0.6,0.6)(0.6,1.6){relative}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \boolitem{innerlabel}
% \ifGERMAN Das ist ein Alias für \opt{label=0 . . relative}\fi
% \ifENGLISH This is an alias for \opt{label=0 . . relative}\fi
% \end{optionlist}
% 
% \ifGERMAN
%   \section{Freistrahl-Komponenten}
% \fi
% \ifENGLISH
%   \section{Free-ray objects}
% \fi
% \label{sec:freeraycomp}
%
% \ifGERMAN
%   \subsection{Linse}
% \fi
% \ifENGLISH
%   \subsection{Lens}
% \fi
% \label{sec:lens}
%
% \begin{ltxsyntax}
% \dipoledesc{lens}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{lens}}]
\begin{pspicture}(3,1.5)
\lens[beam](0,1)(3,1){L}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[1]{lensheight} 
% \ifGERMAN Setzt die Höhe der Linse.\fi
% \ifENGLISH Set the height of the lens.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{lensheight}}]
\begin{pspicture}(3,1.5)
\lens[beam](0,1)(3,1){L1}
\lens[lensheight=0.5](2,1)(3,1){L2}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \numitem[1]{lensradiusleft} 
% \ifGERMAN
% Setzt den Radius der linken Linsengrenzfläche. Ein positiver Wert \prm{num}
% ist für eine konvexe, ein negativer für eine konkave Krümmung. Null ergibt
% eine ebene Fläche.
% \fi
% \ifENGLISH
% Set the left radius of the lens. A positive \prm{num} is for convex, a
% negative one for concave curvatures. Use zero for a plain surface.
% \fi
% 
% \numitem[1]{lensradiusright} 
% \ifGERMAN
% Dasgleiche wie \opt{lensradiusleft}, nur für die rechte Grenzfläche.
% \fi
% \ifENGLISH
% Same as \opt{lensradiusleft} but for the right surface.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{lensradiusleft, lensradiusright}}]
\begin{pspicture}(3,1.5)
  \psset{lensradiusright=0, beam}
  \lens[lensradiusleft=1](0,1)(1.5,1){$R > 0$}
  \lens[lensradiusleft=-1](1.5,1)(3,1){$R < 0$}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem{lensradius} 
% \ifGERMAN
%   Setzt beide Krümmungen auf denselben Wert.
% \fi
% \ifENGLISH
%   Set both curvatures to the same value.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{lensradius}}]
\begin{pspicture}(3,1.5)
  \lens[lensradius=-2, beam](0,1)(3,1){L1}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \numitem[0]{lenswidth}
% \ifGERMAN
% Üblicherweise werden nur die Höhe und die beiden Radien für die
% Konstuktion der Linse verwendet. Die Mittenbreite wird automatisch
% ermittelt. Wenn \opt{lenswidth} auf einen Wert größer Null gesetzt wird,
% wird diese Breite verwendet. Das ist nur sinnvoll, wenn dicke Linsen
% gezeichnet werden sollen, da es andernfalls für zu kleine Werte zu unschönen
% Ergebnissen führt.
% \fi
% \ifENGLISH
% Usually only the height and the two radii are used to construct the lens and
% the width is calculated from these parameters. If \opt{lenswidth} is greater
% than zero, this width is used instead. This is only useful if you want to draw
% thick lenses and it can have ugly results if the lens width is choosen too
% small.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{lenswidth}}]
\begin{pspicture}(3,2)
  \lens[lenswidth=0.5, beam](0,1)(2,1){thicklens}
  \lens[lenswidth=0.1, beam](2,1)(3,1){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \optitem{lens}{\prm{radiusleft} [\prm{radiusright} [\prm{height} [\prm{width}]]]}
% \ifGERMAN
% Eine Option zum gleichzeitigen Setzen mehrerer Linsenparameter. Es müssen
% nicht alle Werte gesetzt werden, die übrigen bleiben unverändert.
% \fi
% \ifENGLISH
% A convenience option to specify all lens parameters with a single option.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{lens}}]
\begin{pspicture}(3,1.5)
  \lens[lens=1](0,1)(1,1){L1}
  \lens[lens=-2 1, beam](0,1)(3,1){L2}
  \lens[lens=1 -0.5 0.7](2,1)(3,1){L3}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Optisches Pl\"attchen}
% \fi
% \ifENGLISH
%   \subsection{Optical plate}
% \fi
% 
% \begin{ltxsyntax}
% \dipoledesc{optplate}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{optplate}}]
\begin{pspicture}(3,1.5)
  \optplate[beam](0,1)(3,1){filter}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
%   \numitem[1]{plateheight} 
%   \ifGERMAN Die Höhe des Plättchens.\fi\ifENGLISH The height of the plate.\fi
% 
%   \optitem[2\nxLcs{pslinewidth}]{platelinewidth}{\prm{num} or \prm{dimen}} 
%   \ifGERMAN \linewidthexplanation{des Plättchens}{Plättchen}\fi
%   \ifENGLISH \linewidthexplanation{plate}{plates}\fi
% \end{optionlist}
% 
% \ifGERMAN
%   \subsection{Verzögerungsplättchen}
% \fi
% \ifENGLISH
%   \subsection{Retardation plate}
% \fi
% \begin{ltxsyntax}
% \dipoledesc{optretplate}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{optretplate}}]
\begin{pspicture}(3,1.5)
  \optretplate[beam](0,1)(3,1){$\nicefrac{\lambda}{2}$}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem*[1]{plateheight} \ifGERMAN Die Höhe des Plättchens.\fi\ifENGLISH The height of the plate.\fi
% \numitem[0.1]{platewidth} \ifGERMAN Die Breite des Plättchens.\fi\ifENGLISH The width of the plate.\fi
% \end{optionlist}
% 
% \subsection{Pinhole}
% 
% \begin{ltxsyntax}
% \dipoledesc{pinhole}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{pinhole}}]
\begin{pspicture}(3,1.5)
  \pinhole[beam](0,1)(3,1){PH}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[1]{outerheight} \ifGERMAN Die Höhe der Lochblende.\fi\ifENGLISH The height of the pinhole.\fi
% \numitem[0.1]{innerheight} \ifGERMAN Die Höhe des Lochs.\fi\ifENGLISH The height of the hole.\fi
% \optitem[2\nxLcs{pslinewidth}]{phlinewidth}{\prm{num} or \prm{dimen}}
% \ifGERMAN \linewidthexplanation{der Lochblende}{Lochblende}\fi
% \ifENGLISH \linewidthexplanation{pinhole}{pinholes}\fi
% 
% \numitem[0]{phwidth} 
% \ifGERMAN 
% Das Pinhole wird plastischer gezeichnet, falls \nxLkeyword{phwidth}
% ungleich Null ist. Bei einem negativen Wert wird die Form gespiegelt.
% \fi
% \ifENGLISH
% The pinhole is drawn in a more plastic style if the
% \nxLkeyword{phwidth} is not zero. For negative values the shape is
% mirrored.
% \fi 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{phwidth}}]
\begin{pspicture}(3,1.5)
  \pinhole[beam, phwidth=-0.1](0,1)(1.5,1){neg}
  \pinhole[beam, phwidth=0.05](1.5,1)(3,1){pos}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \subsection{Crystal}
% \begin{ltxsyntax}
% \dipoledesc{crystal}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{crystal}}]
\begin{pspicture}(3,1.3)
\crystal[beam](0,1)(3,1){Crystal}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[1.4]{crystalwidth}
% \ifGERMAN Die Breite des Kristalls.\fi
% \ifENGLISH The width of the crystal.\fi
%
% \numitem[0.6]{crystalheight}
% \ifGERMAN Die Höhe des Kristalls.\fi
% \ifENGLISH The height of the crystal.\fi
%
% \numitem[0.6]{caxislength}
% \ifGERMAN Die Länge des Pfeils für die $c$-Achse, wird weggelassen falls die Länge \opt{0} ist.\fi
% \ifENGLISH The length of the $c$-axis, is dropped when set to \opt{0}.\fi
%
% \boolitem[false]{caxisinv}
% \ifGERMAN Invertiert die Richtung der $c$-Achse.\fi
% \ifENGLISH Invert the direction of the $c$-axis.\fi
%
% \styleitem{CrystalCaxis}
% \ifGERMAN Der Stil für die $c$-Achse.\fi
% \ifENGLISH The style of the $c$-axis.\fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{voltage, caxisinv}}]
\begin{pspicture}(0,0.5)(3,1.6)
\crystal[voltage, caxisinv, beam](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \boolitem[false]{voltage}
% \ifGERMAN Zeichne einen Spannungsangschluss und ein Erdungszeichen.\fi
% \ifENGLISH Draw a voltage connection and a ground sign.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{voltage}}]
\begin{pspicture}(0,0.4)(3,1.5)
\crystal[voltage, beam](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \boolitem[false]{lamp}
% \ifGERMAN Zeichne eine Lampe neben den Kristall.\fi
% \ifENGLISH Draw a lamp near the crystal.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{lamp}}]
\begin{pspicture}(0,0.4)(3,1.7)
\crystal[lamp, beam](0,1)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \numitem[0.3]{lampscale}
% \ifGERMAN Skalierung der Lampe.\fi
% \ifENGLISH Scale for the lamp.\fi
% \end{optionlist}
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{voltage, lamp}}]
\begin{pspicture}(3,1.7)
\crystal[fillstyle=solid, fillcolor=yellow!90!black, 
           label=1.2 -45, voltage, 
           lamp, beam](0,1)(3,1){SBN:Ce}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \medskip
% 
% \subsection{Box}\label{sec:box}
% 
% \begin{ltxsyntax}
% \dipoledesc{optbox}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{optbox}}]
\begin{pspicture}(3,2)
  \optbox[beam](0,0)(3,2){box}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[1.4]{optboxwidth}
% \ifGERMAN Die Breite der Box.\fi\ifENGLISH The width of the box.\fi
%
% \numitem[0.8]{optboxheight}
% \ifGERMAN Die Höhe der Box.\fi\ifENGLISH The height of the box.\fi
%
% \boolitem[false]{endbox}
% \ifGERMAN 
% Setzt die Box ans Ende der Referenzlinie. Mit \Lkeyword{abspos} oder
% \Lkeyword{position} wäre das im Allgemeinen recht schwierig.
% \fi
% \ifENGLISH
% Place the box at the end of the reference line. With \Lkeyword{abspos} or
% \Lkeyword{position} this is in general not so easy to achieve.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{endbox}}]
\begin{pspicture}(3,2)
  \optbox[beam, endbox, label=0 . . relative]%
           (0,0)(1.5,1){box}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Detektor}\fi
% \ifENGLISH\subsection{Detector}\fi
% 
% \begin{ltxsyntax}
% \dipoledesc{optdetector}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.2)
  \optdetector[beam](0,0)(1.5,1){detector}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.8]{detsize} 
%   \ifGERMAN 
%   Das ist die Seitenlänge (\opt{diode}) bzw. der Durchmesser (\opt{round}) des Detektors.
%   \fi
%   \ifENGLISH 
%   This is the side length (\opt{diode}) or the diameter \opt{round} of the detector.
%   \fi
% 
%   \choitem[round]{dettype}{round, diode} 
%   \ifGERMAN
%   Dieser Parameter bestimmt den Typ und damit das Aussehen des Detektors.
%   \fi
%   \ifENGLISH
%   This parameter selects between different types of detectors.
%   \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{dettype}}] 
\begin{pspicture}(3,1.5)
  \optdetector[beam, dettype=diode](0,0)(1.5,1){detector}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Optische Diode}\fi
% \ifENGLISH\subsection{Optical diode}\fi
%
% \begin{ltxsyntax}
% \dipoledesc{optdiode}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{optdiode}}] 
\begin{pspicture}(3,2)
   \optdiode[beam, beaminside=false](0,1)(3,1){Diode}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.8]{optdiodesize}
% \ifGERMAN 
% Die Seitenlänge der optischen Diode.
% \fi
% \ifENGLISH
% The side length of the optical diode.
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Doveprisma}\fi
% \ifENGLISH\subsection{Dove prism}\fi
% 
% \begin{ltxsyntax}
% \dipoledesc{doveprism}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{doveprism}}] 
\begin{pspicture}(3,1.5)
  \doveprism[beam](0,1)(3,1){Dove}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.6]{doveprismsize} 
%   \ifGERMAN
%   Die Höhe des Prismas, die Gesamtbreite ist das dreifache und die Winkel an
%   der Eingangs- und Ausgangsfläche betragen 45\textdegree.
%   \fi
%   \ifENGLISH
%    The height of the prism, the total width is set to
%   three times the height and the angles at the input and output faces are
%   45\textdegree.
%   \fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Polarisation}\fi
% \ifENGLISH\subsection{Polarization}\fi
%
% \begin{ltxsyntax}
% \dipoledesc{polarization}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{polarization}}] 
\begin{pspicture}(3,1)
  \polarization[beam](0,0.5)(3,0.5)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.6]{polsize}
% \ifGERMAN Die Größe des Polarisationszeichens, der Kreis für \opt{perp} und
% \opt{polmisc} ist halb so groß.\fi
% \ifENGLISH The size of the polarization symbol, the circle for \opt{perp} and
% \opt{polmisc} is half of this.\fi
%
% \optitem[0.7\nxLcs{pslinewidth}]{pollinewidth}{\prm{num} or \prm{dimen}}
%   \ifGERMAN \linewidthexplanation{des Polarisationszeichens}{Polarisationszeichen}\fi
%   \ifENGLISH \linewidthexplanation{polarisation sign}{polarisation signs}\fi
% \ifGERMAN Dieser Parameter ist seit 3.0 veraltet, verwenden Sie stattdessen den \opt{Polarization}-Stil.\fi
% \ifENGLISH This parameter is deprecated since 3.0, please use the \opt{Polarization} style instead.\fi
%
% \choitem[parallel]{poltype}{parallel, perp, misc, lcirc, rcirc}
% \ifGERMAN Dieser Parameter wählt die Polarizationsart aus.\fi
% \ifENGLISH This parameter choses the polarization type.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{poltype}}] 
\begin{pspicture}(3,5)
  \psset{beam}
  \begin{optexp}
  \polarization[poltype=parallel, 
                  abspos=0.5](0,4.5)(3,4.5)
  \polarization[poltype=perp, abspos=1](0,3.5)(3,3.5)
  \polarization[poltype=misc, abspos=1.5](0,2.5)(3,2.5)
  \polarization[poltype=lcirc, abspos=2](0,1.5)(3,1.5)
  \polarization[poltype=rcirc, 
                  abspos=2.5](0,0.5)(3,0.5)
  \end{optexp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \styleitem{Polarization}
% \end{optionlist}
% 
% \ifGERMAN\subsection{Spiegel}\fi
% \ifENGLISH\subsection{Mirror}\fi
% 
% \begin{ltxsyntax}
% \tripoledesc{mirror}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{mirror}}] 
\begin{pspicture}(3,2)
  \mirror[beam](0,0)(1.8,1.5)(0,2){M}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[1]{mirrorwidth}
% \ifGERMAN 
%   Die Breite des Spiegels.
%  \fi
% \ifENGLISH 
%   The width of the mirror.
% \fi
% 
% \optitem[2\nxLcs{pslinewidth}]{mirrorlinewidth}{\prm{num} or \prm{dimen}} 
% \ifGERMAN \linewidthexplanation{des Spiegels}{Spiegel}\fi
% \ifENGLISH \linewidthexplanation{mirror}{mirrors}\fi
%
% \numitem[0]{mirrorradius} 
% \ifGERMAN
% Diese Parameter setzt die Krümmung des Spiegels. Null ergibt einen
% ebenen, ein negativer Radius einen konvexen und ein positiver Radius
% einen konkaven Spiegel.
% \fi
% \ifENGLISH
% This parameter defines the curvature of the mirror. A value of \opt{0}
% is for a plain mirror, a negative radius for a convex mirror and a
% positive radius gives you a concave mirror.
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \psset{labeloffset=0.5}
  \mirror[mirrorradius=1](0,0)(1,2)(1.8,1){convex}
  \mirror[mirrorradius=-1](1,2)(1.8,1)(2.5,3){concave}
  \drawbeam{(0,0)}{1}{2}{(2.5,3)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[normal]{mirrortype}{normal, piezo, extended}
% \ifGERMAN
%   Diese Parameter wählt die Spiegelart aus. Beachte, dass der
%   Anschlussdraht für den Piezospiegel nicht gezeichnet wird, wenn
%   \Lkeyword{extnode} verwendet wird.
% \fi
% \ifENGLISH
% The \nxLkeyword{mirrortype} selects between different types of
% mirrors. Note, when using \Lkeyword{extnode} with a piezo mirror, the
% default piece of wire is omitted.
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \mirror[mirrortype=extended,
            beam](0,0)(1.8,1.5)(0,2){ext}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}
\begin{pspicture}(3,2)
\mirror[mirrortype=piezo,
          beam](0,0)(1.8,1.5)(0,2){piezo}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \styleitem{ExtendedMirror} 
% \ifGERMAN Der Stil für den «extended» Spiegel.\fi
% \ifENGLISH The style for the extended mirror.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \newpsstyle{ExtendedMirror}{fillstyle=solid, 
                                fillcolor=gray!50,
                                linestyle=none}
  \mirror[mirrortype=extended,
            beam](0,0)(1.8,1.5)(0,2){ext}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \styleitem{PiezoMirror} 
% \ifGERMAN 
% Der Stil für den «piezo» Spiegel. Dieser kann auch dazu verwendet
% werden, die Größe des Piezos zu verändern, wie die Beispiele zeigen.
% \fi
% \ifENGLISH
% This style defines the appearance of the piezo mirror. This can also
% be used to change the size of piezo part, as shown in the examples.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \addtopsstyle{PiezoMirror}{xunit=2}
  \mirror[mirrortype=piezo,
            beam](0,0)(1.8,1.5)(0,2){piezo}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \boolitem[false]{variable}
% \ifGERMAN
% Zeichnet einen verstellbaren Spiegel, der mit zwei zusätzlichen,
% gekrümmten Pfeilen an beiden Seiten angedeutet wird.
% \fi
% \ifENGLISH
% Draw an adjustable mirror which has two additional curved arrows on
% both sides.
% \fi
%
% \styleitem{VariableMirror} 
% \ifGERMAN
%   Der Stil der Pfeiles des verstellbaren Spiegels.
% \fi
% \ifENGLISH
% The style of the arrows of the variable mirror.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \mirror[beam, variable](0,0)(1.8,1.5)(0,2){var}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem[0.1]{mirrordepth} 
% \ifGERMAN
%   Die Tiefe eines breiten Spiegels.
% \fi
% \ifENGLISH
%   The depth of an extended mirror.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \mirror[mirrortype=extended, mirrordepth=0.2,
            beam](0,0)(1.8,1.5)(0,2){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Strahlteiler}\fi
% \ifENGLISH\subsection{Beamsplitter}\fi
%
% \begin{ltxsyntax}
% \tripoledesc{beamsplitter}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \beamsplitter[beam](0,1)(2,1)(2,0){BS}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{bssize}
% \ifGERMAN
%   Die Größe des Strahlteilers.
% \fi
% \ifENGLISH
%   The beamplitter size.
% \fi
%  
% \choitem[cube]{bsstyle}{cube, plate} 
% \ifGERMAN
% Wähle zwischen zwei Strahlteilertypen: einem Strahlteilerwürfel
% (\opt{cube}) und einem halbdurchlässigen Spiegel
% (\opt{plate}). Beachte, dass trotz des gleichen Aussehens der
% halbdurchlässige Spiegel eine anderes Verhalten beim Strahlzeichnen
% als der gewöhnliche Spiegel hat.
% \fi
% \ifENGLISH
% Selects between two types of beamsplitters: the beamsplitter cube
% (\opt{cube}) and the semitransparent mirror (\opt{plate}).  Note, that
% despite the same look, the \opt{plate} beamsplitter behaves
% differently for beam drawing.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \beamsplitter[bsstyle=plate, beam](0,1)(2,1)(2,0){BS}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Optisches Gitter}\fi
% \ifENGLISH\subsection{Optical grating}\fi
% 
% \begin{ltxsyntax}
% \tripoledesc{optgrating}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[1]{gratingwidth} 
% \ifGERMAN Die Breite des Gitters.\fi
% \ifENGLISH The width of the grating.\fi
% 
% \numitem[0.15]{gratingheight} 
% \ifGERMAN Die Gesamthöhe des Gitters.\fi
% \ifENGLISH The total height of the grating.\fi
% 
% \numitem[0.075]{gratingdepth}
% \ifGERMAN 
% Die absolute Modulationstiefe der Gitterstruktur. Die Gesamthöhe wird
% an diesen Wert angepasst falls sie kleiner als die Modulationtiefe ist, 
% andernfalls wird sie nicht beinflusst.
% \fi
% \ifENGLISH
% The modulation depth of the grating structure. The total height is
% adapted to this value if it is smaller than the modulation
% depth. Otherwise the total height is not affected.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[gratingdepth=0.05, 
               beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \intitem[10]{gratingcount} 
% \ifGERMAN Die Anzahl der Gitterlinien.\fi
% \ifENGLISH The number of grating grooves.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[gratingcount=3, 
               beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[blazed]{gratingtype}{blazed, binary} 
% \ifGERMAN 
%   Wähle zwischen einem binären Gitter (\opt{binary}) und einem Blazegitter (\opt{blazed}).
% \fi
% \ifENGLISH
%   Select between a \opt{binary} and a \opt{blazed} grating.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[gratingtype=binary, 
               beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \boolitem[false]{reverse} 
% \ifGERMAN
%   Invertiere die Steigung des Blazegitters.
% \fi
% \ifENGLISH
%   Reverse the slope of the grooves of the \opt{blazed} grating.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optgrating[reverse, beam](0,2)(1.8,1.5)(0,0){grating}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \optitem[0.7\nxLcs{pslinewidth}]{gratinglinewidth}{\prm{num} or \prm{dimen}} 
% \ifGERMAN \linewidthexplanation{des Gitters}{Gitter}\fi
% \ifENGLISH \linewidthexplanation{grating}{gratings}\fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Prisma}\fi
% \ifENGLISH\subsection{Prism}\fi
% 
% \begin{ltxsyntax}
% \tripoledesc{optprism}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optprism[beam](0,1)(2,1)(3,0){Prism}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \ifGERMAN
% Das Prisma wird immer symmetrisch bezüglich der \prm{in} und \prm{out}
% Knoten ausgerichtet. Für asymmetrischen Strahlengang siehe
% \prettyref{sec:connecting}.
% \fi
% \ifENGLISH
% The prism is always placed symmetric between \prm{in} and \prm{out}
% nodes. For asymmetric beam traces see \prettyref{sec:connecting}.
% \fi
%
% \begin{optionlist}
% \numitem[1]{prismsize} 
% \ifGERMAN Die Höhe des Prismas.\fi
% \ifENGLISH The height of the prism.\fi
% \numitem[60]{prismangle}
% \ifGERMAN Der obere Winkel des Prismas.\fi
% \ifENGLISH The upper angle of the prism.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \optprism[prismangle=30, beam](0,1)(2,1)(3,0){Prism}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Umkehrprisma}\fi
% \ifENGLISH\subsection{Right-angle prism}\fi
% 
% \begin{ltxsyntax}
% \tripoledesc{rightangleprism}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psdot(1.8,1)
  \rightangleprism[beam](0,1.5)(1.8,1)(0,0.5){RA}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \ifGERMAN
% Das Umkehrprisma wird so ausgerichtet, dass der einfallende und der
% reflektierte Strahl parallel sind und der \prm{center} Knoten vertikal
% zentriert in dem Prisma liegt.
% \fi
% \ifENGLISH
% The right-angle prisms is align such that the incoming and reflected
% beam are parallel and the \prm{center} node is vertically centered in
% the prism.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psdot(1.8,1.2)
  \rightangleprism[beam](0,1.5)(1.8,1.2)(0,0.5){RA}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \begin{optionlist}
% \numitem[1.5]{raprismsize}
% \ifGERMAN Die Länge der Eingangsfläche.\fi
% \ifENGLISH The length of the input plane.\fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Pentaprisma}\fi
% \ifENGLISH\subsection{Penta prism}\fi
% 
% \begin{ltxsyntax}
% \tripoledesc{pentaprism}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
  \pentaprism[beam](0,1)(2,1)(2,0){PP}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.7]{pentaprismsize} 
%   \ifGERMAN Die Länge der Eingangs- und Ausgangsfläche.\fi
%   \ifENGLISH The length of the input and output plane.\fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Benutzerdefinierte Komponenten}\fi
% \ifENGLISH\subsection{Custom components}\fi
% \label{sec:custom}
%
% \ifGERMAN
% Das \LPack{pst-optexp} Paket stellt zwei Makros zur Verfügung um
% eigene Komponenten zu zeichnen. Diese können z.B. aus Bildern oder
% eigenen Zeichnungen bestehen.
% \fi
% \ifENGLISH
% The \nxLPack{pst-optexp} package provides two commands which can use
% anything as optical components. This includes e.g. external images or
% your own drawings.
% \fi
% 
% \begin{ltxsyntax}
%   \dipoledesc{optdipole}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \optdipole[labeloffset=1, beam](0,2)(3,1){%
    \rput(0,0){\rule{0.5cm}{1cm}}%
  }{label}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \tripoledesc{opttripole}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \opttripole[beam](3,1.5)(1.5,2)(0,0){%
    \rput[b](0,0){text}%
  }{label}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
%
% If you want to use a custom component more often, you should define
% it as a new component. For details on how to define your own components see
% \prettyref{sec:newobj}.
% 
% \ifGERMAN\section{Faseroptische Komponenten}\fi
% \ifENGLISH\section{Fiber-optical components}\fi
% \label{sec:fibercomp}
% 
% \begin{optionlist}
%   \boolitem{usefiberstyle} For some components it might me nice to highlight
%   some internals. If \Lkeyword{usefiberstyle} is enabled, for examples the
%   passing parts of the optical filter are drawn with the \styleshape{Fiber}
%   style. In the documentation this parameter is enabled to show the parts
%   which would be highlighted.
% \end{optionlist}
%
% \ifGERMAN\subsection{Optische Faser}\fi
% \ifENGLISH\subsection{Optical fiber}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optfiber}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset{labeloffset=0.3}
  \optfiber(0,0.5)(3,0.5){SSMF}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \intitem[3]{fiberloops} 
% \ifGERMAN Anzahl der Faserschleifen.\fi
% \ifENGLISH Number of the fiber loops.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset{labeloffset=0.3}
  \optfiber[fiberloops=2](0,0.5)(3,0.5){SSMF}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem[0.4]{fiberloopradius}
% \ifGERMAN Radius der Faserschleifen.\fi
% \ifENGLISH Radius of the fiber loops.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset{labeloffset=0.3}
  \optfiber[fiberloopradius=0.2](0,0.5)(3,0.5){SSMF}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \numitem[0.3]{fiberloopsep}
% \ifGERMAN Abstand zwischen zwei aufeinanderfolgenden Faserschleifen.\fi
% \ifENGLISH Separation between two successive fiber loops.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \psset{labeloffset=0.3}
  \optfiber[fiberloopsep=0.6](0,0.5)(3,0.5){SSMF}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Optischer Verstärker}\fi
% \ifENGLISH\subsection{Optical amplifier}\fi
%
% \begin{ltxsyntax}
% \fiberdipoledesc{optamp}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optamp(0,1)(3,1){EDFA}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{optampsize} \sizeexplanation{\ifGERMAN des Verstärkers\fi\ifENGLISH amplifier\fi}
% \end{optionlist}
% 
% \ifGERMAN\subsection{Mach-Zehnder-Modulator}\fi
% \ifENGLISH\subsection{Mach-Zehnder modulator}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optmzm}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optmzm(0,1)(3,1){MZM}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{optmzmsize} \sizeexplanation{\ifGERMAN des Modulators\fi\ifENGLISH modulator\fi}
% \end{optionlist}
% 
% \ifGERMAN\subsection{Optischer Filter}\fi
% \ifENGLISH\subsection{Optical filter}\fi
%
% \begin{ltxsyntax}
% \fiberdipoledesc{optfilter}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfilter(0,1)(3,1){bandpass}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{filtersize}
% \ifGERMAN Die Größe des Filters.\fi
% \ifENGLISH The size of the filter.\fi
%
% \choitem[bandpass]{filtertype}{bandpass, bandstop, lowpass, highpass}
% \ifGERMAN Wähle zwischen unterschiedlichen Filtertypen.\fi
% \ifENGLISH Select between different filter types.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfilter[filtertype=bandstop](0,1)(3,1){bandstop}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfilter[filtertype=lowpass](0,1)(3,1){lowpass}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfilter[filtertype=highpass](0,1)(3,1){highpass}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Polarisationssteller}\fi
% \ifENGLISH\subsection{Polarization controller}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{polcontrol}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \polcontrol(0,1)(3,1){PC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.15]{polcontrolsize} 
% \ifGERMAN Der Radius der Polarisationssteller-Kreise.\fi
% \ifENGLISH The radius of the polarization controller circles.\fi
% \end{optionlist}
% 
% \subsection{Isolator}
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optisolator}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optisolator(0,1)(3,1){isolator}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.6]{isolatorsize} \sizeexplanation{\ifGERMAN des Isolators\fi\ifENGLISH isolator\fi}
%
% \styleitem{IsolatorArrow} 
% \ifGERMAN 
% Der Stil für den Isolatorpfeil. Das kann insbesondere nützlich sein um
% die Länge des Pfeils zu verändern. 
% \fi
% \ifENGLISH 
% The style of the isolator arrow. This can be especially useful to
% adapt the length of the arrow.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \addtopsstyle{IsolatorArrow}{xunit=1.2, 
                                 arrowinset=0.1}
  \optisolator(0,1)(3,1){isolator}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Optischer Schalter}\fi
% \ifENGLISH\subsection{Optical switch}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optswitch}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optswitch(0,1)(3,1){opened switch}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.8]{switchsize}
% \ifGERMAN Die Größe des Schalters.\fi
% \ifENGLISH The size of the switch.\fi
%
% \choitem[opened]{switchstyle}{opened, closed} 
% \ifGERMAN Der Zustand des Schalters kann geschlossen (\opt{closed}) oder geöffnet (\opt{opened}) sein. \fi
% \ifENGLISH Indicate the switch as \opt{opened} or \opt{closed}.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optswitch[switchstyle=closed](0,1)(3,1){closed switch}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Faserverzögerungstrecke}\fi
% \ifENGLISH\subsection{Fiber delay line}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{fiberdelayline}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \fiberdelayline(0,1)(3,1){delay line}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem[0.6]{fdlsize} \sizeexplanation{\ifGERMAN der Verzögerungsstrecke\fi\ifENGLISH delay line\fi}
%
% \styleitem{FdlArrow} 
% \ifGERMAN 
% Der Stil für den Pfeil. Das kann insbesonders nützlich sein um die
% Länge des Pfeils zu verändern, die bei geänderter Größe nicht mehr
% passend sein kann, oder um den Pfeil zu spiegeln.
% \fi
% \ifENGLISH 
% The style of the arrow. This can be especially useful to
% adapt the length of the arrow which may not be appropriate depending
% on the \opt{fdlsize}, or to reverse the arrow.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \addtopsstyle{FdlArrow}{xunit=-1}
  \fiberdelayline(0,1)(3,1){Delay line}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsection{Polarisator}\fi
% \ifENGLISH\subsection{Polarizer}\fi
% 
% \begin{ltxsyntax}
% \fiberdipoledesc{optfiberpolarizer}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optfiberpolarizer(0,1)(3,1){polarizer}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \numitem[0.6]{fiberpolsize} \sizeexplanation{\ifGERMAN des Polarisators\fi\ifENGLISH polarizer\fi}
% \end{optionlist}
% 
% \ifGERMAN\subsection{Faserkollimator}\fi
% \ifENGLISH\subsection{Fiber collimator}\fi
% 
% \begin{ltxsyntax}
% \xLdipole{fibercollimator}\cmditem{fibercollimator}(in)(A)(B)(out){label}%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \fibercollimator[beam](0,1)(3,1){FC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.3]{fibercolsize} \sizeexplanation{\ifGERMAN des Kollimators\fi\ifENGLISH collimator\fi}
% \end{optionlist}
% \ifGERMAN
% Der Fasekollimator kann mit zwei, drei oder vier Punkten verwendet
% werden. Bei zwei Punkten wird der Kollimator wie jeder andere Zweipol
% zwischen \prm{in} und \prm{out} Knoten platziert. Bei drei Punkten
% wird eine \Lcs{psbezier} Kurve gezeichnet, wobei der mittlere Punkt
% doppelt verwendet wird. Die Positionierungsparameter (see
% \prettyref{sec:positioning}) können verwendet werden um den Kollimator
% zwischen dem \prm{in} und \prm{A} Knoten auszurichten.
% \fi
% \ifENGLISH
% The \nxLcs{fibercollimator} can be used with two, three or four
% points. With two points, the collimator is placed like any other
% dipole component between \prm{in} and \prm{out} node. For three nodes,
% the fiber is drawn as \Lcs{psbezier} curve for which the central node
% \prm{A} is used twice. Positioning parameters can be used to shift the
% object between \prm{in} and \prm{A} nodes.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
   \fibercollimator[beam](0,1)(2,1)(3,2){FC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \medskip
%
% \ifGERMAN
% Bei vier Konten wird eine \Lcs{psbezier} Kurve mit allen vier Knoten
% gezeichnet. Die Positionierungsparameter (see
% \prettyref{sec:positioning}) können verwendet werden um den Kollimator
% zwischen dem \prm{in} und \prm{A} Knoten auszurichten.
% \fi
% \ifENGLISH
% For four nodes, the fiber is drawn as \Lcs{psbezier} curve with the
% specified nodes. Positioning parameters can be used to shift the
% object between \prm{in} and \prm{A} nodes.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2)
   \fibercollimator[beam](0,1)(2,1)(3,1)(3,2){FC}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \ifGERMAN\subsection{Faserkoppler}\fi
% \ifENGLISH\subsection{Fiber coupler}\fi\label{sec:coupler}
%
% \ifGERMAN\subsubsection{\texorpdfstring{\mathversion{bold}$2\times 2$}{2x2}-Koppler}\fi
% \ifENGLISH\subsubsection{\texorpdfstring{\mathversion{bold}$2\times 2$}{2x2} coupler}\fi
%
% \begin{ltxsyntax}
% \xLfmultipole{optcoupler}%
% \cmditem{optcoupler}(lefttop)(leftbottom)(righttop)(rightbottom)%
% \cmditem*{optcoupler}(lefttop)(leftbottom)(righttop)(rightbottom){label}%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \optcoupler(0,1.5)(0,0.5)(3,1.5)(3,0.5){Coupler}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.2]{couplersize} \sizeexplanation[2.5]{\ifGERMAN des Kopplers\fi\ifENGLISH coupler\fi}
% \numitem[0.1]{couplersep} 
% \ifGERMAN Der vertikale Abstand zwischen zwei Faserports.\fi
% \ifENGLISH The vertical distance between two fiber ports.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{couplersep}}]
\begin{pspicture}(3,1.5)
  \optcoupler[couplersep=0]%
               (0,1.5)(0,0.5)(3,1.5)(3,0.5){Coupler}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[elliptic]{couplertype}{none, elliptic, rectangular, crossswitch}
% \ifGERMAN Wähle zwischen unterschiedlichen Kopplertypen.\fi
% \ifENGLISH Select between different coupler types.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{couplertype}}]
\begin{pspicture}(3,4.5)
  \psset{labeloffset=0.5}
  \optcoupler[couplertype=none]%
                (0,4.5)(0,3.5)(3,4.5)(3,3.5)
  \optcoupler[couplertype=rectangular]%
               (0,3)(0,2)(3,3)(3,2)
  \optcoupler[couplertype=crossswitch]%
               (0,1.5)(0,0.5)(3,1.5)(3,0.5)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem[center]{align}{top, bottom, center}
% \ifGERMAN Die Ausrichtung des Kopplers bezüglich der Referenzknoten.\fi
% \ifENGLISH The alignment of the coupler with respect to the reference nodes.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{align}}]
\begin{pspicture}(3,3)
  \psset{labeloffset=0.4}
  \optcoupler[align=top]%
               (0,3)(0,2)(3,3)(3,2){Top}
  \optcoupler[align=bottom]
               (0,1.5)(0,0.5)(3,1.5)(3,0.5){Bottom}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsubsection{WDM-Koppler}\fi
% \ifENGLISH\subsubsection{WDM coupler}\fi
%
% \begin{ltxsyntax}
% \xLfmultipole{wdmcoupler}%
% \cmditem{wdmcoupler}(lefttop)(leftbottom)(right)%
% \cmditem*{wdmcoupler}(lefttop)(leftbottom)(right){label}%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \wdmcoupler(0,1.5)(0,0.5)(3,1){WDM}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% 
% \begin{optionlist}
% \numitem*[0.2]{couplersize} \sizeexplanation[2.5]{\ifGERMAN des Kopplers\fi\ifENGLISH coupler\fi}
% \numitem*[0.1]{couplersep}
% \ifGERMAN Der vertikale Abstand zwischen den beiden Eingangsports.\fi
% \ifENGLISH The vertical distance between the two input ports.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{couplersep}}]
\begin{pspicture}(3,1.5)
  \wdmcoupler[couplersep=0](0,1.5)(0,0.5)(3,1){WDM}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem*[elliptic]{couplertype}{none, elliptic, rectangular}
% \ifGERMAN Wähle zwischen unterschiedlichen Kopplertypen.\fi
% \ifENGLISH Select between different coupler types.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{couplertype}}]
\begin{pspicture}(3,3)
  \psset{labeloffset=0.5}
  \wdmcoupler[couplertype=none](0,3)(0,2)(3,2.5)
  \wdmcoupler[couplertype=rectangular]%
               (0,1.5)(0,0.5)(3,1)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem*[center]{align}{top, bottom, center}
% \ifGERMAN Die Ausrichtung des Kopplers bezüglich der Referenzknoten.\fi
% \ifENGLISH The alignment of the coupler with respect to the reference nodes.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{align}}]
\begin{pspicture}(3,3)
  \psset{labeloffset=0.4}
  \wdmcoupler[align=top,
                couplertype=none](0,3)(0,2)(3,3){top}
  \wdmcoupler[align=bottom]
               (0,1.5)(0,0.5)(3,0.5){bottom}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsubsection{WDM-Teiler}\fi
% \ifENGLISH\subsubsection{WDM splitter}\fi
%
% \begin{ltxsyntax}
% \xLfmultipole{wdmcoupler}%
% \cmditem{wdmsplitter}(left)(righttop)(rightbottom)%
% \cmditem*{wdmsplitter}(left)(righttop)(rightbottom){label}%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \wdmsplitter(0,1)(3,1.5)(3,0.5){WDM}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem*[0.2]{couplersize} \sizeexplanation[2.5]{\ifGERMAN des Kopplers\fi\ifENGLISH coupler\fi}
% \numitem*[0.1]{couplersep} 
% \ifGERMAN Der vertikale Abstand zwischen den beiden Ausgangsports.\fi
% \ifENGLISH The vertical distance between the two output ports.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{couplersep}}]
\begin{pspicture}(3,1.5)
  \wdmsplitter[couplersep=0](0,1)(3,1.5)(3,0.5){WDM}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem*[elliptic]{couplertype}{none, elliptic, rectangular}
% \ifGERMAN Wähle zwischen unterschiedlichen Kopplertypen.\fi
% \ifENGLISH Select between different coupler types.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{couplertype}}]
\begin{pspicture}(3,3)
  \psset{labeloffset=0.5}
  \wdmsplitter[couplertype=none](0,2.5)(3,3)(3,2)
  \wdmsplitter[couplertype=rectangular]%
                 (0,1)(3,1.5)(3,0.5)
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem*[center]{align}{top, bottom, center}
% \ifGERMAN Die Ausrichtung des Kopplers bezüglich der Referenzknoten.\fi
% \ifENGLISH The alignment of the coupler with respect to the reference nodes.\fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{align}}]
\begin{pspicture}(3,3)
  \psset{labeloffset=0.4}
  \wdmsplitter[align=top,
                 couplertype=none](0,3)(3,3)(3,2){top}
  \wdmsplitter[align=bottom](0,0.5)(3,1.5)(3,0.5){bottom}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
% 
% \ifGERMAN\subsubsection{Eingangs- und Ausgangsknoten}\fi
% \ifENGLISH\subsubsection{Input and output nodes}\fi
% \label{sec:coupler-nodes}
%
% \ifGERMAN
% Die Definition der Eingangs- und Ausgangsknoten aus \prettyref{sec:ifcnode}
% ist für die Koppler nicht gültig. Hier werden die Knoten einfach von \opt{1} (links
% oben) bis \opt{N} (rechts unten) durchnummeriert.
% \fi
% \ifENGLISH
% The definition of input and output nodes from \prettyref{sec:ifcnode} is not
% valid for couplers. Here, the nodes are simply numbered from \opt{1} (left
% top) to \opt{N} (right bottom).
% \fi
% \begin{center}
% \begin{pspicture}(11,2)
% \psset{couplersize=0.5, couplertype=rectangular, couplersep=0.2}
% \wdmsplitter(0, 1)(3,2)(3,0)
% \psdot(\oenodeIfc{1}{})\uput[90](\oenodeIfc{1}{}){1}
% \psdot(\oenodeIfc{2}{})\uput[90](\oenodeIfc{2}{}){2}
% \psdot(\oenodeIfc{N}{})\uput[-90](\oenodeIfc{N}{}){N}
% \wdmcoupler(4, 2)(4,0)(7,1)
% \psdot(\oenodeIfc{1}{})\uput[90](\oenodeIfc{1}{}){1}
% \psdot(\oenodeIfc{2}{})\uput[-90](\oenodeIfc{2}{}){2}
% \psdot(\oenodeIfc{N}{})\uput[90](\oenodeIfc{N}{}){N}
% \optcoupler(8,2)(8,0)(11,2)(11,0)
% \psdot(\oenodeIfc{1}{})\uput[90](\oenodeIfc{1}{}){1}
% \psdot(\oenodeIfc{2}{})\uput[-90](\oenodeIfc{2}{}){2}
% \psdot(\oenodeIfc{3}{})\uput[90](\oenodeIfc{3}{}){3}
% \psdot(\oenodeIfc{N}{})\uput[-90](\oenodeIfc{N}{}){N}
% \end{pspicture}
% \end{center}
% 
% \ifGERMAN\chapter{Verbinden von Komponenten}\fi
% \ifENGLISH\chapter{Connecting components}\fi\label{sec:connecting}
% 
% \ifGERMAN 
% Das \nxLPack{pst-optexp}-Paket stellt unterschiedlichen Methoden bereit,
% Komponenten vollautomatisch oder manuell mit Fasern oder Lichtstrahlen zu
% verbinden.
% \fi
% \ifENGLISH
% The \nxLPack{pst-optexp} package provides several methods for automatic and
% manual beam and fiber drawing.  
% \fi
% 
% \begin{itemize}
% \item Section \ref{sec:accessobj} contains detailed information about
%   all possiblities of beam and fiber connections.
% \end{itemize}
%
% \ifGERMAN\section{Zugriff auf Komponenten}\fi
% \ifENGLISH\section{Accessing components}\fi\label{sec:accessobj}
% 
% The arguments of the connection macros, specified as \prm{obj$_1$},
% \prm{obj$_2$}, \ldots \prm{obj$_N$}, can be either \nxLPack{pst-optexp} object
% names (see \prettyref{sec:namingobj} or PSTricks nodes. To distinguish between
% nodes and object names, the node content must be enclosed in parenthesis
% within the brackets.
% 
%
% The components are number in increasing order by their definition in the
% source code, starting with 1.
% 
% \iffalse
%<*ignore>
% \fi
\ifGERMAN
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \pnode(0,1){A}\pnode(1.5,1){B}
  \optbox[endbox, labeloffset=0](A)(B){1}
  % Verbinde eine Komponente unter Verwendung der Nummer
  \drawbeam{(A)}{1}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}
\begin{pspicture}(3,2)
  \psset{endbox, labeloffset=0}
  \optbox[compname=obj](0,1)(1.5,1){obj}
  % Verbinde eine Komponente unter Verwendung seines Namens
  \drawbeam{(0,1)}{obj}
\end{pspicture}
\end{LTXexample}
\fi\ifENGLISH
\begin{LTXexample}
\begin{pspicture}(3,1.5)
  \pnode(0,1){A}\pnode(1.5,1){B}
  \optbox[endbox, labeloffset=0](A)(B){1}
  % connect a component by its automatic number
  \drawbeam{(A)}{1}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}
\begin{pspicture}(3,2)
  \psset{endbox, labeloffset=0}
  \optbox[compname=obj](0,1)(1.5,1){obj}
  % connect a component by its compname
  \drawbeam{(0,1)}{obj}
\end{pspicture}
\end{LTXexample}
\fi
% \iffalse
%</ignore>
% \fi
% 
% \medskip
% If the argument is left empty, the last defined component is used.
% 
% \iffalse
%<*ignore>
% \fi
\ifGERMAN
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psset{endbox, labeloffset=0}
  \optbox(0,0.5)(1.5,0.5){1}
  \optbox(0,1.5)(1.5,1.5){2}
  % Ein leeres Argument bezieht sich auf die zuletzt definierte Komponente
  \drawbeam{(0,1)}{}
\end{pspicture}
\end{LTXexample}
\fi\ifENGLISH
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psset{endbox, labeloffset=0}
  \optbox(0,0.5)(1.5,0.5){1}
  \optbox(0,1.5)(1.5,1.5){2}
  % an empty argument refers to the last defined object
  \drawbeam{(0,1)}{}
\end{pspicture}
\end{LTXexample}
\fi
% \iffalse
%</ignore>
% \fi
%
% Objects which have an explicit \Lkeyword{compname} can also be accessed by
% this name or by their number.
%
% \iffalse
%<*ignore>
% \fi
\ifGERMAN
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psset{endbox, labeloffset=0}
  \optbox[compname=obj](0,0.5)(1.5,0.5){obj, 1}
  \optbox(0,1.5)(1.5,1.5){2}
  % Benannte Komponenten werden auch nummeriert
  \drawbeam{(0,1)}{2}
\end{pspicture}
\end{LTXexample}
\fi\ifENGLISH
\begin{LTXexample}
\begin{pspicture}(3,2)
  \psset{endbox, labeloffset=0}
  \optbox[compname=obj](0,0.5)(1.5,0.5){obj, 1}
  \optbox(0,1.5)(1.5,1.5){2}
  % named objects are also numbered
  \drawbeam{(0,1)}{2}
\end{pspicture}
\end{LTXexample}
\fi
% \iffalse
%</ignore>
% \fi
%
% This is especially useful when connecting a range of components.
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,3)
  \psset{endbox, optboxwidth=0.5, optboxheight=0.5, bssize=0.5}
  \optbox[compname=obj](0.5,0.5)(0.5,2.5){obj, 1}
  \beamsplitter(0.5,2.5)(0.5,1)(2.5,1){2}
  \optbox(0.5,1)(2.5,1){3}
  \drawbeam{1-3}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \section{Drawing beams}\label{sec:drawbeam}
% 
% \begin{ltxsyntax}
%   \xLcs{drawbeam}\cmditem{drawbeam}[options]{obj$_1$}{obj$_2$}{\ldots}{obj$_N$}
%   \xLcs{drawwidebeam}\cmditem{drawwidebeam}[options]{obj$_1$}{obj$_2$}{\ldots}{obj$_N$}
% \end{ltxsyntax}
% The package provides two macros for connecting objects with beams. Most
% parameters are valid for both, those which are specified for wide beams
% are demonstrated separately in the next section.
%
% \begin{ltxsyntax}
%   \xLcs{optplane}\cmditem{optplane}(center)(vec){name}
% \end{ltxsyntax}
% 
% \begin{optionlist}
%   \optitem[0]{beampos}{[\prm{x}] \prm{y}} This is the start position (\prm{x},
%   \prm{y}) of the beam at the first interface. Both values are of \prm{psnum}
%   type. If only one number is given then the $x$-coordinate is set to \opt{0}.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{beampos}}]
\begin{pspicture}(4,3.8)
  \pnode(1.5,0.5){A}\pnode(3.5,0.5){B}
  \pnode(3.5,3.5){C} 
  \optbox[endbox](B)(A){}
  \psset{mirrortype=extended, mirrordepth=0.15}
  \mirror[mirrorradius=3](A)(B)(C){} 
  \mirror(B)(C)(B){} 
  \drawbeam[linecolor=red, beampos=-0.2]{1-3}
  \drawbeam[linecolor=blue, beampos=0]{1-3}
  \drawbeam[linecolor=green, beampos=0.2]{1-3}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[linerange={1-7,9-9}, morekeywords = {[21]{beampos}}, explpreset={escapeinside={}}]
\begin{pspicture*}(0,2)(3.05,6)
  \lens[lens=8 8 8, abspos=0.6](0.5,2)(3,2)
  \optplate[position=1, plateheight=6](0.5,2)(3,2)
  \psset{beampos=2.1}
  \drawbeam[beamangle=-60]{1}{2}
  \drawbeam[beamangle=-40]{1}{2}
  \drawbeam[beamangle=-20]{1}{2}
  \psline[style=Refline, linewidth=3\pslinewidth, arrows=->, arrowinset=0, arrowscale=1.3](\oenodeOut{1})([offset=2.1]\oenodeOut{1})
\end{pspicture*}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \psnumitem[0]{beamangle}
% \ifGERMAN
% Der Anfangswinkel des Strahls. Dieser ist relativ zu der Verbindung von der
% ersten zur zweiten Komponente, mit \Lkeyword{beamangleabs} kann dieser auf
% globale Werte geändert werden.
% \fi
% \ifENGLISH
% This is the start angle of the beam. It is relative to the connection between the first
% two components, use \Lkeyword{beamangleabs} to change this.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{beamangle}}]
\begin{pspicture}(4,4)
  \pnode(1.5,0.5){A}\pnode(3.5,0.5){B}
  \pnode(3.5,3.5){C} 
  \psset{mirrortype=extended, mirrordepth=0.15}
  \optbox[endbox](B)(A){}
  \mirror(A)(B)(C){} 
  \mirror(B)(C)(B){} 
  \drawbeam[linecolor=red, beamangle=3]{-3}
  \drawbeam[linecolor=blue, beamangle=0]{1-}
  \drawbeam[linecolor=green, beamangle=-3]{-}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \boolitem[false]{beamangleabs}
% 
% \boolitem[false]{connectplanes}
% 
% \psnumitem[1.5]{n}
% \ifGERMAN 
% Der relative Brechungsindex der Komponente, der Hintergrund hat einen Index
% von \opt{1}. Der Wert kann pro Komponente oder pro Strahlengang gesetzt
% werden.
% \fi
% \ifENGLISH
% The relative refractive index of the component, the background is set to
% \opt{1}. The value can be set for each component or for one beam ray.
% \fi
%
% \psnumitem[0]{nadd}
% \ifGERMAN \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{nadd, n}}]
\begin{pspicture}(3,3)
  \pnode(0,1.5){A}\pnode(3,1.5){B}
  \lens[lens=4 4 3, n=2, abspos=0.3](A)(B)
  \optplane(B)(0,1){Plane}
  \psset{beampos=0.6}
  \drawbeam[linecolor=red]{(A)}{1}{Plane}
  \drawbeam[linecolor=yellow, nadd=0.5]{(A)}{1}{Plane}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{nadd}}]
\begin{pspicture}(3.8,3)
  \pnode(0,2.5){A}\pnode(1,2.5){B}\pnode(4,1){C}
  \optprism(A)(B)(C)
  \definecolor[ps]{bl}{rgb}{%
    tx@addDict begin Red Green Blue end}%
  \addtopsstyle{Beam}{linecolor=bl, linewidth=0.4\pslinewidth}
  \multido{\i=0+1}{20}{%
    \pstVerb{%
      \i\space 650 400 sub 19 div mul 400 add 
      tx@addDict begin wavelengthToRGB end }%
    \drawbeam[nadd=-2e-3 \i\space mul]{(A)}{1}{(C)}
  }%
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \psnumitem[1]{nmul} 
% \ifGERMAN
% Analog zu \nxLkeyword{nadd}, nur dass der ursprüngliche Brechungsindex mit
% diesem Faktor multipliziert wird. Wenn \nxLkeyword{nadd} und \nxLkeyword{nmul}
% zusammen verwendet werden, wird zuerst die Multiplikation durchgeführt:
% $n_\mathrm{neu} = n_\mathrm{alt}\times n_\mathrm{mul} + n_\mathrm{add}$.
% \fi
% \ifENGLISH
% Like \nxLkeyword{nadd} only that the original refractive index is multiplied
% by this factor. If both \nxLkeyword{nadd} and \nxLkeyword{nmul} are used, the
% multiplication is carried out first: $n_\mathrm{new} = n_\mathrm{old}\times
% n_\mathrm{mul} + n_\mathrm{add}$.
% \fi
%
% \boolitem[true]{beaminside}
% \ifGERMAN
% Zeichne den Strahlengang innerhalb aller Komponenten mit Ausnahme der
% ersten und letzten.
% \fi
% \ifENGLISH
% Draw the internal beams in all components except for the first and last one.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{beaminside}}]
\begin{pspicture}(0.3,0.3)(3,4)
  \psset{optboxwidth=1}
  \optbox[endbox](1,1)(1,3)
  \optretplate(1,1)(1,3)
  \pentaprism(1,3)(1,1)(2,1)
  \optbox[endbox](1,1)(2,1)
  \drawbeam[beampos=-0.05, linecolor=red]{1}{2}{3}{4}
  \drawbeam[beampos=0.05, beaminside=false]{1}{2}{3}{4}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \boolitem[false]{beaminsidefirst}
% \ifGERMAN
% Zeichne den Strahlengang innerhalb der ersten Komponenten.
% \fi
% \ifENGLISH
% Draw the internal beams in the first component.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{beaminsidefirst}}]
\begin{pspicture}(0.3,0.3)(3,4)
  \psset{optboxwidth=1}
  \optbox[endbox](1,1)(1,3)
  \optretplate(1,1)(1,3)
  \pentaprism(1,3)(1,1)(2,1)
  \optbox[endbox](1,1)(2,1)
  \drawbeam[beampos=-0.05, linecolor=red]{1}{2}{3}{4}
  \drawbeam[beampos=0.05, beaminsidefirst]{1}{2}{3}{4}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \boolitem[false]{beaminsidelast}
% \ifGERMAN
% Zeichne den Strahlengang innerhalb der letzten Komponenten.
% \fi
% \ifENGLISH
% Draw the internal beams in the last component.
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{beaminsidelast}}]
\begin{pspicture}(0.3,0.3)(3,4)
  \psset{optboxwidth=1}
  \optbox[endbox](1,1)(1,3)
  \optretplate(1,1)(1,3)
  \pentaprism(1,3)(1,1)(2,1)
  \optbox[endbox](1,1)(2,1)
  \drawbeam[beampos=-0.05, linecolor=red]{1}{2}{3}{4}
  \drawbeam[beampos=0.05, beaminsidelast]{1}{2}{3}{4}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \boolitem[false]{beam}
% \ifGERMAN Kann als Option für jede Komponente verwendet werden, ist äquivalent zu\fi
% \ifENGLISH Can be used as option for every component, is equivalent to the statement\fi
% \begin{lstlisting}
% \drawbeam[connectplanes]{\oenodeRefA{Comp}}{Comp}{\oenodeRefB{Comp}}
% \end{lstlisting}
%
% \valitem{conn}{string}
% \ifGERMAN Diese Option wird nur aus Kompatibilitätsgründen noch bereitgestellt und wird aus zukünftigen Versionen entfernt.\fi
% \ifENGLISH This option is maintained for backward compatibility only and will be removed in future versions.\fi
% \end{optionlist}
% 
% \ifGERMAN\section{Aufgeweitete Strahlen}\fi
% \ifENGLISH\section{Drawing wide beams}\fi
% 
% \begin{ltxsyntax}
%   \xLcs{drawwidebeam}\cmditem{drawwidebeam}[options]{obj$_1$}{obj$_2$}{\ldots}{obj$_N$}
% \end{ltxsyntax}
% \begin{optionlist}
% \numitem[0.1]{beamwidth}
% 
% \numitem[0]{beamdiv}
% \end{optionlist}
%
% \ifGERMAN\section{Fehlerbehandlung}\fi
% \ifENGLISH\section{Error handling}\fi
% \label{sec:error-handling}
%
% \ifGERMAN
% Da alle Strahlen direkt mit Postscript berechnet und gezeichnet werden, ist
% eine umfassende Fehlerbehandlung zur Zeit der Kompilation nicht möglich. Um
% jedoch trotzdem fehlerfreie Bilder zu bekommen, wird der Strahlengang
% abgebrochen, sobald eine Situation eintritt, die nicht unterstützt wird. Das kann
% eintreten, falls der Strahl eine gekrümmte Grenzfläche nicht trifft, oder
% Totalreflektion auftritt.
% \fi
%
% \iffalse
%<*ignore>
% \fi
\ifGERMAN
\begin{LTXexample}
\begin{pspicture}(3,2.7)
  \optplane(0,1)(0,1){A}
  \lens[lens=2 2 2, abspos=2.5](0,1)(3,1)
  \optplane(3,1)(0,1){B}
  \drawbeam{A}{1}{B}
  \drawbeam[beamangle=15]{A}{1}{B}
  % Verfehlt die zweite Grenzfläche, der Strahl wird nur bis zur ersten Grenzfläche gezeichnet.
  \drawbeam[beamangle=28]{A}{1}{B}
  % Verfehlt schon die erste Grenzfläche, kein Strahl wird gezeichnet.
  \drawbeam[beamangle=29]{A}{1}{B}
\end{pspicture}
\end{LTXexample}
\fi\ifENGLISH
\begin{LTXexample}
\begin{pspicture}(3,2.7)
  \optplane(0,1)(0,1){A}
  \lens[lens=2 2 2, abspos=2.5](0,1)(3,1)
  \optplane(3,1)(0,1){B}
  \drawbeam{A}{1}{B}
  \drawbeam[beamangle=15]{A}{1}{B}
  % misses the second interface, draw only until the first interface
  \drawbeam[beamangle=28]{A}{1}{B}
  % misses first interface, skipped completely
  \drawbeam[beamangle=29]{A}{1}{B}
\end{pspicture}
\end{LTXexample}
\fi
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(3,2.5)
  \pnode(0,2){A}\optplane(A)(0,1){A}
  \pnode(4,0){B}\optplane(3,0)(0,1){B}
  \optprism[n=1.8](A)([Xnodesep=2]A)(B)
  \addtopsstyle{Beam}{fillcolor=red, fillstyle=solid, opacity=0.3}
  \drawwidebeam[beamdiv=5]{A}{2}{B}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \section{Custom beams}\label{sec:custombeam}
%
% \ifGERMAN
%
% Im Prinzip können alle Strahlengänge mit passenden Wahl des Brechungsindex und
% der Komponentenparameter (z.B. der Linsenkrümmung) realisiert werden, dass
% kann aber sehr aufwändig werden. Die Endpunkte eines Strahls als Anfangspunkt genutzt werden.
% \fi
% \begin{optionlist}
%   \boolitem[true]{savebeampoints}
%   \boolitem[false]{loadbeampoints}
%   \intitem[0]{skipconn}
% \end{optionlist}
%
% Als Beispiel nehmen wir ein Teleskop, die Strahldivergenz am Eingang und am
% Ausgang ist Null. Anstatt die Linsenparameter und den Brechungsindex genau
% einzustellen, zeichnen wir einfach die drei Strahlenteile mit den
% entsprechenden Parametern. 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{savebeampoints, loadbeampoints}}, linerange={1-9,12-12}]
\begin{pspicture}(4,3)
  \pnode(0,0.5){A}\pnode(2,0.5){B}\pnode(4,3){C}
  \nodexn{(C)-(1.5,0)}{C'}
  \optgrating(A)(B)(C)
  \addtopsstyle{Beam}{fillstyle=solid, fillcolor=green, opacity=0.3}
  \drawwidebeam[beamwidth=0.3]{(A)}{1}
  \psset{savebeampoints=false, loadbeampoints}
  \drawwidebeam{1}{(C)}
  \drawwidebeam{1}{(C')}
  \rput[rb]([Xnodesep=0.3, offset=0.2]C){0. order}
  \rput[rb]([offset=0.2]C'){1. order}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{savebeampoints, loadbeampoints}}]
\begin{pspicture}(4,2) 
  \pnode(0,1){A}\pnode(4,1){B}
  \begin{optexp}
  \lens[lens=0.5 0.5 0.5, abspos=0.5](A)(B)
  \lens[lens=4 4 2, abspos=2](A)(B)
  \addtopsstyle{Beam}{fillstyle=solid, fillcolor=green, opacity=0.3}
  \psset{loadbeampoints}
  \drawwidebeam[beamwidth=0.2, stopinside]{(A)}{1}
  \drawwidebeam[beamdiv=-30]{1}{2}
  \drawwidebeam{2}{(B)}
  \end{optexp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \begin{optionlist}
% \boolitem[false]{startinside}
% 
% \boolitem[false]{stopinside}
% \end{optionlist}
%
% \section{Drawing fibers}\label{sec:drawfiber}
% 
% Fiber-optical components are automatically connected to the reference
% nodes. The style of all fiber connections can be configured
% independently (see \prettyref{fig:fiberstyles}).
%
% This works quiet well if the components are aligned in series, but ceases to
% give good result for more complicated situations (e.g. loop setups). In that
% case individual fibers can be omitted and drawn separately.
%
% \subsection{Automatic fiber connections}\label{sec:drawfiber-auto}
%
% All fiber-optical components described in \prettyref{sec:fibercomp} are
% connected automatically to their reference nodes with \Lcs{pccurve}. The
% styles of the fiber connections can be configured independently by the
% styles shown in \prettyref{fig:fiberstyles}.
%
% \begin{figure}\centering
% \begin{pspicture}(12,4.4)
% \rput[lt](0,4.4){%
%   \pstree[levelsep=1.5cm, treesep=0.6, 
%           nodesep=4pt, arrows=<-, 
%           arrowinset=0, arrowscale=1.5]{\poeTR{Fiber}}{%
%     \pstree{\poeTR{FiberIn}}{%
%       \poeTR{FiberIn1} \poeTR{FiberIn2}%
%     }%
%     \pstree{\poeTR{FiberOut}}{%
%       \poeTR{FiberOut1} \poeTR{FiberOut2}%
%     }%
%   }%
%   \rput[l](-1,0|T-0){\ifGERMAN Grundstil\fi\ifENGLISH parent style\fi}
%   \rput[l](-1,0|T-0-0){%
%     \ifGERMAN\parbox{\widthof{ausgehende Fasern}}{%
%       \RaggedRight eingehende und ausgehende Fasern}\fi
%     \ifENGLISH\parbox{\widthof{outgoing fibers}}{%
%       \RaggedRight incoming and outgoing fibers}\fi}
%   \rput[t](! \psGetNodeCenter{T-0-0-0} \psGetNodeCenter{T-0-0-1}
%      T-0-0-0.x T-0-0-1.x add 2 div T-0-0-0.y 0.4 sub){%
%      \ifGERMAN\parbox{\widthof{Obere(1) oder untere(2)}}{\RaggedRight Obere(1) oder untere(2) eingehende Faser.}\fi
%      \ifENGLISH\parbox{\widthof{Upper(1) or lower(2)}}{\RaggedRight Upper(1) or lower(2) incoming fiber.}\fi}
%   \rput[t](! \psGetNodeCenter{T-0-1-0} \psGetNodeCenter{T-0-1-1}
%      T-0-1-0.x T-0-1-1.x add 2 div T-0-1-0.y 0.4 sub){%
%      \ifGERMAN\parbox{\widthof{Obere(1) oder untere(2)}}{\RaggedRight Obere(1) oder untere(2) ausgehende Faser.}\fi
%      \ifENGLISH\parbox{\widthof{Upper(1) or lower(2)}}{\RaggedRight Upper(1) or lower(2) outgoing fiber.}\fi}
% }%
% \end{pspicture}
% \ifGERMAN
% \caption{Vererbungsdiagramm der PS-Stile für die automatischen
%   Faserverbindungen. Sie sollten diese Stile mit \protect\Lcs{addtopsstyle}
%   ändern um die Vererbungslinie beizubehalten.}%
% \fi
% \ifENGLISH
% \caption{Inheritance diagram for the psstyles used for the automatic fiber
%   connections. These styles should be changed with \protect\Lcs{addtopsstyle}
%   to preserve the inheritance.}%
% \fi
% \label{fig:fiberstyles}
% \xLstyle{Fiber}\label{prm:Fiber}\xLstyle{FiberIn}\label{prm:FiberIn}%
% \xLstyle{FiberIn1}\label{prm:FiberIn1}\xLstyle{FiberIn2}\label{prm:FiberIn2}%
% \xLstyle{FiberOut}\label{prm:FiberOut}\xLstyle{FiberOut1}\label{prm:FiberOut1}%
% \xLstyle{FiberOut2}\label{prm:FiberOut2}%
% \end{figure}
%
% \begin{optionlist}
% \item[\smash{\begin{tabular}[t]{@{}r}\opt{new}\prm{style}\\\opt{addto}\prm{style}\end{tabular}}]
%   \xLkeyword{newFiber}\xLkeyword{addtoFiber}
%   \xLkeyword{newFiberIn}\xLkeyword{addtoFiberIn}
%   \xLkeyword{newFiberIn1}\xLkeyword{addtoFiberIn1}
%   \xLkeyword{newFiberIn2}\xLkeyword{addtoFiberIn2}
%   \xLkeyword{newFiberOut}\xLkeyword{addtoFiberOut}
%   \xLkeyword{newFiberOut1}\xLkeyword{addtoFiberOut1}
%   \xLkeyword{newFiberOut2}\xLkeyword{addtoFiberOut2} For every style two
%   appropriate keys \opt{new}\prm{style} and \opt{addto}\prm{style} are
%   provided which can be used to change the styles for single objects. This
%   can be used to define own components with respectively changed fiber
%   connections or to avoid explicit grouping.
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{addtoFiberOut}}]
\begin{pspicture}(3,2)
   \newpsobject{tapcoupler}{wdmsplitter}{%
     align=bottom, addtoFiberOut1={arrows=->, arrowscale=1.2, arrowinset=0}
   }
   \tapcoupler(0,0.5)(3,1.5)(3,0.5){99/1}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%   \choitem[all]{fiber}{none,in,out,top,bottom,all} Some components can be used either for free-ray or
%   fiber-optical setups (\Lcs{optbox}, \Lcs{optdetector}). The \opt{fiber}
%   parameter enables automatic fiber connections for them.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{fiber}}]
\begin{pspicture}(3,2)
  \optbox[fiber](0,1)(3,1){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%   \choitem[all]{fiberin}{none, top, bottom, all} Choose which input fiber
%   connections to draw automatically. The values \opt{top} and \opt{bottom}
%   affect only \Lcs{optcoupler} and \Lcs{wdmcoupler}.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{fiberin}}]
\begin{pspicture}(3,2)
  \optcoupler[fiberin=top](0,2)(0,0)(3,2)(3,0){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%   \choitem[all]{fiberout}{none, top, bottom, all} Choose which output fiber
%   connections to draw automatically. The values \opt{top} and \opt{bottom}
%   affect only \Lcs{optcoupler} and \Lcs{wdmsplitter}.
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{fiberout}}]
\begin{pspicture}(3,2)
  \wdmsplitter[fiberout=bottom](0,1)(3,2)(3,0){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \end{optionlist}
%
% \minisec{Fiber angles}
%
% The angles of the fiber connections are calculated automatically from the
% orientation of the component. The automatic connections are a special case of
% \Lcs{drawfiber} from a node to a component, see
% \prettyref{sec:drawfiber-manual} for detail.
% 
% \subsection{Manual fiber connections}\label{sec:drawfiber-manual}
%
% \begin{ltxsyntax}
%   \xLcs{drawfiber}\cmditem{drawfiber}[Options]{Obj$_1$}{Obj$_2$}
% \end{ltxsyntax}
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, linerange={1,2,9-11}]
\begin{pspicture}(-1,0)(7,2.4)
  \optbox[fiber, angle=20, rotateref=bl](0,1)(6,1){}
  \psdot(\oenodeRefA{})\uput[180](\oenodeRefA{}){RefA}%
  \psdot(\oenodeRefB{})\uput[0](\oenodeRefB{}){RefB}%
  \psdot(\oenodeRotref{})\uput[-90](\oenodeRotref{}){Rotref}%
  \psdot(\oenodeTrefA{})\uput[180](\oenodeTrefA{}){TrefA}%
  \psdot(\oenodeTrefB{})\uput[0](\oenodeTrefB{}){TrefB}%
  \uput{0.5}[180](\oenodeTrefB{}){\textcolor{black!30}{reference line}}%
  \psset{linecolor=black!30, linestyle=dashed}
  \psline(\oenodeTrefA{})(\oenodeTrefB{})
  \psline(\oenodeRefA{})(\oenodeRefB{})
  \end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, explpreset={linerange={1,2,9-11}}]
\begin{pspicture}(-1,-0.1)(7,3.2)
  \optbox[fiber, angle=-30, rotateref=t, compshift=0.5](0,1)(6,1){}
  \psdot(\oenodeRefA{})\uput[180](\oenodeRefA{}){RefA}%
  \psdot(\oenodeRefB{})\uput[0](\oenodeRefB{}){RefB}%
  \psdot(\oenodeRotref{})\uput[60](\oenodeRotref{}){Rotref}%
  \psdot(\oenodeTrefA{})\uput[180](\oenodeTrefA{}){TrefA}%
  \psdot(\oenodeTrefB{})\uput[0](\oenodeTrefB{}){TrefB}%
  \uput{0.5}[180](\oenodeTrefB{}){\textcolor{black!30}{reference line}}%
  \psset{linecolor=black!30, linestyle=dashed}
  \psline(\oenodeTrefA{})(\oenodeTrefB{})
  \psline(\oenodeRefA{})(\oenodeRefB{})
  \end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \begin{optionlist}
%   \boolitem{relangle}
%   \choitem{startnode}{auto, 1, 2, 3, 4, N}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(4,3)
  \pnode(0,0.5){A}\pnode(2,0.5){B}
  \pnode([offset=1]B){C}\pnode(A|C){D}
  \optamp[fiber=none](A)(B){EDFA}
  \optbox(C)(D){PM}
  \drawfiber[linecolor=black]{1}{2}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \choitem{stopnode}{auto, 1, 2, 3, 4, N}
% \end{optionlist}
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(2.1,3)
\pnode(0,0){A}\pnode(2,0){B}
\pnode(0.3,3){C}\pnode(1.7,3){D}
\optcoupler[fiberout=none,
            addtoFiberIn1={angleA=0, ArrowInside=->},
            addtoFiberIn2={angleA=180, arrows=<-},
            abspos=0.5, compname=Cpl](A)(B)(C)(D){}
\optfiber[fiber=none, compname=Hnlf, abspos=1](C)(C|A){}
\optamp[fiber=none, abspos=2, compname=Amp](D|B)(D){}
\drawfiber{Cpl}{Hnlf}
\drawfiber[startnode=1, stopnode=N, ncurv=1.2]{Hnlf}{Amp}
\drawfiber{Cpl}{Amp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
%
% \ifGERMAN\section{Zeichenebenen}\fi
% \ifENGLISH\section{Layers}\fi
%
% \begin{ltxsyntax}
%   \envitem{optexp}
% \end{ltxsyntax}
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords = {[21]{optexp}}]
\begin{pspicture}(3,4)
\psset{beam, fillstyle=solid, fillcolor=black}
\optbox(0,3.5)(3,3.5){no layers}
\begin{optexp}
  \optbox(0,1.5)(3,1.5){with layers}
\end{optexp}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \begin{ltxsyntax}
%   \cmditem{frontlayer}{code}
%   \cmditem{backlayer}{code}
% \end{ltxsyntax}
% 
% 
% \ifGERMAN\chapter{Zusatzinformationen}\fi
% \ifENGLISH\chapter{Additional information}\fi
% 
% \ifGERMAN
% \section{Benutzerdefinierte Version existierender Komponenten}
% \fi
% \ifENGLISH
% \section{Customized versions of existing components}
% \fi
% \label{sec:customcomp}
% The easiest way to define your own components is to use the
% \Lcs{newpsobject} macro. With this you can define a new component using
% predefined objects with a set of options. These options serve only as
% default values and can be overridden when calling the macro. 
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{newpsobject}}]
\begin{pspicture}(3,1.7)
\newpsobject{sbn}{crystal}{%
  voltage, lamp, %
  fillstyle=solid, fillcolor=yellow!90!black
}
\sbn[label=1.2 45, beam](0,1)(3,1){SBN:Ce}
\end{pspicture}
\end{LTXexample}

\begin{LTXexample}[morekeywords={[21]{newpsobject}}]
\begin{pspicture}(3,1.7) 
\newpsobject{pumpcoupler}{wdmcoupler}{%
  align=top, addtoFiberIn2={ArrowInside=->, arrowscale=2}
}
\pumpcoupler[label=0.5 180](0,1)(0,0)(3,1){Pumpcoupler}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, morekeywords={[21]{newpsobject}}]
\begin{pspicture}(10,2)
\newpsobject{MOLensIn}{lens}{lens=0.5 0.5 0.5}
\newpsobject{MOLensOut}{lens}{lens=1.5 1.5 1.5}
\pnode(0,1){A}\pnode(10,1){B}
\MOLensIn[abspos=1](A)(B)\MOLensOut[abspos=2](A)(B)
\optplate[plateheight=1.5](A)(B)
\MOLensOut[abspos=8](A)(B)\MOLensIn[abspos=9](A)(B)
\addtopsstyle{Beam}{n=1, fillstyle=solid, fillcolor=green, opacity=0.3}
\psset{loadbeampoints}
\drawwidebeam[beamwidth=0.2, stopinside]{(A)}{1}
\drawwidebeam[beamdiv=30]{1}{2}
\drawwidebeam[stopinside]{2-4}
\drawwidebeam[beamdiv=-30]{4}{5}
\drawwidebeam{5}{(B)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \section{Defining new objects}\label{sec:newobj}
% \nxLPack{pst-optexp} provides some high-level macros to
% allow very convenient definition of your own custom components. 
%
% \begin{ltxsyntax}
%   \cmditem{newOptexpDipole}[fixopt]{name}{dftopt}\xLcs{newOptexpDipole}
%   \cmditem{newOptexpTripole}[fixopt]{name}{dftopt}\xLcs{newOptexpTripole}
%   \cmditem{newOptexpFiberDipole}[fixopt]{name}{dftopt}\xLcs{newOptexpFiberDipole}
% \end{ltxsyntax}
%
% These macros generate all organizing code for the components which handle the
% positioning, label placement, rotation and shifting and the layering. In the
% simplest case you only have to define the actual drawing of the component
% outline.
%
% The macro \Lcs{newOptexpDipoleNolabel} is superfluous because since version
% 3.0 the label is optional for all components.
%
% The actual process of creating a new component is split up in different parts,
% depending on the component complexity and user requirements:
% \begin{enumerate}
% \item The component drawing, this is the only required part.
% \item Support for layering (optional).
% \item Support for \Lkeyword{rotateref} and \Lkeyword{extnode} (optional).
% \end{enumerate}
%
% \subsection{The component drawing}
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{newOptexpDipole}}]
\begin{pspicture}(3.5,2.6)
\newOptexpDipole{mydipole}{}
\makeatletter
\def\mydipole@comp{%
  \psaxes[arrows=->](0,0)(0,-1.1)(1.3,1.3)[$x$,90][$y$,0]
}%
\makeatother
\mydipole(0,1)(3.5,1){\color{spot}label}
\drawbeam{(0,1)}{}{(3.5,1)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[morekeywords={[21]{newOptexpTripole}}]
\begin{pspicture}(3.5,3.7)
\newOptexpTripole{mytripole}{labelangle=-60}
\makeatletter
\def\mytripole@comp{%
  \psaxes[arrows=->](0,0)(-1.1,0)(1.3,1.3)[$x$,90][$y$,0]
}%
\makeatother
\mytripole(0,1)(2,1.7)(3,0){\color{spot}label}
\drawbeam{(0,1)}{}{(3,0)}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% \medskip
%
% \subsection{Adding external node}
%
% \subsection{Layering support}
%
% To support layering, the component nodes and the drawings must be separated
% into two macro. \nxLcs{component@nodes} contains the nodes and the Postscript
% definition of the component interfaces. \nxLcs{component@comp} hold only the drawings.
%
%
% \section{Internal component structure}
% 
% In order to understand properly how the automatic beam drawing actually works,
% it is necessary to describe in more detail the internal component structure.
% 
% \begin{optionlist}
% \boolitem[false]{showifcnodes}
% \styleitem{IfcNodeStyle}
% \end{optionlist}
% Every component type consists internally of interfaces which are defined by a
% node on the optical axis, a plane vector or a curvature radius, and by its
% optical characteristic (reflective or transmittive). The interface nodes can be
% visualized for each component type with the \Lkeyword{showifcnodes}
% parameter. 
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(4,3)
  \psset{showifcnodes}
  \optbox(0,2.5)(4,2.5){}
  \doveprism(0,1.5)(4,1.5){}
  \lens(0,0.5)(4,0.5){}
  \mirror(0,0.5)(3.5,0.5)(3.5,3){}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \medskip
% 
% \nxLcs{draw*beam} calculates the distance between the interface nodes of two
% objects and connects the two nearest
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}
\begin{pspicture}(-2,-2)(2,2)
  \psset{optboxwidth=0.6, optboxheight=0.5, labeloffset=0}
  \multido{\i=0+60,\ii=1+1}{6}{%
    \pnode(1.75;\i){A}
    \optbox([Xnodesep=-1]A)([Xnodesep=1]A){\ii}
  }
  \optbox[compname=ref](-1,0)(1,0){ref}
  \addtopsstyle{Beam}{arrows=->}
  \multido{\i=1+1}{6}{\drawbeam{ref}{\i}}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \section{Overview of special nodes}
% \subsection{External and rotation reference nodes}\label{sec:overview-extnode}
%
% \subsection{Reference nodes}\label{sec:overview-refnode}
%
% \subsection{Interface nodes}\label{sec:overview-ifcnode}
% Here, all available components and their interface nodes are listed. If
% a node is labeled as «1, N», it means that both nodes are equal.
% \bgroup \psset{unit=1.2}
% \subsubsection*{Free-ray components}
% \addtopsstyle{Beam}{arrows=->, arrowinset=0, arrowscale=1.5}
% \newcommand{\showdipoleifc}[1]{%
%   \begin{pspicture}(0,-0.5)(3,1) 
%     \pnode(0,0.5){A}\pnode(3,0.5){B}
%     \csname #1\endcsname(A)(B)
%     \drawbeam{(A)}{}{(B)}
%     \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1}
%     \psdot(\oenodeOut{})\uput[-45](\oenodeOut{}){N}
%     \rput[bl](0,-0.4){\ttfamily\textbackslash #1}
%   \end{pspicture}
% }%
% \newcommand{\showdipoleoneifc}[1]{%
%   \begin{pspicture}(0,-0.5)(3,1) 
%     \pnode(0,0.5){A}\pnode(3,0.5){B}
%     \csname #1\endcsname(A)(B)
%     \drawbeam{(A)}{}{(B)}
%     \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1, N}
%     \rput[bl](0,-0.4){\ttfamily\textbackslash #1}
%   \end{pspicture}
% }%
% \showdipoleifc{lens}\hspace{\fill}%
% \showdipoleoneifc{optplate}\hspace{\fill}%
% \showdipoleifc{optretplate}%
% \bigskip
%
% \noindent\showdipoleoneifc{pinhole}\hspace{\fill}%
% \showdipoleifc{crystal}\hspace{\fill}%
% \showdipoleifc{optbox}
% \bigskip
%
% \noindent
% \begin{pspicture}(0, -0.5)(3,1)
%   \pnode(0,0.5){A}\pnode(2.5,0.5){B}
%   \optdetector(A)(B)
%   \drawbeam{(A)}{}
%   \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1, N}
%   \rput[bl](0,-0.4){\ttfamily\textbackslash optdetector}
% \end{pspicture}%
% \hspace{\fill}%
% \bgroup
% \addtopsstyle{Beam}{beaminside=false}%
% \showdipoleifc{optdiode}\egroup%
% \hspace{\fill}%
% \begin{pspicture}(0,-0.5)(3,1) 
%   \pnode(0,0.5){A}\pnode(3,0.5){B}
%   \doveprism(A)(B)
%   \drawbeam[connectplanes]{(A)}{}{(B)}
%   \psdot(\oenodeIn{})\uput[135](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[90](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeOut{})\uput[45](\oenodeOut{}){N}
%   \rput[bl](0,-0.4){\ttfamily\textbackslash doveprism}
% \end{pspicture}%
%
% \begin{pspicture}(3,1.5)
%   \pnode(0,1){A}\pnode(2.5,1){B}\pnode(2.5,0){C}
%   \mirror(A)(B)(C)
%   \drawbeam{(A)}{}{(C)}
%   \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1, N}
%   \rput[bl](0,0){\ttfamily\textbackslash mirror}
% \end{pspicture}%
% \hspace{\fill}%
% \begin{pspicture}(3,1.5) 
%   \pnode(0,1){A}\pnode(1.5,1){B}\pnode(3,0){C}
%   \optprism(A)(B)(C)
%   \drawbeam[connectplanes]{(A)}{}{(C)}
%   \psdot(\oenodeIn{})\uput[135](\oenodeIn{}){1}
%   \psdot(\oenodeOut{})\uput[45](\oenodeOut{}){N}
%   \rput[bl](0,0){\ttfamily\textbackslash optprism}
% \end{pspicture}%
% \hspace{\fill}%
% \begin{pspicture}(3,1.5)
%   \pnode(0,1){A}\pnode(2.5,1){B}\pnode(2.5,0){C}
%   \optgrating(A)(B)(C)
%   \drawbeam{(A)}{}{(C)}
%   \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1, N}
%   \rput[bl](0,0){\ttfamily\textbackslash optgrating}
% \end{pspicture}%
% \bigskip
%
% \noindent
% \begin{pspicture}(3,2.5)
%   \pnode(0,1.5){A}\pnode(2.5,1.5){B}\pnode(2.5,0){C}
%   \beamsplitter[bssize=1.2](A)(B)(C)
%   \drawbeam{(A)}{}{(C)}
%   \psdot(\oenodeIfc{1}{})\uput[135](\oenodeIfc{1}{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[-45](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeIfc{3}{})\uput[0](\oenodeIfc{3}{}){3}
%   \psdot(\oenodeIfc{N}{})\uput[90](\oenodeIfc{N}{}){N}
%   \psdot(\oenodeIfc{C}{})\uput[-135](\oenodeIfc{C}{}){C}
%   \rput[bl](0,0){\ttfamily\textbackslash beamsplitter}
% \end{pspicture}%
% \hspace{\fill}%
% \begin{pspicture}(3,2.5)
%   \pnode(0,2){A}\pnode(2.5,1.5){B}\pnode(0,1){C}
%   \rightangleprism[raprismsize=2](A)(B)(C)
%   \drawbeam[arrows=->, arrowinset=0, arrowscale=1.5]{(A)}{}{(C)}
%   \psdot(\oenodeIn{})\uput[135](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[45](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeIfc{3}{})\uput[-45](\oenodeIfc{3}{}){3}
%   \psdot(\oenodeOut{})\uput[-135](\oenodeOut{}){N}
%   \rput[bl](0,0){\ttfamily\textbackslash rightangleprism}
% \end{pspicture}%
% \hspace{\fill}%
% \begin{pspicture}(3,2.5) 
%   \pnode(0,1.5){A}\pnode(2.1,1.5){B}\pnode(2.1,0){C}
%   \pentaprism[pentaprismsize=1](A)(B)(C)
%   \drawbeam[arrows=->, arrowinset=0, arrowscale=1.5]{(A)}{}{(C)}
%   \psdot(\oenodeIn{})\uput[135](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[0](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeIfc{3}{})\uput[90](\oenodeIfc{3}{}){3}
%   \psdot(\oenodeOut{})\uput[-45](\oenodeOut{}){N}
%   \rput[bl](0,0){\ttfamily\textbackslash pentaprism}
% \end{pspicture}%
%
% \subsubsection*{Fiber components}
% \newcommand{\showfdipoleifc}[1]{%
%   \begin{pspicture}(0,-0.5)(3,1) 
%     \pnode(0,0.5){A}\pnode(3,0.5){B}
%     \csname #1\endcsname(A)(B)
%     \psdot(\oenodeIn{})\uput[-135](\oenodeIn{}){1}
%     \psdot(\oenodeOut{})\uput[-45](\oenodeOut{}){N}
%     \rput[bl](0,-0.4){\ttfamily\textbackslash #1}
%   \end{pspicture}%
% }%
% \addtopsstyle{Fiber}{ArrowInside=->, ArrowInsidePos=0.6, arrowscale=1.5, arrowinset=0}
% \vspace*{5mm}%
% \showfdipoleifc{optfiber}\hspace{\fill}%
% \showfdipoleifc{optamp}\hspace{\fill}%
% \showfdipoleifc{optmzm}%
% \bigskip
%
% \noindent\showfdipoleifc{optfilter}\hspace{\fill}%
% \begin{pspicture}(0,-0.5)(3,1)
%   \pnode(0,0.5){A}\pnode(3,0.5){B}
%   \polcontrol(A)(B)
%   \psdot(\oenodeIn{})\uput[-90](\oenodeIn{}){1, N}
%   \rput[bl](0,-0.4){\ttfamily\textbackslash polcontrol}
% \end{pspicture}\hspace{\fill}%
% \showfdipoleifc{optisolator}%
% \bigskip
%
% \noindent\showfdipoleifc{optswitch}\hspace{\fill}%
% \showfdipoleifc{fiberdelayline}\hspace{\fill}%
% \showfdipoleifc{optfiberpolarizer}%
% \bigskip
%
% \bgroup\psset{beam}
% \noindent\showfdipoleifc{fibercollimator}\egroup
% \bigskip
%
% \noindent
% \begin{pspicture}(0,-0.5)(3,1.5)
%   \pnode(0,0.75){A}\pnode(3,1.5){B}\pnode(3,0){C}
%   \wdmsplitter[couplersize=0.5, couplersep=0.2](A)(B)(C)
%   \psdot(\oenodeIn{})\uput[135](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[90](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeOut{})\uput[-90](\oenodeOut{}){N}
%   \rput[bl](0,-0.4){\ttfamily\textbackslash wdmsplitter}
% \end{pspicture}%
% \hspace{\fill}%
% \begin{pspicture}(0,-0.5)(3,1.5)
%   \pnode(0,1.5){A}\pnode(0,0){B}\pnode(3,0.75){C}
%   \wdmcoupler[couplersize=0.5, couplersep=0.2](A)(B)(C)
%   \psdot(\oenodeIn{})\uput[90](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[-90](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeOut{})\uput[45](\oenodeOut{}){N}
%   \rput[bl](0,-0.4){\ttfamily\textbackslash wdmcoupler}
% \end{pspicture}%
% \hspace{\fill}%
% \begin{pspicture}(0,-0.5)(3,1.5)
%   \pnode(0,1.5){A}\pnode(0,0){B}\pnode(3,1.5){C}\pnode(3,0){D}
%   \optcoupler[couplersize=0.5, couplersep=0.2](A)(B)(C)(D)
%   \psdot(\oenodeIn{})\uput[90](\oenodeIn{}){1}
%   \psdot(\oenodeIfc{2}{})\uput[-90](\oenodeIfc{2}{}){2}
%   \psdot(\oenodeIfc{3}{})\uput[90](\oenodeIfc{3}{}){3}
%   \psdot(\oenodeOut{})\uput[-90](\oenodeOut{}){N}
%   \rput[bl](0,-0.4){\ttfamily\textbackslash optcoupler}
% \end{pspicture}%
% \egroup
%
% \ifGERMAN
%   \chapter{Beispiele}
% \fi
% \ifENGLISH
%   \chapter{Examples}
% \fi
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t,vsep=8mm]
\begin{pspicture}(10,2)
\psset{optboxwidth=1}\addtopsstyle{Beam}{linewidth=2\pslinewidth}
\pnode(1,1){Start}\pnode(9,1){CCD}\optbox[endbox, labeloffset=0](CCD)(Start){Laser}
\optbox[endbox,labeloffset=0,beam](Start)(CCD){CCD}
\polarization[poltype=perp,abspos=0.5](Start)(CCD)
\optretplate[abspos=1](Start)(CCD){$\nicefrac{\lambda}{2}$}
\lens[lens=0.4 0.4 0.5,abspos=2](Start)(CCD){$L_1$}\lens[abspos=4](Start)(CCD){$L_2$}
\optplate[abspos=6,platelinewidth=3\pslinewidth](Start)(CCD){SLM}
\optplate[abspos=6.5,labelangle=180](Start)(CCD){PF}
\polarization[abspos=6.7](Start)(CCD)\lens[abspos=7](Start)(CCD){$L_3$}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \vspace{\fill}
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t,vsep=8mm]
\begin{pspicture}(-4,-1)(3,3)
\psset{labeloffset=0.5}
\pnode(-2,0){LOut}\pnode(0,0){Grat}\pnode(4;45){Out}\pnode(2.5;70){Mvar}
\newpsstyle{Beam}{linewidth=2\pslinewidth, linecolor=red!90!black}
\begin{optexp}
  \optbox[optboxwidth=2, labeloffset=0, endbox](Grat)(LOut){diode laser}
  \mirror[variable](Grat)(Mvar)(Grat){M$_\mathrm{var}$}
  \optretplate[position=0.3, labeloffset=0.8]%
    (LOut)(Grat){$\nicefrac{\lambda}{4}$}
  \optgrating(LOut)(Grat)(Out){grating}
  \drawbeam[arrows=->]{1}{3}{4}{(Out)}
  \drawbeam{2}{4}
\end{optexp}
\rput[l](-3,2){Littman setup}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, vsep=8mm]
\begin{pspicture}(8.5,1.6)
    \addtopsstyle{Beam}{linecolor=green!90!black}
    \pnode(1.6,1){Laser}\pnode(7.6,1){Diode}
    \optbox[endbox,labeloffset=0](Diode)(Laser){Laser}%
    \optbox[abspos=4, optboxwidth=1, optboxheight=0.6, labeloffset=1, compname=PC, angle=-10, rotateref=l, n=2.3](Laser)(Diode){Photonic Crystal}
    \optdetector[dettype=diode](\oenodeOut{PC})(Diode|\oenodeOut{PC}){PD}
    \nodexn{(\oenodeIn{PC}) + (2;170)}{Angle1}
    \psline[linestyle=dashed](\oenodeIn{PC})(Angle1)
    \psarc{<->}(\oenodeIn{PC}){1.3}{330}{30}
    \psarc[arcsep=1pt]{<->}(\oenodeIn{PC}){2}{170}{180}
    \uput{2.1}[175](\oenodeIn{PC}){\small $\varphi$}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, vsep=8mm]
\begin{pspicture}(6.4,3.2)
  \addtopsstyle{Fiber}{linecolor=red}
  \pnode(2.3,2.3){Lin}\pnode([Xnodesep=0.5]Lin){Lout}
  \pnode([Xnodesep=1.5]Lout){EAMout}
  \pnode([Xnodesep=1.5]EAMout){Det}
  \optbox[fiber, label=-0.2, endbox, compname=L, extnode=b](Lout)(Lin){%
    \psGauss[yunit=0.03,sigma=0.03]{-0.5}{0.5}}
  \optbox[fiber, label=0, optboxwidth=1, compname=EAM, extnode=b](Lout)(EAMout){EAM}
  \optfiber[labeloffset=0.3](EAMout)(Det){fibre}
  \optdetector(EAMout)(Det){OSA}
  \pnode([Xnodesep=-1,offset=-1]\oenodeExt{L}){Osc}
  \pnode(\oenodeExt{L}|Osc){PSin}\pnode(\oenodeExt{EAM}|Osc){PSout}
  \oscillator[output=right](Osc){10\,GHz}{}
  \phaseshifter[arrowscale=1.5, inputarrow, labeloffset=-0.7](PSin)(PSout){$\tau$}
  \psset{arrows=->, arrowinset=0, arrowscale=1.5}
  \wire(PSin)(\oenodeExt{L})
  \wire(PSout)(\oenodeExt{EAM})
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, vsep=5mm]
\begin{pspicture}(0.9,0.9)(10.4,5.9)
  \psset{arrowscale=1.5, arrowinset=0}
  \pnode(2,5){PC1in}\pnode(4,5){PC1out}\pnode(6,5){PC2in}
  \pnode(8,5){PC2out}\pnode(2,2){CplSig}\pnode(5,2){CplIn}
  \pnode(2,1){CplOut}\pnode(10,4.5){Pump}\pnode(8,2){PumpSig}
  \optisolator[compshift=0.8, addtoFiberIn={angleA=180}, 
                 addtoFiberOut={angleB=180}, label=0.5 . l]%
                 (CplSig)(PC1in){isolator}
  \polcontrol[addtoFiberIn={arrows=|-}](PC1in)(PC1out){}
  \optfiberpolarizer[labeloffset=0.6](PC1out)(PC2in){polarizer}
  \polcontrol[addtoFiberOut={arrows=-|}](PC2in)(PC2out){}
  \wdmsplitter[labeloffset=0.3, align=bottom, addtoFiberIn={arrows=|-}, 
                 addtoFiberOut1={arrows=->}, addtoFiberOut2={arrows=-|}]%
                 (CplIn)(CplOut)(CplSig){95/5}
  \wdmcoupler[addtoFiberIn1={ArrowInside=->}, addtoFiberIn2={angleA=0}, 
                addtoFiberOut={angleB=0,arrows=-|}, ncurv=0.9, 
                align=bottom, compshift=0.8](Pump)(PC2out)(PumpSig){Pump}
  \optbox[endbox, label=0 . . relative]([offset=-0.1]Pump)(Pump){980~nm}
  \optfiber[fiberloops=2, labeloffset=0.4](CplIn)(PumpSig){Er$^+$-doped}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t]
\begin{pspicture}(0.4,0.1)(9,3.4)
  \pnode(2,3){Laser}\pnode(2,1){PwMeter}
  \pnode(6,3){CplTop}\pnode(6,1){CplBot}
  \psset{arrowscale=1.5, arrowinset=0}
  \optbox[endbox, optboxheight=1, optboxwidth=1.6, labeloffset=0]([Xnodesep=0.1]Laser)(Laser){%
    \begin{tabular}{@{}c@{}}Nd:YAG\\cw laser\end{tabular}}
  \optcoupler[addtoFiberIn1={ArrowInside=->},
              addtoFiberIn2={ArrowInside=-<},
              labeloffset=0.4]%
              (Laser)(PwMeter)(CplTop)(CplBot){WDM}
  \optfiber[addtoFiberOut={ncurv=1, angleB=0},
            addtoFiberIn={ncurv=1, angleA=0}, 
            compshift=-1,
            label=0.2 . l](CplBot)(CplTop){Fiber}
  \optdetector[labelangle=180, dettype=diode]([Xnodesep=0.1]PwMeter)(PwMeter){power meter}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t]
\begin{pspicture}(1,1.2)(6.2,5)
  \pnode(1,4){SigIn}
  \pnode(3,4){BS}
  \pnode(3,5){LO}
  \pnode(5,4){Det1}
  \pnode(3,2){Det2}
  \begin{optexp}
  \optplane(LO)(1,0){LO}
  \beamsplitter[compname=BS](SigIn)(BS)(Det2)
  \lens[abspos=0.5, compname=L2, n=2.1](Det2)(BS)
  \lens[abspos=0.5, compname=L1, n=2.1](Det1)(BS)
  \optdetector[compname=Det1, extnode=c](BS)(Det1){PD1}
  \optdetector[compname=Det2, extnode=c](BS)(Det2){PD2}
  \addtopsstyle{Beam}{beamwidth=0.2, fillstyle=solid, fillcolor=green, opacity=0.2}
  \drawwidebeam{(SigIn)}{BS}{L2}{Det2}
  \drawwidebeam[beaminsidefirst]{BS}{L1}{Det1}
  \newpsstyle{Beam}{linecolor=red, linestyle=dashed, linewidth=1.5\pslinewidth}
  \drawbeam{LO}{BS}{L1}{Det1}
  \drawbeam[beaminsidefirst]{BS}{L2}{Det2}
  \end{optexp}
  \cnodeput([Xnodesep=0.5, offset=-0.5]\oenodeExt{Det1}|\oenodeExt{Det2}){M}{\rule{3mm}{1pt}}
  \nccurve[angleA=90, arrows=<-]{M}{\oenodeExt{Det1}}
  \nccurve[angleA=180, angleB=-90, arrows=<-]{M}{\oenodeExt{Det2}}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t, vsep=8mm]
\makeatletter
\def\LCLV@nodes{%
  \newOptexpComp{ {-0.12 0} {0 1} trans {PlaneIfc}
                  {0.15 0} {0 1} trans {PlaneIfc} \POE@key@n}%
}%
\def\LCLV@comp{%
  \psframe[fillstyle=solid,fillcolor=black,dimen=outer](-0.12,-0.5)(0,0.5)
  \psframe[fillstyle=solid,fillcolor=gray!50,dimen=outer](0,-0.5)(0.15,0.5)
}%
\makeatother
\begin{pspicture}(9,5)
\newOptexpDipole{LCLV}{}\psset{lens=1.2 0 1}
\pnode(2.4,1){BS1}\pnode([offset=3]BS1){M1}\pnode([Xnodesep=5.5]M1){PP}\pnode(PP|BS1){BS2}
\LCLV[position=0.2, compname=LCLV](BS1)(BS2){LCLV}\beamsplitter[compname=BS](BS2)(BS1)(M1){BS}
\optretplate(BS1)(M1){P}\mirror(BS1)(M1)(PP){M}\lens[position=0.2](M1)(PP){L}
\pinhole(M1)(PP){}\lens[position=0.2](PP)(M1){L}\pentaprism(M1)(PP)(BS2){PP}
\beamsplitter(PP)(BS2)(BS1){BS}\lens(BS2)(BS1){L}
\doveprism[compname=Dove,position=0.27](BS2)(BS1){D}
\addtopsstyle{Beam}{arrowscale=1.3, ArrowInside=-<}
\optbox[labeloffset=0, endbox](BS1)([Xnodesep=-1]BS1){Nd:YAG}
\drawbeam{LCLV}{BS}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
% 
% \iffalse
%<*ignore>
% \fi
\begin{LTXexample}[pos=t]
\begin{pspicture}(0,-0.4)(9,6)
  \pnode(1.5,5){Laser}\pnode(4,5){PBS}\pnode(6.5,5){PBS2}
  \pnode(6.5,5.7){piezo}\pnode(4,2){BSFwd}\pnode(6.5,2){BSBwd}
  \pnode(2,2){BS4f}\pnode(2,0.5){M4f3}\pnode(8,2){M4f1}
  \pnode(8,0.5){M4f2}\pnode(1,2){CCD}
  \psset{mirrorwidth=0.6, plateheight=0.7, outerheight=0.7, labeloffset=0.7, labelstyle=\scriptsize, lens=1.2 1.2 0.8, bssize=0.5} 
  \optbox[endbox,optboxwidth=1.5, optboxheight=0.7,labeloffset=0]% 
     (PBS)(Laser){\parbox{1.5cm}{\centering Nd:YAG\\ 532\,nm}}
  \lens[lensheight=0.5, position=0.2](Laser)(PBS){MO}
  \pinhole[position=0.3,labelangle=180](Laser)(PBS){PH}
  \lens[position=0.5](Laser)(PBS){L}
  \optretplate[position=0.8](Laser)(PBS){$\nicefrac{\lambda}{2}$}
  \beamsplitter(Laser)(PBS)(BSFwd){PBS}
  \optretplate[position=0.4](PBS)(BSFwd){$\nicefrac{\lambda}{2}$}
  \polarization(PBS)(BSFwd)\polarization(PBS2)(BSBwd)
  \lens[position=0.8](PBS)(BSFwd){L}
  \optretplate(PBS)(PBS2){$\nicefrac{\lambda}{2}$}
  \beamsplitter(PBS)(PBS2)(piezo){PBS}
  \optretplate[abspos=0.5](PBS2)(piezo){$\nicefrac{\lambda}{4}$}
  \mirror[mirrortype=piezo,labelangle=90](PBS2)(piezo)(PBS2){PZ}
  \lens[position=0.8,labelangle=180](PBS2)(BSBwd){L}
  \crystal[crystalwidth=1, crystalheight=0.5, voltage, lamp, fillstyle=solid, fillcolor=yellow!90!black, labeloffset=0.8](BSFwd)(BSBwd){SBN:Ce}
  \beamsplitter(PBS)(BSFwd)(BSBwd){BS}
  \beamsplitter[labelangle=-90](PBS2)(BSBwd)(BSFwd){BS}
  \mirror(BSBwd)(M4f1)(M4f2){M}\mirror(M4f1)(M4f2)(M4f3){M}
  \lens[labelangle=180](M4f2)(M4f3){L}\mirror(M4f2)(M4f3)(BS4f){M}
  \beamsplitter(M4f3)(BS4f)(CCD){BS}\optbox[endbox,labeloffset=0, optboxwidth=1](BS4f)(CCD){CCD}
  \lens[abspos=0.7](BS4f)(BSFwd){L}\lens[abspos=0.7](BSBwd)(M4f1){L}
  \addtopsstyle{Beam}{linewidth=2\pslinewidth}
  \drawbeam{1-6}{11-14}{13}{12}{15}{18}{16}{17}{25}{23}{24}
  \drawbeam[beaminsidefirst]{6}{7}{10}{17}{16}{18}{26}{19-24}
\end{pspicture}
\end{LTXexample}
% \iffalse
%</ignore>
% \fi
%
% \psset{unit=0.8cm,labelstyle=\footnotesize}
% \begin{pspicture}(0.5,4)(13.2,10.5)
%   \addtopsstyle{Fiber}{linecolor=red!90!black}\psset{usefiberstyle, optboxwidth=1}
%   \pnode(2,10){LD}\pnode([Xnodesep=5.5]LD){CPLin1}
%   \pnode([offset=-2]CPLin1){CPLin2}\pnode([Xnodesep=1.5]CPLin1){CPLout1}
%   \pnode([Xnodesep=1.5]CPLin2){CPLout2}
%   \optbox[endbox, labeloffset=0, fiber]([Xnodesep=0.1]LD)(LD){LD}
%   \optmzm([Xnodesep=0.1]LD)([Xnodesep=1.5]LD){MZM}
%   \optamp([Xnodesep=1.5]LD)([Xnodesep=2.5]LD){EDFA}
%   \optfilter([Xnodesep=2.5]LD)([Xnodesep=3.5]LD){BPF}
%   \optswitch([Xnodesep=3.5]LD)([Xnodesep=4.5]LD){SW}
%   \polcontrol([Xnodesep=4.5]LD)(CPLin1){}
%   \optcoupler[couplertype=none](CPLin1)(CPLin2)(CPLout1)(CPLout2){}
%   \optamp(CPLout1)([Xnodesep=1.5]CPLout1){EDFA}
%   \optfilter([Xnodesep=1.5]CPLout1)([Xnodesep=3]CPLout1){BPF}
%   \pnode([Xnodesep=2]CPLout2){LoopRU}\pnode([offset=-3.5]LoopRU){LoopRL}
%   \pnode([Xnodesep=-5]CPLin2){LoopLU}\pnode([offset=-3.5]LoopLU){LoopLL}
%   \optamp(CPLout2)(LoopRU){EDFA}
%   \psline[linearc=1,style=Fiber](LoopRU)([Xnodesep=1]LoopRU)([Xnodesep=1,offset=-2]LoopRU)
%   \psline[linearc=1,style=Fiber]([Xnodesep=1,offset=1.5]LoopRL)%
%                                 ([Xnodesep=1]LoopRL)(LoopRL)
%   \optfiber[labelalign=b, labeloffset=-1, position=0.8]([Xnodesep=-2]LoopRL)(LoopRL){\begin{tabular}{c}conventional\\fibre 89.8~km\end{tabular}}
%   \optamp([Xnodesep=-2]LoopRL)([Xnodesep=-3]LoopRL){EDFA}
%   \optfilter([Xnodesep=-3]LoopRL)([Xnodesep=-4.5]LoopRL){BPF}
%   \optfiber[fiberloops=1, labeloffset=-1, labelalign=b]([Xnodesep=-7]LoopRL)([Xnodesep=-4.5]LoopRL){DCF 16.2~km}
%   \optamp([Xnodesep=1.5]LoopLL)(LoopLL){EDFA}
%   \psline[style=Fiber,linearc=1](LoopLL)([Xnodesep=-1]LoopLL)%
%                                 ([Xnodesep=-1,offset=3.5]LoopLL)(LoopLU)
%   \optfilter(LoopLU)([Xnodesep=1.5]LoopLU){BPF}
%   \optswitch([Xnodesep=1.5]LoopLU)([Xnodesep=3.5]LoopLU){SW}
%   \polcontrol([Xnodesep=3.5]LoopLU)(CPLin2){}
% \end{pspicture}
% 
%
% \ifGERMAN
% \chapter*{Versionsgeschichte}
% \addcontentsline{toc}{chapter}{Versionsgeschichte}
%
% Diese Versionsgeschichte ist eine Liste von Änderungen, die für den Nutzer des
% Pakets von Bedeutung sind. Änderungen, die eher technischer Natur sind und für
% den Nutzer des Pakets nicht relevant sind und das Verhalten des Pakets nicht
% ändern, werden nicht aufgeführt. Wenn ein Eintrag der Versionsgeschichte ein
% Feature als \emph{improved} oder \emph{extended} bekannt gibt, so bedeutet dies,
% dass eine Modifikation die Syntax und das Verhalten des Pakets nicht
% beeinflusst, oder das es für ältere Versionen kompatibel ist. Einträge, die
% als \emph{modified}, \emph{renamed}, oder \emph{removed} deklariert sind,
% verlangen besondere Aufmerksamkeit. Diese bedeuten, dass eine Modifikation
% Änderungen in bereits existierenden Stilen oder Dokumenten mit sich zieht. Die
% Zahlen an der rechten Seite stehen für die relevante Stelle dieser
% Dokumentation.
% \fi
% \ifENGLISH
% \chapter*{Revision history}
% \addcontentsline{toc}{chapter}{Revision history}
%
% This revision history is a list of changes relevant to users of this
% package. Changes of a more technical nature which do not affect the user
% interface or the behavior of the package are not included in the list. If an
% entry in the revision history states that a feature has been \emph{improved}
% or \emph{extended}, this indicates a modification which either does not affect
% the syntax and behavior of the package or is syntactically backwards
% compatible (such as the addition of an optional argument to an existing
% command). Entries stating that a feature has been \emph{modified},
% \emph{renamed}, or \emph{removed} demand attention. They indicate a
% modification which may require changes to existing styles or documents in
% some, hopefully rare, cases. The numbers on the right indicate the relevant
% section of this manual.
% \fi
%
% \begin{changelog}
%
%   \begin{release}{3.0}{2011-00-00}
%   \item Removed option \opt{labelrelative}\see{sec:labels}
%   \item Removed option \opt{iwidth}\see{cmd:pinhole}
%   \item Removed option \opt{owidth}\see{cmd:pinhole}
%   \item Removed option \opt{bswidth}\see{cmd:beamsplitter}
%   \item Removed option \opt{polwidth}\see{cmd:polarization}
%   \item Removed option \opt{pol}\see{cmd:polarization}
%   \item Removed old lens code\see{cmd:lens}
%   \item Deprecated \cs{newOptexpDipoleNolabel}, use \cs{newOptexpDipole}\see{sec:newobj}
%   \item Extended use of \opt{angle} and \opt{rotateref} to all components\see{sec:rotshift}
%   \item Deprecated option \opt{refractiveindex}\see{sec:drawbeam}
%   \item Renamed option \opt{refractiveindex} to \opt{n}\see{sec:drawbeam}
%   \item Deprecated option \opt{conn}\see{sec:drawbeam}
%   \end{release}
%   \begin{release}{2.1}{2009-11-05}
%   \item Added component \cs{optfiberpolarizer}\see{cmd:optfiberpolarizer}
%   \item Added option \opt{compshift}\see{sec:rotshift}
%   \item Added option \opt{label}\see{sec:labels}
%   \item Added option \opt{connjoin}
%   \item Added options \opt{addtoBeam} and \opt{newBeam}\see{sec:drawbeam}
%   \item Added options \opt{addtoOptComp} and \opt{newOptComp}\see{sec:appearance}
%   \item Added option \opt{bsstyle} to \cs{beamsplitter}\see{cmd:beamsplitter}
%   \item Extended \cs{fibercollimator}\see{cmd:fibercollimator}
%   \item Use pst-doc class for the documentation
%   \item Improved \opt{thicklens} to work with plain lenses\see{cmd:lens}
%   \end{release}
%
%   \begin{release}{2.0}{2008-07-27}
%     \item Added fiber-optical components\see{sec:fibercomp}
%     \item Added component \cs{optdiode}\see{cmd:optdiode}
%     \item Added component \cs{pentaprism}\see{cmd:pentaprism}
%     \item Added component \cs{rightangleprism}\see{cmd:rightangleprism}
%     \item Added component \cs{doveprism}\see{cmd:doveprism}
%     \item Added component \cs{optprism}\see{cmd:optprism}
%     \item Added \cs{drawbeam}\see{sec:drawbeam}
%     \item Added component connections (options \opt{fiber}, \opt{conn} and \opt{beam})\see{sec:connecting}
%     \item Added option \opt{compname}\see{sec:namingobj}
%     \item Added option \opt{extnode}\see{sec:extnode}
%     \item Deprecated \cs{detector}\see{cmd:optdetector}
%     \item Renamed \cs{detector} to \cs{optdetector}\see{cmd:optdetector}
%   \end{release}
%   \begin{release}{1.2}{2008-06-17}
%   \item Modified lens design\see{cmd:lens}
%   \item Added options \opt{lensradiusleft} and \opt{lensradiusright}\see{cmd:lens}
%   \item Added option \opt{thicklens}\see{cmd:lens}
%   \item Added option \opt{lenstype}\see{cmd:lens}
%   \item Added option \opt{mirrorradius} (curved mirrors)\see{cmd:mirror}
%   \item Added option \opt{optgridtype} (binary gratings)\see{cmd:optgrating}
%   \item Added \cs{newOptexpDipole}\see{sec:newobj}
%   \item Added \cs{newOptexpDipoleNolabel}\see{sec:newobj}
%   \item Added \cs{newOptexpTripole}\see{sec:newobj}
%   \item Added \cs{newOptexpFiberDipole}\see{sec:newobj}
%   \item General improvements of \TeX{} and Postscript code
%   \end{release}
%   \begin{release}{1.1}{2007-09-06}
%   \item Improved labeling features\see{sec:labels}
%   \item Added parameter \opt{labelref}\see{sec:labels}
%   \item Replaced \opt{labelrelative} by \opt{labelref=relative}\see{sec:labels}
%   \item Renamed \cs{polarisation} to \cs{polarization}\see{cmd:polarization}
%   \item Renamed \opt{polwidth} to \opt{polsize}\see{cmd:polarization}
%   \item Renamed \opt{pol} to \opt{poltype}\see{cmd:polarization}
%   \item Renamed \opt{bswidth} to \opt{bssize}\see{cmd:beamsplitter}
%   \item Renamed \opt{iwidth} to \opt{innerheight}\see{cmd:pinhole}
%   \item Renamed \opt{owidth} to \opt{outerheight}\see{cmd:pinhole}
%   \item Added support for fillstyle for all components
%   \end{release}
%
%   \begin{release}{1.0}{2007-07-18}
%   \item First CTAN version
%   \end{release}
% \end{changelog}
%
%
% \makeatletter
% \bgroup
% \newcommand*{\index@preamble}{}
% \let\index@preamble=\relax
% \renewcommand{\setindexpreamble}[1]{\def\index@preamble{#1}}
% \renewcommand*{\idx@heading}{%
%   \twocolumn[\idx@@heading{\indexname}]%
%   \@mkboth{\indexname}{\indexname}%
% }
% \renewenvironment{theindex}{%
%   \if@twocolumn
%     \@restonecolfalse
%   \else
%     \@restonecoltrue
%   \fi
%   \columnseprule \z@
%   \columnsep 35\p@
%   \idx@heading%
%   \index@preamble\par\nobreak
%   \thispagestyle{\indexpagestyle}\parindent\z@
%   \setlength{\parskip}{\z@ \@plus .3\p@}%
%   \setlength{\parfillskip}{\z@ \@plus 1fil}%
%   \let\item\@idxitem
% }{%
%   \if@restonecol\onecolumn\else\clearpage\fi
% }
% \renewcommand*\@idxitem{\par\hangindent 40\p@}
% \renewcommand*\subitem{\@idxitem \hspace*{20\p@}}
% \renewcommand*\subsubitem{\@idxitem \hspace*{30\p@}}
% \renewcommand*\indexspace{%
%   \par \vskip 10\p@ \@plus5\p@ \@minus3\p@\relax
% }
% \renewcommand*\indexname{Index}
% \printindex[doc]
% \egroup
% \makeatother
%
% \StopEventually{}
%
% \appendix
%
% \chapter{Implementation}
% \section{The \LaTeX/\TeX\ implementation}
%<*stylefile>
%    \begin{macrocode}
\RequirePackage{pstricks}
\RequirePackage{pst-xkey}
\RequirePackage{pst-node}
\RequirePackage{pst-plot}
\RequirePackage{multido}
\RequirePackage{pst-eucl}
\RequirePackage{pstricks-add}
\RequirePackage{environ}
\long\def\POE@collect#1{%
  \global\POE@oldcnt=\POE@cnt
  \psset[optexp]{optexpenv, backlayer=true, frontlayer=false}#1%
  \gdef\POE@complist{}\global\POE@cnt=\POE@oldcnt\relax
  \psset[optexp]{backlayer=false, frontlayer=true}%
  #1}%
\newenvironment{optexp}{\Collect@Body\POE@collect}{}
\@addtofilelist{pst-optexp.pro}{}%
\csname PSToptexpLoaded\endcsname
\let\PSToptexpLoaded\endinput
\pst@addfams{optexp}
\pstheader{pst-optexp.pro}
\def\pst@optexpdict{tx@OptexpDict begin }
\def\POE@dict#1{\pst@optexpdict #1 end}
\SpecialCoor
%    \end{macrocode}
% IFs for the boolean keys.
%    \begin{macrocode}
\newif\ifPOE@connjoin
\newif\ifPOE@backlayer
\newif\ifPOE@frontlayer
\newif\ifPOE@optexpenv
\newif\ifPOE@variable
\newif\ifPOE@voltage
\newif\ifPOE@caxisinv
\newif\ifPOE@reverse
\newif\ifPOE@lamp
\newif\ifPOE@component@optional
\newif\ifPOE@debug@showoptdots
\newif\ifPOE@debug@showifcnodes
\newif\ifPOE@endbox
\newif\ifPOE@thicklens
\newif\ifPOE@usefiberstyle
\newif\ifPOE@fiber@
\newif\ifPOE@nofiber@
\newif\ifPOE@fiberin@
\newif\ifPOE@fiberin@top
\newif\ifPOE@fiberin@bottom
\newif\ifPOE@fiberout@
\newif\ifPOE@fiberout@top
\newif\ifPOE@fiberout@bottom
\newif\ifPOE@beam
\newif\ifPOE@startinside
\newif\ifPOE@stopinside
\newif\ifPOE@beaminsidefirst
\newif\ifPOE@beaminsidelast
\newif\ifPOE@savebeampoints
\newif\ifPOE@loadbeampoints
\newif\ifPOE@beamangleabs
\newif\ifPOE@beaminside
\newif\ifPOE@connectplanes
\newif\ifPOE@insideobj\POE@insideobjfalse
\newif\ifPOE@globalnoderef
%    \end{macrocode}
% count the components in a pspicture environment
%    \begin{macrocode}
\newcount\POE@cnt
\newcount\POE@oldcnt
%    \end{macrocode}
% count the temporal planes which are created for connections to nodes
%    \begin{macrocode}
\newcount\POE@nodecnt
%    \end{macrocode}
% Fixed strings for choicekeys.
%    \begin{macrocode}
\def\POE@str@pol@polperp{perp}
\def\POE@str@pol@polparallel{parallel}
\def\POE@str@pol@polmisc{misc}
\def\POE@str@pol@polrcirc{rcirc}
\def\POE@str@pol@pollcirc{lcirc}
\def\POE@str@mirrortype@piezo{piezo}
\def\POE@str@mirrortype@plain{plain}
\def\POE@str@mirrortype@extended{extended}
\def\POE@str@gratingtype@blazed{blazed}
\def\POE@str@gratingtype@binary{binary}
\def\POE@str@labelref@relative{relative}
\def\POE@str@labelref@relgrav{relgrav}
\def\POE@str@labelref@global{global}
\def\POE@str@filtertype@bandpass{bandpass}
\def\POE@str@filtertype@bandstop{bandstop}
\def\POE@str@filtertype@lowpass{lowpass}
\def\POE@str@filtertype@highpass{highpass}
\def\POE@str@couplertype@none{none}
\def\POE@str@couplertype@elliptic{elliptic}
\def\POE@str@couplertype@rectangular{rectangular}
\def\POE@str@couplertype@crossswitch{crossswitch}
\def\POE@str@top{top}
\def\POE@str@bottom{bottom}
\def\POE@str@center{center}
\def\POE@str@closed{closed}
\def\POE@str@opened{opened}
\def\POE@str@dettype@round{round}
\def\POE@str@dettype@diode{diode}
\def\POE@str@bsstyle@cube{cube}
\def\POE@str@bsstyle@plate{plate}
\def\POE@str@autonode{auto}
\def\POE@Verb#1{\pst@Verb{\pst@optexpdict #1 end }}%
%    \end{macrocode}
%
% \subsection{Parameter and style definitions}
%    \begin{macrocode}
\newpsstyle{OptComp}{}%
\define@key[psset]{optexp}{newOptComp}{%
  \newpsstyle{OptComp}{#1}%
}
\define@key[psset]{optexp}{addtoOptComp}{%
  \addtopsstyle{OptComp}{#1}%
}
%    \end{macrocode}
% 
%    \begin{macrocode}
\newpsstyle{OptionalStyle}{linestyle=dashed,dash=1.5pt 1pt}%
\newpsstyle{IfcNodeStyle}{linecolor=blue}%
%    \end{macrocode}
% Style for beams drawn with \cs{drawbeam} and \cs{drawwidebeam}
%    \begin{macrocode}
\newpsstyle{Beam}{linecolor=green!90!black,
                  linewidth=\pslinewidth, linejoin=1}%
\define@key[psset]{optexp}{newBeam}{%
  \newpsstyle{Beam}{#1}%
}
\define@key[psset]{optexp}{addtoBeam}{%
  \addtopsstyle{Beam}{#1}%
}
%    \end{macrocode}
% Styles for the automatic fiber connections.
%    \begin{macrocode}
\newpsstyle{Fiber}{}%
\define@key[psset]{optexp}{newFiber}{%
  \newpsstyle{Fiber}{#1}%
}
\define@key[psset]{optexp}{addtoFiber}{%
  \addtopsstyle{Fiber}{#1}%
}
\newpsstyle{FiberIn}{style=Fiber}%
\define@key[psset]{optexp}{newFiberIn}{%
  \newpsstyle{FiberIn}{#1}%
}
\define@key[psset]{optexp}{addtoFiberIn}{%
  \addtopsstyle{FiberIn}{#1}%
}
\newpsstyle{FiberOut}{style=Fiber}%
\define@key[psset]{optexp}{newFiberOut}{%
  \newpsstyle{FiberOut}{#1}%
}
\define@key[psset]{optexp}{addtoFiberOut}{%
  \addtopsstyle{FiberOut}{#1}%
}
\newpsstyle{FiberIn1}{style=FiberIn}%
\define@key[psset]{optexp}{newFiberIn1}{%
  \newpsstyle{FiberIn1}{#1}%
}
\define@key[psset]{optexp}{addtoFiberIn1}{%
  \addtopsstyle{FiberIn1}{#1}%
}
\newpsstyle{FiberIn2}{style=FiberIn}%
\define@key[psset]{optexp}{newFiberIn2}{%
  \newpsstyle{FiberIn2}{#1}%
}
\define@key[psset]{optexp}{addtoFiberIn2}{%
  \addtopsstyle{FiberIn2}{#1}%
}
\newpsstyle{FiberOut1}{style=FiberOut}%
\define@key[psset]{optexp}{newFiberOut1}{%
  \newpsstyle{FiberOut1}{#1}%
}
\define@key[psset]{optexp}{addtoFiberOut1}{%
  \addtopsstyle{FiberOut1}{#1}%
}
\newpsstyle{FiberOut2}{style=FiberOut}%
\define@key[psset]{optexp}{newFiberOut2}{%
  \newpsstyle{FiberOut2}{#1}%
}
\define@key[psset]{optexp}{addtoFiberOut2}{%
  \addtopsstyle{FiberOut2}{#1}%
}
%    \end{macrocode}
% Special styles to change only a part of some devices.
%    \begin{macrocode}
\newpsstyle{ExtendedMirror}{%
  linestyle=none, hatchwidth=0.5\POE@key@mirrorlinewidth,
  hatchsep=1.4\POE@key@mirrorlinewidth, fillstyle=hlines
}%
\newpsstyle{VariableMirror}{%
  linewidth=0.8\pslinewidth, arrowinset=0, arrowscale=0.8, arrows=<->
}
\newpsstyle{PiezoMirror}{fillstyle=solid,fillcolor=black!30}%
\newpsstyle{IsolatorArrow}{linewidth=2\pslinewidth, arrowinset=0}
\newpsstyle{CrystalCaxis}{%
  linestyle=dashed, dash=2pt 2pt, linewidth=0.7\pslinewidth, 
  arrowinset=0, arrows=->
}
\newpsstyle{FdlArrow}{arrowinset=0, arrows=->}
\newpsstyle{VariableCoupler}{arrowinset=0, arrows=->}
%    \end{macrocode}
%
% General parameters
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@component@]{optional}[true]{}
\define@boolkey[psset]{optexp}[POE@]{usefiberstyle}[true]{}
\define@boolkey[psset]{optexp}[POE@debug@]{showoptdots}[true]{}
\define@boolkey[psset]{optexp}[POE@debug@]{showifcnodes}[true]{}
\define@choicekey*[psset]{optexp}{namingscheme}%
  [\val\nr]{old,new}[new]{%
  \ifcase\nr\relax
%    \end{macrocode}
% old naming scheme
%    \begin{macrocode}
    \edef\POE@str@basicname@default{tempNode}
    \edef\POE@str@basicname@prefix{}
    \gdef\POE@str@basicname@sep{Intern}
    \edef\POE@str@extnode@postfix{ExtNode}
  \or
    \edef\POE@str@basicname@default{@}
    \edef\POE@str@basicname@prefix{OE@}
    \gdef\POE@str@basicname@sep{}
    \edef\POE@str@extnode@postfix{Ext}
  \fi
}%
\psset[optexp]{namingscheme=new}%
%    \end{macrocode}
% Positioning
%    \begin{macrocode}
\define@key[psset]{optexp}{position}{%
  \edef\POE@key@position{#1}%
}
\define@key[psset]{optexp}{abspos}{%
  \edef\POE@key@abspos{#1}%
}
\define@key[psset]{optexp}{compshift}{%
  \pst@checknum{#1}\POE@key@compshift
}
\define@key[psset]{optexp}{angle}{%
  \pst@checknum{#1}\POE@key@angle
}
\psset[optexp]{%
  position=\@empty,
  abspos=\@empty,
  compshift=0,
  angle=0
}%
%    \end{macrocode}
% Layering
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@]{backlayer}[true]{}
\define@boolkey[psset]{optexp}[POE@]{frontlayer}[true]{}
\define@boolkey[psset]{optexp}[POE@]{optexpenv}[true]{}
\psset[optexp]{backlayer, frontlayer, optexpenv=false}%
%    \end{macrocode}
% Label
%    \begin{macrocode}
\define@key[psset]{optexp}{labelangle}{%
  \pst@checknum{#1}\POE@key@labelangle
}
\define@key[psset]{optexp}{labeloffset}{%
  \pst@checknum{#1}\POE@key@labeloffset
}
\define@key[psset]{optexp}{labelstyle}{%
  \def\POE@key@labelstyle{#1}%
}
\define@key[psset]{optexp}{labelalign}{%
  \def\POE@key@labelalign{#1}%
}
\define@key[psset]{optexp}{labelref}{%
  \edef\POE@key@labelref{#1}%
}
\define@choicekey*[psset]{optexp}{innerlabel}%
  [\val\nr]{true,false}[true]{%
  \ifcase\nr\relax
    \psset[optexp]{labeloffset=0, labelref=relative}%
  \fi
}%
\define@key[psset]{optexp}{label}{%
  \pst@expandafter\POE@psset@@label{#1} {} {} {} {} {}\@nil
}%
\def\POE@psset@@label#1 #2 #3 #4 #5\@nil{%
  \edef\POE@temp{#4}%
  \ifx\POE@temp\@empty\else
    \expandafter\ifx\POE@temp.\else
      \psset[optexp]{labelref=#4}%
    \fi
  \fi
  \edef\POE@temp{#3}
  \ifx\POE@temp\@empty\else
    \expandafter\ifx\POE@temp.\else
      \psset[optexp]{labelalign=#3}%
    \fi
  \fi
  \edef\POE@temp{#2}%
  \ifx\POE@temp\@empty\else
    \expandafter\ifx\POE@temp.\else
      \psset[optexp]{labelangle=#2}%
    \fi
  \fi
  \edef\POE@temp{#1}%
  \ifx\POE@temp\@empty\else
    \expandafter\ifx\POE@temp.\else
      \psset[optexp]{labeloffset=#1}%
    \fi
  \fi
}%
%    \end{macrocode}
% for internal use only! Set the reference angle for the \opt{labelangle} parameter.
%    \begin{macrocode}
\define@key[psset]{optexp}{ref@angle}{%
  \pst@checknum{#1}\POE@key@labelrefangle
}%
\psset[optexp]{%
  labeloffset=0.8,
  labelangle=0,
  labelstyle=,
  labelalign=c,
  labelref=relgrav,
  ref@angle=0
}%
\define@key[psset]{optexp}{lensheight}{%
  \pst@checknum{#1}\POE@key@lensheight
}
\define@key[psset]{optexp}{lenswidth}{%
  \pst@checknum{#1}\POE@key@lenswidth
  \ifdim\POE@key@lenswidth pt > 0pt
    \psset[optexp]{thicklens=true}
  \fi
}
\define@key[psset]{optexp}{lensradiusleft}{%
  \pst@checknum{#1}\POE@key@lensradiusleft
}
\define@key[psset]{optexp}{lensradiusright}{%
  \pst@checknum{#1}\POE@key@lensradiusright
}
\define@boolkey[psset]{optexp}[POE@]{thicklens}[true]{}
\define@key[psset]{optexp}{lensradius}{%
  \edef\POE@temp{#1}%
  \ifx\POE@temp\@empty\else
    \psset[optexp]{lensradiusleft=#1, lensradiusright=#1}%
  \fi
}%
\define@key[psset]{optexp}{lens}{%
  \pst@expandafter\POE@psset@@lens{#1} {} {} {} {} {}\@nil
}%
\def\POE@psset@@lens#1 #2 #3 #4 #5\@nil{%
  \edef\POE@temp{#4}%
  \ifx\POE@temp\@empty\else
     \psset[optexp]{lenswidth=#4}%
  \fi
  \edef\POE@temp{#3}%
  \ifx\POE@temp\@empty\else
     \psset[optexp]{lensheight=#3}
  \fi
  \edef\POE@temp{#2}%
  \ifx\POE@temp\@empty
     \psset[optexp]{lensradiusright=#1}%
  \else
     \psset[optexp]{lensradiusright=#2}%
  \fi
  \psset[optexp]{lensradiusleft=#1}%
}%
\psset[optexp]{%
  lenswidth=0,
  lensheight=1,
  lensradiusleft=1,
  lensradiusright=1
}%
%    \end{macrocode}
% Pinhole
%    \begin{macrocode}
\define@key[psset]{optexp}{innerheight}{%
  \pst@checknum{#1}\POE@key@innerheight
}
\define@key[psset]{optexp}{outerheight}{%
  \pst@checknum{#1}\POE@key@outerheight
}
\define@key[psset]{optexp}{phlinewidth}{%
  \edef\POE@key@phlinewidth{#1}%
}
\define@key[psset]{optexp}{phwidth}{%
  \edef\POE@key@phwidth{#1}%
}
\psset[optexp]{%
  phlinewidth=2\pslinewidth,
  phwidth=0,
  outerheight=1,
  innerheight=0.1
}%
%    \end{macrocode}
% Crystal
%    \begin{macrocode}
\define@key[psset]{optexp}{crystalwidth}{%
  \pst@checknum{#1}\POE@key@crystalwidth
}
\define@key[psset]{optexp}{crystalheight}{%
  \pst@checknum{#1}\POE@key@crystalheight
}
\define@key[psset]{optexp}{caxislength}{%
  \pst@checknum{#1}\POE@key@caxislength
}
\define@boolkey[psset]{optexp}[POE@]{voltage}[true]{}
\define@boolkey[psset]{optexp}[POE@]{caxisinv}[true]{}
\define@boolkey[psset]{optexp}[POE@]{lamp}[true]{}
\define@key[psset]{optexp}{lampscale}{%
  \pst@checknum{#1}\POE@key@lampscale
}
\psset[optexp]{%
  crystalwidth=1.4,
  crystalheight=0.6,
  caxislength=0.6,
  lampscale=0.3
}%
%    \end{macrocode}
% Box
%    \begin{macrocode}
\define@key[psset]{optexp}{optboxwidth}{%
  \pst@checknum{#1}\POE@key@optboxwidth
}
\define@key[psset]{optexp}{optboxheight}{%
  \pst@checknum{#1}\POE@key@optboxheight
}
\define@boolkey[psset]{optexp}[POE@]{endbox}[true]{}
\psset[optexp]{%
  optboxwidth=1.4,
  optboxheight=0.8
}%
%    \end{macrocode}
% Plate
%    \begin{macrocode}
\define@key[psset]{optexp}{platelinewidth}{%
  \edef\POE@key@platelinewidth{#1}%
}
\define@key[psset]{optexp}{plateheight}{%
  \pst@checknum{#1}\POE@key@plateheight
}
\psset[optexp]{%
  plateheight=1,
  platelinewidth=2\pslinewidth
}%
%    \end{macrocode}
% Optical Retardation Plate
%    \begin{macrocode}
\define@key[psset]{optexp}{platewidth}{%
  \pst@checknum{#1}\POE@key@platewidth
}
\psset[optexp]{platewidth=0.1}%
%    \end{macrocode}
% Detector
%    \begin{macrocode}
\define@key[psset]{optexp}{detsize}{%
  \pst@checknum{#1}\POE@key@detsize
}
\define@choicekey*+[psset]{optexp}{dettype}[\val\nr]{round,diode}%
   {\edef\POE@key@dettype{\val}}
   {\PackageError{pst-optexp}{Unknown dettype '\val'}}
\psset[optexp]{%
  detsize=0.8,
  dettype=round
}%
%    \end{macrocode}
% Polarization
%    \begin{macrocode}
\define@key[psset]{optexp}{polsize}{%
  \pst@checknum{#1}\POE@key@polsize
}
\define@key[psset]{optexp}{pollinewidth}{%
  \edef\POE@key@pollinewidth{#1}%
  \PackageWarning{pst-optexp}{%
    Parameter pollinewidth is deprecated, \MessageBreak
    use style Polarization.}%
}%
\def\POE@key@pollinewidth{0.7\pslinewidth}%
\newpsstyle{Polarization}{%
  linestyle=solid, linewidth=\POE@key@pollinewidth, 
  arrowscale=0.8, dotsize=3\pslinewidth
}
\define@choicekey+[psset]{optexp}{poltype}%
  [\val\nr]{parallel,misc,perp,rcirc,lcirc}%
  {\edef\POE@key@poltype{#1}}
  {\PackageError{pst-optexp}{Unknown poltype '\val'}}
\psset[optexp]{%
  poltype=parallel,
  polsize=0.6
}%
%    \end{macrocode}
% Optical Diode
%    \begin{macrocode}
\define@key[psset]{optexp}{optdiodesize}{%
  \pst@checknum{#1}\POE@key@optdiodesize
}
\psset[optexp]{optdiodesize=0.8}%
%    \end{macrocode}
% Dove Prism
%    \begin{macrocode}
\define@key[psset]{optexp}{doveprismsize}{%
  \pst@checknum{#1}\POE@key@doveprismsize
}
\psset[optexp]{doveprismsize=0.6}%
%    \end{macrocode}
% Beamsplitter
%    \begin{macrocode}
\define@key[psset]{optexp}{bssize}{%
  \pst@checknum{#1}\POE@key@bssize
}
\define@key[psset]{optexp}{bsstyle}{%
  \edef\POE@key@bsstyle{#1}%
}
\psset[optexp]{%
  bssize=0.8,
  bsstyle=cube
}%
%    \end{macrocode}
% Mirror
%    \begin{macrocode}
\define@key[psset]{optexp}{mirrorwidth}{%
  \pst@checknum{#1}\POE@key@mirrorwidth
}
\define@key[psset]{optexp}{mirrorlinewidth}{%
  \edef\POE@key@mirrorlinewidth{#1}%
}
\define@choicekey*[psset]{optexp}{mirrortype}%
  [\val\nr]{piezo,extended,plain}{%
  \edef\POE@key@mirrortype{#1}%
}
\define@key[psset]{optexp}{mirrordepth}{%
  \pst@checknum{#1}\POE@key@mirrordepth
}
\define@key[psset]{optexp}{mirrorradius}{%
  \pst@checknum{#1}\POE@key@mirrorradius
}
\define@boolkey[psset]{optexp}[POE@]{variable}[true]{}
\psset[optexp]{%
  mirrorwidth=1,
  mirrordepth=0.1,
  mirrorradius=0,
  mirrortype=plain,
  mirrorlinewidth=2\pslinewidth,
  variable=false
}%
%    \end{macrocode}
% Grating
%    \begin{macrocode}
\define@key[psset]{optexp}{optgridcount}{%
  \pst@checknum{#1}\POE@key@gratingcount
  \PackageWarning{pst-optexp}{%
    Parameter optgridcount is deprecated,\MessageBreak
    use gratingcount instead.}%
}%
\define@key[psset]{optexp}{optgridwidth}{%
  \pst@checknum{#1}\POE@key@gratingwidth
  \PackageWarning{pst-optexp}{%
    Parameter optgridwidth is deprecated,\MessageBreak
    use gratingwidth instead.}%
}%
\define@key[psset]{optexp}{optgridheight}{%
  \pst@checknum{#1}\POE@key@gratingheight
  \PackageWarning{pst-optexp}{%
    Parameter optgridheight is deprecated,\MessageBreak
    use gratingheight instead.}%
}%
\define@choicekey*[psset]{optexp}{optgridtype}%
  [\val\nr]{binary,blazed}{%
  \edef\POE@key@gratingtype{#1}%
  \PackageWarning{pst-optexp}{%
    Parameter optgridtype is deprecated,\MessageBreak
    use gratingtype instead.}%
}%
\define@key[psset]{optexp}{optgriddepth}{%
  \pst@checknum{#1}\POE@key@gratingdepth
  \PackageWarning{pst-optexp}{%
    Parameter optgriddepth is deprecated,\MessageBreak
    use gratingdepth instead.}%
}%
\define@key[psset]{optexp}{optgridlinewidth}{%
  \edef\POE@key@gratinglinewidth{#1}%
  \PackageWarning{pst-optexp}{%
    Parameter optgridlinewidth is deprecated,\MessageBreak
    use gratinglinewidth instead.}%
}%
\define@key[psset]{optexp}{gratingcount}{%
  \pst@checknum{#1}\POE@key@gratingcount
}
\define@key[psset]{optexp}{gratingwidth}{%
  \pst@checknum{#1}\POE@key@gratingwidth
}
\define@key[psset]{optexp}{gratingheight}{%
  \pst@checknum{#1}\POE@key@gratingheight
}
\define@choicekey*[psset]{optexp}{gratingtype}%
  [\val\nr]{binary,blazed}{%
  \edef\POE@key@gratingtype{#1}%
}
\define@key[psset]{optexp}{gratingdepth}{%
  \pst@checknum{#1}\POE@key@gratingdepth
}
\define@key[psset]{optexp}{gratinglinewidth}{%
  \edef\POE@key@gratinglinewidth{#1}%
}
\define@boolkey[psset]{optexp}[POE@]{reverse}[true]{}
\psset[optexp]{%
  gratingcount=10,
  gratingwidth=1,
  gratingheight=0.15,
  gratingdepth=0.075,
  gratingtype=blazed,
  gratinglinewidth=0.7\pslinewidth,
  reverse=false
}%
\define@key[psset]{optexp}{refractiveindex}{%
  \pst@checknum{#1}\POE@key@n%
  \PackageWarning{pst-optexp}{%
    Option 'refractiveindex' is deprecated,\MessageBreak
    use 'n' instead}%
}%
\define@key[psset]{optexp}{n}{%
  \pst@checknum{#1}\POE@key@n
}
\define@key[psset]{optexp}{nmul}{%
  \edef\POE@key@nmul{#1}%
}
\define@key[psset]{optexp}{nadd}{%
  \edef\POE@key@nadd{#1}%
}
\psset[optexp]{%
  n=1.5,
  nmul=1,
  nadd=0
}%
%    \end{macrocode}
% Penta Prism
%    \begin{macrocode}
\define@key[psset]{optexp}{pentaprismsize}{%
  \pst@checknum{#1}\POE@key@pentaprismsize
}
\psset[optexp]{pentaprismsize=0.7}
%    \end{macrocode}
% Right-Angle Prism
%    \begin{macrocode}
\define@key[psset]{optexp}{raprismsize}{%
  \pst@checknum{#1}\POE@key@raprismsize
}
\psset[optexp]{raprismsize=1.5}
%    \end{macrocode}
% Prism
%    \begin{macrocode}
\define@key[psset]{optexp}{prismsize}{%
  \pst@checknum{#1}\POE@key@prismsize
}
\define@key[psset]{optexp}{prismangle}{%
  \pst@checknum{#1}\POE@key@prismangle
}
\psset[optexp]{%
  prismsize=1,
  prismangle=60
}%
%    \end{macrocode}
% Fiber
%    \begin{macrocode}
\define@key[psset]{optexp}{fiberloops}{%
  \pst@checknum{#1}\POE@key@fiberloops
}
\define@key[psset]{optexp}{fiberloopradius}{%
  \pst@checknum{#1}\POE@key@fiberloopradius
}
\define@key[psset]{optexp}{fiberloopsep}{%
  \pst@checknum{#1}\POE@key@fiberloopsep
}
\psset[optexp]{%
  fiberloops=3,
  fiberloopradius=0.4,
  fiberloopsep=0.3
}%
%    \end{macrocode}
% Filter
%    \begin{macrocode}
\define@key[psset]{optexp}{filtersize}{%
  \pst@checknum{#1}\POE@key@filtersize
}
\define@choicekey+[psset]{optexp}{filtertype}[\val\nr]%
   {bandstop,bandpass,lowpass,highpass}%
   {\edef\POE@key@filtertype{#1}}%
   {\PackageError{pst-optexp}{Unknown filtertype '\val'}}
\psset[optexp]{%
  filtersize=0.8,
  filtertype=bandpass
}%
%    \end{macrocode}
% Polarization controller
%    \begin{macrocode}
\define@key[psset]{optexp}{polcontrolsize}{%
  \pst@checknum{#1}\POE@key@polcontrolsize
}
\psset[optexp]{polcontrolsize=0.15}%
%    \end{macrocode}
% Optical amplifier
%    \begin{macrocode}
\define@key[psset]{optexp}{optampsize}{%
  \pst@checknum{#1}\POE@key@optampsize
}
\psset[optexp]{optampsize=0.8}
%    \end{macrocode}
% Mach-Zehnder modulator
%    \begin{macrocode}
\define@key[psset]{optexp}{optmzmsize}{%
  \pst@checknum{#1}\POE@key@optmzmsize
}
\psset[optexp]{optmzmsize=0.8}
%    \end{macrocode}
% Isolator
%    \begin{macrocode}
\define@key[psset]{optexp}{isolatorsize}{%
  \pst@checknum{#1}\POE@key@isolatorsize
}
\psset[optexp]{isolatorsize=0.6}%
%    \end{macrocode}
% Fiber polarizer
%    \begin{macrocode}
\define@key[psset]{optexp}{fiberpolsize}{%
  \pst@checknum{#1}\POE@key@fiberpolsize
}
\psset[optexp]{fiberpolsize=0.6}%
%    \end{macrocode}
% Optical switch
%    \begin{macrocode}
\define@key[psset]{optexp}{switchsize}{%
  \pst@checknum{#1}\POE@key@switchsize
}
\define@choicekey+[psset]{optexp}{switchstyle}%
  [\val\nr]{opened,closed}%
  {\edef\POE@key@switchstyle{#1}}%
  {\PackageError{pst-optexp}{Unknown switchstyle '\val'}}
\psset[optexp]{%
  switchsize=0.8,
  switchstyle=opened
}%
%    \end{macrocode}
% Fiber delay line
%    \begin{macrocode}
\define@key[psset]{optexp}{fdlsize}{%
  \pst@checknum{#1}\POE@key@fdlsize
}
\psset[optexp]{fdlsize=0.6}%
%    \end{macrocode}
% Fiber collimator 
%    \begin{macrocode}
\define@key[psset]{optexp}{fibercolsize}{%
  \pst@checknum{#1}\POE@key@fibercolsize
}
\psset[optexp]{fibercolsize=0.3}%
%    \end{macrocode}
% Coupler
%    \begin{macrocode}
\define@key[psset]{optexp}{couplersize}{%
  \pst@checknum{#1}\POE@key@couplersize
}
\define@key[psset]{optexp}{couplersep}{%
  \pst@checknum{#1}\POE@key@couplersep
}
\define@choicekey+[psset]{optexp}{couplertype}%
  [\val\nr]{none,elliptic,crossswitch,rectangular}%
  {\edef\POE@key@couplertype{#1}}%
  {\PackageError{pst-optexp}{Unknown couplertype '\val'}}
\define@key[psset]{optexp}{align}{%
  \edef\POE@key@align{#1}%
}
\psset[optexp]{%
  couplersize=0.2,
  couplersep=0.05,
  align=center,
  couplertype=elliptic
}%
%    \end{macrocode}
% External node
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@]{globalnoderef}[true]{}%
%    \end{macrocode}
% (this part was copied and adapted from \cs{psset@@ref} from pstricks.tex)
%    \begin{macrocode}
\define@key[psset]{optexp}{extnode}{%
   \edef\POE@key@extnode{#1}%
   \ifx\@empty\POE@key@extnode\else
      \pst@expandafter\POE@psset@@extnode{#1}\@empty,,\@nil
   \fi
}%
\psset[optexp]{%
  extnode=\@empty, 
  globalnoderef=true
}%
\def\POE@key@extnode@xref{0}%
\def\POE@key@extnode@yref{0}%
\def\POE@psset@@extnode#1#2,#3,#4\@nil{%
  \def\POE@key@extnode@xref{0}%
  \def\POE@key@extnode@yref{0}%
  \ifx\@empty#3\@empty
    \@nameuse{POE@getref@#1}%
    \@nameuse{POE@getref@#2}%
  \else
    \pst@checknum{#1#2}\POE@key@extnode@xref%
    \pst@checknum{#3}\POE@key@extnode@yref%
  \fi}%
\def\POE@getref@c{}%
\def\POE@getref@t{\def\POE@key@extnode@yref{1}}%
\def\POE@getref@b{\def\POE@key@extnode@yref{-1}}%
\def\POE@getref@l{\def\POE@key@extnode@xref{-1}}%
\def\POE@getref@r{\def\POE@key@extnode@xref{1}}%
\define@key[psset]{optexp}{rotateref}{%
   \def\POE@temp{#1}%
   \ifx\@empty\POE@temp\else
      \pst@expandafter\POE@psset@@rotateref{#1}\@empty,,\@nil
   \fi
}%
\def\POE@key@rotate@xref{0}%
\def\POE@key@rotate@yref{0}%
\def\POE@psset@@rotateref#1#2,#3,#4\@nil{%
  \def\POE@key@rotate@xref{0}%
  \def\POE@key@rotate@yref{0}%
  \ifx\@empty#3\@empty
    \@nameuse{POE@getref@rotate@#1}%
    \@nameuse{POE@getref@rotate@#2}%
  \else
    \pst@checknum{#1#2}\POE@key@rotate@xref%
    \pst@checknum{#3}\POE@key@rotate@yref%
  \fi}%
\def\POE@getref@rotate@c{}%
\def\POE@getref@rotate@t{\def\POE@key@rotate@yref{1}}%
\def\POE@getref@rotate@b{\def\POE@key@rotate@yref{-1}}%
\def\POE@getref@rotate@l{\def\POE@key@rotate@xref{-1}}%
\def\POE@getref@rotate@r{\def\POE@key@rotate@xref{1}}%
\psset[optexp]{rotateref=c}%
%    \end{macrocode}
%    \begin{macrocode}
\define@key[psset]{optexp}{b@sicname}{%
  \edef\POE@key@b@sicname{\POE@str@basicname@prefix#1}%
}%
%    \end{macrocode}
% List with all component names define until now. Is kept for a single pspicture environment
%    \begin{macrocode}
\gdef\POE@complist{}%
\g@addto@macro{\endpspicture}{%
  \POE@Verb{%
    /lastBeamPointUp /lastBeamPointLow /lastBeamPoint 
    3 { currentdict exch undef } repeat 
    /N@\oenodeBeam\space /N@\oenodeBeamUp\space /N@\oenodeBeamLow\space
    3 { tx@NodeDict exch undef } repeat
  }%
  \gdef\POE@complist{}\global\POE@cnt=0\relax
}%
\define@key[psset]{optexp}{compname}{%
  \ifPOE@insideobj\else
    \PackageError{pst-optexp}{compname allowed only inside an object}
  \fi
  \edef\POE@temp{#1}%
  \ifx\POE@temp\@empty
    \edef\POE@key@compname{\the\POE@cnt}%
  \else
    \edef\POE@key@compname{#1}%
  \fi
%    \end{macrocode}
% check if compname was already defined
%    \begin{macrocode}
  \@expandtwoargs\in@{,\POE@key@compname,}{,\POE@complist,}%
  \ifin@
    \PackageWarning{pst-optexp}{%
      ^^Jcompname '\POE@key@compname' already used,\MessageBreak
      previous nodes will be overwritten!^^J
    }%
  \else
%    \end{macrocode}
%
% Use definition of \cs{XKV@addtolist@x} with an \cs{xdef} instead of \cs{edef} in order to keep the bookkeeping global
%    \begin{macrocode}
    \xdef\POE@complist{%
      \POE@key@compname\ifx\POE@complist\@empty\else,\fi\POE@complist
    }%
  \fi
}%
\POE@insideobjtrue
\psset[optexp]{compname=\@empty}
\POE@insideobjfalse
%    \end{macrocode}
% Connect a component directly with its reference nodes using \cs{drawbeam}.
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@]{beam}[true]{}
%    \end{macrocode}
%
% Select which fibers are drawn automatically.
%    \begin{macrocode}
\define@choicekey*[psset]{optexp}{fiber}%
  [\val\nr]{none,in,out,top,bottom,all}[all]{%
  \ifcase\nr\relax
    \psset[optexp]{fiber@=false, nofiber@, fiberin=none, fiberout=none}
  \or
    \psset[optexp]{fiberin, fiberout=none}
  \or
    \psset[optexp]{fiberin=none, fiberout}
  \or
    \psset[optexp]{fiberin=top, fiberout=top}
  \or
    \psset[optexp]{fiberin=bottom, fiberout=bottom}
  \or
    \psset[optexp]{fiberin, fiberout}
  \fi
}%
%    \end{macrocode}
% Select which input fibers are drawn directly
%    \begin{macrocode}
\define@choicekey*[psset]{optexp}{fiberin}%
  [\val\nr]{none,top,bottom,all}[all]{%
  \ifcase\nr\relax
    \psset[optexp]{%
      fiberin@=false, 
      fiberin@top=false, fiberin@bottom=false
    }
  \or
    \psset[optexp]{%
      fiber@, fiberin@, nofiber@=false,
      fiberin@top, fiberin@bottom=false
    }
  \or
    \psset[optexp]{%
      fiber@, fiberin@, nofiber@=false,
      fiberin@top=false, fiberin@bottom
    }
  \or
    \psset[optexp]{%
      fiber@, fiberin@, nofiber@=false,
      fiberin@top, fiberin@bottom
    }
  \fi
}%
%    \end{macrocode}
% Select which output fibers are drawn directly
%    \begin{macrocode}
\define@choicekey*[psset]{optexp}{fiberout}%
  [\val\nr]{none,top,bottom,all}[all]{%
  \ifcase\nr\relax
    \psset[optexp]{%
      fiberout@=false,
      fiberout@top=false, fiberout@bottom=false
    }
  \or
    \psset[optexp]{%
      fiber@, fiberout@, nofiber@=false,
      fiberout@top, fiberout@bottom=false
    }
  \or
    \psset[optexp]{%
      fiber@, fiberout@, nofiber@=false,
      fiberout@top=false, fiberout@bottom=true
    }
  \or
    \psset[optexp]{%
      fiber@, fiberout@, nofiber@=false,
      fiberout@top, fiberout@bottom
    }
  \fi
}%
\define@boolkey[psset]{optexp}[POE@]{fiber@}[true]{}
\define@boolkey[psset]{optexp}[POE@]{nofiber@}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberin@}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberin@top}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberin@bottom}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberout@}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberout@top}[true]{}
\define@boolkey[psset]{optexp}[POE@]{fiberout@bottom}[true]{}
\psset[optexp]{fiber, fiber@=false}%
%    \end{macrocode}
% These are the internal boolkeys for the fiber choices done with 'fiberin' and 'fiberout'
%    \begin{macrocode}
\define@boolkey[psset]{optexp}[POE@]{relangle}[true]{}
\psset[optexp]{relangle=false}
%    \end{macrocode}
% Which nodes to take for the automatic fiber connections.
%    \begin{macrocode}
\define@choicekey+[psset]{optexp}{startnode}%
  [\val\nr]{auto,1,2,3,4,N}%
  {\edef\POE@key@startnode{\val}}
  {\PackageError{pst-optexp}{Unknown startnode '\val'}}
\define@choicekey+[psset]{optexp}{stopnode}[\val\nr]{auto,1,2,3,4,N}%
   {\edef\POE@key@stopnode{\val}}
   {\PackageError{pst-optexp}{Unknown stopnode '\val'}}
\psset[optexp]{%
  startnode=auto,
  stopnode=auto
}%
%    \end{macrocode}
%
% \begin{macro}{\POE@getnode}
%    \begin{macrocode}
\def\POE@getnode#1#2\@nil{%
  \ifx(#1\relax%)
    \POE@getcoor#1#2
    \edef\POE@temp{{\pst@coor}}%
  \else
    \ifnum9<1#1 %
      \edef\POE@temp{%
        /\POE@str@basicname@prefix\POE@str@basicname@default#1#2 %
      }%
    \else
      \edef\POE@temp{/\POE@str@basicname@prefix#1#2\space}%
    \fi
  \fi%
}%
%    \end{macrocode}
% \begin{macro}{\POE@getcoor}
%    \begin{macrocode}
\def\POE@getcoor(#1){%
  \pst@@getcoor{#1}
}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\drawfiber}
%    \begin{macrocode}
\def\drawfiber{\drawfiber@{Fiber}}%
\def\drawfiber@#1{%
  \ifPst@custom\else
    \def\pst@par{style=#1}%
  \fi
  \@ifnextchar[%]
    {\drawfiber@i}{\drawfiber@i[]}%
}%
\def\drawfiber@i[#1]#2{%
  \addafter@par{#1}%
  \def\POE@tempe{#2}%
  \@ifnextchar\bgroup{\drawfiber@ii}{}%
}%
\def\drawfiber@ii#1{%
  \expandafter\drawfiber@iii\expandafter{\POE@tempe}{#1}%
  \def\POE@tempe{#1}%
  \@ifnextchar\bgroup{\drawfiber@ii}{}%
}%
% \begin{macro}{POE@pnode}
%   Do some trickery to define \cs{pnode} inside \cs{pscustom}, which is
%   required if one wants to use \cs{drawfiber} inside \cs{pscustom}.
%    \begin{macrocode}
\def\POE@pnode#1#2{%
  \ifPst@custom
%%    \code{ /currentpoint load stopped { 0 0 moveto } if }%
%%    \code{ tx@NodeDict begin {#1 \tx@ScreenCoor 8.3021995 div exch 8.3021995 div exch neg
%%          } false /N@#2 10 {InitPnode} /NodeScale {} def NewNode end }%

    \code{%
      gsave 
        /currentpoint load stopped { 0 0 moveto } if 
        1 8.3021995 div dup neg scale 
        tx@NodeDict begin 
          {#1 \tx@ScreenCoor } false /N@#2 10 {InitPnode} 
          /NodeScale {} def NewNode 
        end 
      grestore 
    }%
  \else
    \pnode(!#1){#2}
  \fi
}%
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\def\drawfiber@iii#1#2{%
  \begingroup
    \let\psk@angleA\relax
    \let\psk@angleB\relax
    \use@par
    \def\POE@tempa{#1}
    \ifx\POE@tempa\@empty
      \edef\POE@comps{/\oenode{}{}\space}
    \else
      \expandafter\POE@getnode#1\@nil
      \edef\POE@comps{\POE@temp}
    \fi
    \def\POE@tempb{#2}
    \ifx\POE@tempb\@empty
      \edef\POE@comps{/\oenode{}{}\space \POE@comps}
    \else
      \expandafter\POE@getnode#2\@nil
      \edef\POE@comps{\POE@temp\space \POE@comps}
    \fi   
    \ifPOE@backlayer
      \ifx\POE@key@startnode\POE@str@autonode\else
        \POE@pnode{/\POE@key@startnode\space \POE@comps exch pop 
          \POE@dict{getsubnode} \tx@UserCoor}{@@A}
      \fi
      \ifx\POE@key@stopnode\POE@str@autonode\else
        \POE@pnode{/\POE@key@stopnode\space \POE@comps pop 
                 \POE@dict{getsubnode} \tx@UserCoor}{@@B}
      \fi
      \ifx\POE@key@startnode\POE@str@autonode
        \ifx\POE@key@stopnode\POE@str@autonode
          \POE@pnode{\POE@comps exch \POE@dict{NearestNode} 
                   \tx@UserCoor}{@@A}
          \POE@pnode{\POE@comps \POE@dict{NearestNode} 
                   \tx@UserCoor}{@@B}
        \else
          \POE@pnode{\POE@comps exch pop /N@@@B 
                   \POE@dict{@GetCenter ToVec NearestNode} 
                   \tx@UserCoor}{@@A}
        \fi
      \else\ifx\POE@key@stopnode\POE@str@autonode
        \POE@pnode{\POE@comps pop /N@@@A 
                 \POE@dict{@GetCenter ToVec NearestNode} 
                 \tx@UserCoor}{@@B}
      \fi\fi
      \pst@getcoor{@@A}\POE@tempa
      \pst@getcoor{@@B}\POE@tempb
      \ifx\psk@angleA\relax
        \psset{%
          angleA=! \POE@dict{%
            \POE@tempb \POE@tempa \POE@comps exch RelFiberAngle
          }%
        }%
      \else
        \ifPOE@relangle
          \psset{%
            angleA=! \POE@dict{%
              \POE@tempb \POE@tempa \POE@comps exch RelFiberAngle
            } %
            \psk@angleA\space add
          }%
        \fi
      \fi
      \ifx\psk@angleB\relax
        \psset{%
          angleB=! \POE@dict{%
            \POE@tempa \POE@tempb \POE@comps RelFiberAngle
          }
        }%
      \else
        \ifPOE@relangle
          \psset{%
            angleB=! \POE@dict{%
              \POE@tempa \POE@tempb \POE@comps RelFiberAngle
            } \psk@angleB\space add 
          }%
      \fi\fi
      \nccurve{@@A}{@@B}
    \fi
  \endgroup
}%
%    \end{macrocode}
% 
% \begin{macro}{\backlayer}
%    \begin{macrocode}
\def\backlayer#1{\ifPOE@backlayer #1\fi\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\frontlayer}
%    \begin{macrocode}
\def\frontlayer#1{\ifPOE@frontlayer #1\fi\ignorespaces}
%    \end{macrocode}
% \end{macro}
%    
% The keys related to the \cs{draw*} macros
%    \begin{macrocode}
\define@key[psset]{optexp}{beamangle}{%
  \edef\POE@key@beamangle{#1}%
}%
\define@key[psset]{optexp}{beampos}{%
  \edef\POE@key@beampos{#1}%
}%
\define@key[psset]{optexp}{beamdiv}{%
  \edef\POE@key@beamdiv{#1}%
}%
\define@key[psset]{optexp}{beamwidth}{%
  \edef\POE@key@beamwidth{#1}%
}%
\define@boolkey[psset]{optexp}[POE@]{startinside}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{stopinside}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{beaminsidefirst}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{beaminsidelast}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{savebeampoints}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{loadbeampoints}[true]{}%
\define@key[psset]{optexp}{skipconn}{%
  \pst@checknum{#1}\POE@key@skipconn
}%
\define@boolkey[psset]{optexp}[POE@]{beaminside}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{connectplanes}[true]{}%
\define@boolkey[psset]{optexp}[POE@]{beamangleabs}[true]{}%
\psset[optexp]{skipconn=0}%
%    \end{macrocode}
%
% \begin{macro}{\begin@BeamObj}
%    \begin{macrocode}
\def\begin@BeamObj{%
  \addbefore@par{n=0}%
  \begin@SpecialObj%
  \addto@pscode{%
     \pst@optexpdict 
     /loadbeampoints \ifPOE@loadbeampoints true \else false \fi def
     /savebeampoints \ifPOE@savebeampoints true \else false \fi def
     /beaminsidefirst \ifPOE@beaminsidefirst true \else false \fi def
     /beaminsidelast \ifPOE@beaminsidelast true \else false \fi def
     /beaminside \ifPOE@beaminside true \else false \fi def
     /startinside \ifPOE@startinside true \else false \fi def
     /stopinside \ifPOE@stopinside true \else false \fi def
     /connectplanes \ifPOE@connectplanes true \else false \fi def
     /beamangleabs \ifPOE@beamangleabs true \else false \fi def
     /skipconn \POE@key@skipconn\space def
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\begin@WideBeamObj}
%    \begin{macrocode}
\def\begin@WideBeamObj{%
  \addafter@par{style=Beam}%
  \begin@BeamObj
  \let\pst@linetype\pst@arrowtype
  \pst@addarrowdef%
  \let\POE@strokebeam\POE@strokewidebeam
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\begin@SingleBeamObj}
%    \begin{macrocode}
\def\begin@SingleBeamObj{%
  \addbefore@par{style=Beam}%
  \begin@BeamObj
  \let\pst@linetype\pst@arrowtype
  \pst@addarrowdef%
  \let\POE@strokebeam\POE@strokesinglebeam
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\drawbeam}
%    \begin{macrocode}
\def\drawbeam{\pst@object{drawbeam}}%
\def\drawbeam@i{%
  \def\POE@conntable{,a-a,b-b,A-A,B-B}%
  \begin@SingleBeamObj
  \POE@getcomps[\drawbeam@ii%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\drawwidebeam}
%    \begin{macrocode}
\def\drawwidebeam{\pst@object{drawwidebeam}}%
\def\drawwidebeam@i{%
  \begin@WideBeamObj
  \POE@getcomps[\drawwidebeam@ii%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@beam@use@pscode}
%
%   This is a hack which allows us to leave the names and coordinates of the
%   beam end points on the stack after the \opt{@endspecial} call. This replaces
%   \nxLcs{use@pscode} in \nxLcs{end@BeamObj}. These values on the stack must be
%   consumed directly after closing the beam object.
%    \begin{macrocode}
\def\POE@beam@use@pscode{%
  \pstverb{%
    \pst@dict
    \tx@STP
    \pst@newpath
    \psk@origin
    \psk@swapaxes
    \pst@code
    end
    count /ocount exch def
  }%
  \gdef\pst@code{}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\end@BeamObj}
%    \begin{macrocode}
\def\end@BeamObj{%
  \addto@pscode{ end}%
  \let\psk@fillstyle\relax
  \ifPOE@optexpenv
    \ifPOE@frontlayer
%    \end{macrocode}
% Erase all beam-drawing code and leave only \opt{false} on the stack to 
% indicate that no beampoints should be stored.
%    \begin{macrocode}
      \def\pst@code{ false }%
    \fi
  \fi
  \let\use@pscode\POE@beam@use@pscode
  \end@SpecialObj%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\drawbeam@ii}
%    \begin{macrocode}
\def\drawbeam@ii{%
  \ifx\POE@key@conn\@empty
    \drawbeam@iii
  \else
    \drawbeam@compat
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\drawbeam@iii}
%    \begin{macrocode}
\def\drawbeam@iii{%
  \ifx\pslinestyle\@none
    \addto@pscode{ false }%
  \else
    \addto@pscode{%
     {/nmul \POE@key@nmul\space def
      /nadd \POE@key@nadd\space def
      /nforce \POE@key@n\space def} }%
    \ifx\POE@key@beampos\@empty
      \addto@pscode{ {0 0} }%
    \else
      \addto@pscode{ [\POE@key@beampos\space counttomark 1 eq 
                     { 0 exch } if \tx@ScreenCoor] cvx }%
    \fi
    \addto@pscode{%
       \POE@key@beamangle\space
    }%
    \addto@pscode{%
      currentdict /lastBeamPointTmp undef
      loadbeampoints tx@NodeDict /N@\oenodeBeam\space known and {
        /N@\oenodeBeam\space @GetCenter ToVec /lastBeamPointTmp ED
      } if
      TraceBeam 
    }%
    \POE@strokebeam
    \addto@pscode{%
      savebeampoints { 
        lastBeamPointTmp /N@\oenodeBeam
      } if
      savebeampoints }%
  \fi
  \end@BeamObj
  \POE@Verb{ { \tx@NodeScale @NewNode } if }%
}%
%    \end{macrocode}
% \end{macro}
% This fix is necessary for pst-node since version 1.21.
%    \begin{macrocode}
\def\tx@NodeScale{%
  \pst@nodedict 
    /NodeScale {\ifx\pstnodescale\@undefined  \else\pstnodescale \fi} def 
  end }
%    \end{macrocode}
% 
% \begin{macro}{\POE@strokesinglebeam}
%    \begin{macrocode}
\def\POE@strokesinglebeam{%
  \addto@pscode{%
    gsave 
      Drawbeam 
      \tx@setlinejoin
      \pst@number\pslinewidth SLW
      \pst@usecolor\pslinecolor
      \tx@setStrokeTransparency
      \@nameuse{psls@\pslinestyle}
    grestore
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\drawwidebeam@ii}
%    \begin{macrocode}
\def\drawwidebeam@ii{%
  \def\pst@fill##1{ gsave ##1 grestore }%
  \addto@pscode{%
    {/nmul \POE@key@nmul\space def
     /nadd \POE@key@nadd\space def
     /nforce \POE@key@n\space def
     /beamdiv \ifx\POE@key@beamdiv\@empty 0 \else 
                  \POE@key@beamdiv\fi\space def
    } %
  }%
%    \end{macrocode}
% arrange and create the input vectors
%    \begin{macrocode}
  \addto@pscode{%
    \POE@key@beamangle\space dup
    \ifx\POE@key@beamdiv\@empty\else 
      \POE@key@beamdiv\space dup 4 -1 roll add 3 1 roll sub
    \fi
  }%
%    \end{macrocode}
% the start positions
%    \begin{macrocode}
  \addto@pscode{%
    [
      \ifx\POE@key@beampos\@empty 
        0 0 
      \else
        \POE@key@beampos\space
      \fi
      counttomark 1 eq { 0 exch } if
      \ifx\POE@key@beamwidth\@empty 
        0 
      \else 
        \POE@key@beamwidth\space 0.5 mul 
      \fi\space
      3 copy add \tx@ScreenCoor\space ToVec 
      5 1 roll sub \tx@ScreenCoor
    ] cvx
  }%
%    \end{macrocode}
% rearrange options
%    \begin{macrocode}
  \addto@pscode{ exch 4 -1 roll 4 2 roll exch }% 
%    \end{macrocode}
% stroke and/or fill
%    \begin{macrocode}
  \ifx\psk@fillstyle\relax\else
    \addto@pscode{%
      counttomark 1 add copy 
      gsave
        /fillBeam { \psk@fillstyle } def
        currentdict /TmpLastBeamPointLow undef 
        currentdict /TmpLastBeamPointUp undef 
        loadbeampoints
        tx@NodeDict /N@\oenodeBeamLow\space known and
        tx@NodeDict /N@\oenodeBeamUp\space known and {
          /N@\oenodeBeamLow\space @GetCenter ToVec /TmpLastBeamPointLow ED
          /N@\oenodeBeamUp\space @GetCenter ToVec /TmpLastBeamPointUp ED
        } if
        FillWideBeam
      grestore pop % pop off the mark
    }%
  \fi%
%    \end{macrocode}
% stroke
%    \begin{macrocode}
  \ifx\pslinestyle\@none
    \addto@pscode{ cleartomark }%
  \else
    \addto@pscode{%
      currentdict /lastBeamPointUp undef
      currentdict /lastBeamPointLow undef
      loadbeampoints tx@NodeDict /N@\oenodeBeamLow\space known
      tx@NodeDict /N@\oenodeBeamUp\space known and and {
        /N@\oenodeBeamLow\space @GetCenter ToVec /lastBeamPointLow ED
        /N@\oenodeBeamUp\space @GetCenter ToVec /lastBeamPointUp ED
      } if
      TraceWideBeam }%
    \POE@strokebeam
  \fi
  \ifx\pslinestyle\@none
    \ifx\psk@fillstyle\relax\else
      \addto@pscode{%
        savebeampoints {
          TmpLastBeamPointLow /N@\oenodeBeamLow\space
          TmpLastBeamPointUp /N@\oenodeBeamUp\space
        } if
        savebeampoints
      }%
    \fi
  \else
    \addto@pscode{%
      savebeampoints {
        lastBeamPointLow /N@\oenodeBeamLow\space
        lastBeamPointUp /N@\oenodeBeamUp\space
      } if 
      savebeampoints }%
  \fi
  \end@BeamObj
  \POE@Verb{ { \tx@NodeScale @NewNode @NewNode } if }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@strokewidebeam}
%    \begin{macrocode}
\def\POE@strokewidebeam{%
  \POE@strokesinglebeam
  \POE@strokesinglebeam
}%
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\def\POE@getcomprange#1-#2\@nil{%
  \ifx\\#2\\%
    \ifx\\#1\\%
      % empty option
      \edef\POE@firstcomp{\the\POE@cnt}%
      \edef\POE@lastcomp{\the\POE@cnt}%
    \else
      \edef\POE@firstcomp{#1}%
      \edef\POE@lastcomp{#1}%
    \fi
  \else
    \ifx\\#1\\%
      \edef\POE@firstcomp{1}%
    \else
      \edef\POE@firstcomp{#1}%
    \fi
    \POE@getlastcomp#2%
  \fi
  \ifnum\POE@firstcomp<1
    \def\POE@firstcomp{1}%
  \else\ifnum\POE@firstcomp>\the\POE@cnt
    \edef\POE@firstcomp{\the\POE@cnt}%
  \fi\fi
  \ifnum\POE@lastcomp>\the\POE@cnt
    \edef\POE@lastcomp{\the\POE@cnt}%
  \else\ifnum\POE@lastcomp<1
    \def\POE@lastcomp{1}%
  \fi\fi
}
\def\POE@getlastcomp#1-{%
  \ifx.#1.%
    \edef\POE@lastcomp{\the\POE@cnt}%
  \else
    \ifx\@empty#1\relax
      \edef\POE@lastcomp{\the\POE@cnt}%
    \else
      \edef\POE@lastcomp{#1}%
    \fi
  \fi
}
%    \end{macrocode}
%
% \begin{macro}{\POE@getcomps}
%    \begin{macrocode}
\def\POE@getcomps#1#2{%
  \ifx\POE@key@conn\@empty
    \def\POE@aftercomps{\addto@pscode{#1 \POE@comps }#2}%
  \else
    \def\POE@aftercomps{#2}%
  \fi
  \def\POE@comps{}%
  \POE@@getcomps%
}%
\def\POE@@getcomps{%
  \@ifnextchar\bgroup{\POE@@@getcomps}{\POE@aftercomps}%
}%
\def\POE@@@getcomps#1{%
  \def\POE@temp{#1\@empty}%
  \expandafter\POE@@@@getcomps\POE@temp\@nil
}%
\def\POE@@@@getcomps#1#2\@nil{%
  \edef\POE@temp{#1}%
  \ifx\POE@temp\@empty
    \POE@getcomp{(\oenode{}{})}%
  \else\ifx(#1\relax%)
    \POE@getplanenode#1#2%
  \else\ifnum9<1#1\relax
    \POE@getcomprange#1#2-\@nil
    \POE@getcomp{%
      (\POE@str@basicname@prefix\POE@str@basicname@default)
      \POE@firstcomp\space\POE@lastcomp\space GetCompRange %
    }%
  \else\ifx-#1\relax
    \POE@getcomprange#1#2-\@nil
    \POE@getcomp{%
      (\POE@str@basicname@prefix\POE@str@basicname@default) 
      \POE@firstcomp\space\POE@lastcomp\space GetCompRange %
    }%
  \else
    \POE@getcomp{(\oenode{}{#1#2})}%
  \fi\fi\fi\fi%
  \POE@@getcomps%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@getplanenode}
%    \begin{macrocode}
\def\POE@getplanenode(#1){%
  \pst@@getcoor{#1}%
  \ifx\POE@key@conn\@empty
    \advance\POE@nodecnt by 1
    \POE@getcomp{%
      {\pst@coor} {0 1} (\POE@str@basicname@default N@\the\POE@nodecnt) 
      {\tx@UserCoor} NewTempNodeComp 
      (\POE@str@basicname@default N@\the\POE@nodecnt)
    }%
  \else
    \POE@getcomp{{\pst@coor} }%
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@getcomp}
%    \begin{macrocode}
\def\POE@getcomp#1{%
  \ifx\POE@comps\@empty
    \edef\POE@tempc{#1}%
  \else
    \edef\POE@tempd{#1}%
  \fi
  \edef\POE@comps{#1 \POE@comps}%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@drawInternalConnections}
%    \begin{macrocode}
\def\POE@drawInternalConnections{%
  \ifx\POE@key@conn\@empty
    \POE@drawInternalConnectionsNew
  \else
    \POE@drawInternalConnectionsOld
  \fi
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\POE@drawInternalFibers}
%    \begin{macrocode}
\def\POE@drawInternalFibers{%
  \ifPOE@endbox
    \ifPOE@fiberin@
      \drawfiber@{FiberIn}{(\oenodeRefA{})}{}
    \fi
  \else
    \ifPOE@fiberin@
      \drawfiber@{FiberIn}{(\oenodeRefA{})}{}
    \fi
    \ifPOE@fiberout@
      \drawfiber@{FiberOut}{}{(\oenodeRefB{})}
    \fi
  \fi
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\POE@drawInternalConnectionsNew}
%    \begin{macrocode}
\def\POE@drawInternalConnectionsNew{%
  \ifPOE@beam
    \ifPOE@endbox
      \drawbeam[connectplanes]{(\oenodeRefA{})}{}
    \else
      \drawbeam[connectplanes]{(\oenodeRefA{})}{}{(\oenodeRefB{})}
    \fi
  \else\ifPOE@fiber@
    \POE@drawInternalFibers
  \fi\fi
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\POE@drawInternalConnectionsOld}
%    \begin{macrocode}
\def\POE@drawInternalConnectionsOld{%
  \ifPOE@endbox
    \@nameuse{\POE@connIn}
  \else
    \ifPOE@fiber@
      \ifPOE@fiberin@
        \@nameuse{\POE@connIn}
      \fi
      \ifPOE@fiberout@
        \@nameuse{\POE@connOut}
      \fi
    \else
      \ifPOE@connjoin
        \def\POE@tempa{POE@conn@in@i}%
        \ifx\POE@tempa\POE@connIn
          \def\POE@tempb{POE@conn@out@o}
          \ifx\POE@tempb\POE@connOut
            \pscustom[style=Beam, linejoin=\POE@key@connjoin]{%
              \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}}%
          \else\ifx\@empty\POE@connOut
            \pscustom[style=Beam, linejoin=\POE@key@connjoin]{%
              \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}}%
          \else
            \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}%
          \fi\fi
        \else
          \def\POE@tempa{POE@conn@in@o}%
          \ifx\POE@tempa\POE@connIn
            \def\POE@tempb{POE@conn@out@o}
            \ifx\POE@tempb\POE@connOut
              \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}%
            \else\ifx\@empty\POE@connOut
              \pscustom[style=Beam, linejoin=\POE@key@connjoin]{%
                \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}}%
            \else
              \pscustom[style=Beam, linejoin=\POE@key@connjoin]{%
                \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}}%
            \fi\fi
          \else
            \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}%
          \fi
        \fi
      \else
        \@nameuse{\POE@connIn}\@nameuse{\POE@connOut}%
      \fi
    \fi
  \fi
}%
%    \end{macrocode}
% \end{macro}
%
% Set default settings for the new connection code
%    \begin{macrocode}
\psset[optexp]{%
        startinside=false
        ,stopinside=false
        ,beaminside=true
        ,beaminsidefirst=false
        ,beaminsidelast=false
        ,loadbeampoints=false
        ,savebeampoints=true
        ,beamangle=0
        ,beampos=\@empty
        ,beamangleabs=false
        ,beamwidth=0
        ,beamdiv=\@empty
        ,nmul=1
        ,nadd=0
}%

%    \end{macrocode}
% The old connection code for backward compatibility to version 2.x. As this is obsolete and was broken by design, there is no need to comment on this.
%    \begin{macrocode}
\def\optexp@nodeA{\oenodeIn{}}%
\def\optexp@nodeB{\oenodeOut{}}%
\define@key[psset]{optexp}{connjoin}{%
 \edef\POE@temp{#1}%
 \ifnum\POE@temp<0
   \POE@connjoinfalse
 \else\ifnum\POE@temp>2
   \POE@connjoinfalse
 \else
   \POE@connjointrue
   \edef\POE@key@connjoin{\POE@temp}
 \fi\fi
}%
\def\POE@key@conn{}%
\define@key[psset]{optexp}{conn}{%
  \edef\POE@key@conn{#1}%
  \expandafter\POE@psset@@conn\POE@key@conn\@empty-\@empty\@nil
  \if@pst\else
    \PackageError{pst-optexp}{Bad connection specification: #1}%
  \fi
}%
\def\POE@psset@@conn#1-#2\@empty#3\@nil{%
  \@psttrue
  \def\POE@next##1,#1-##2,##3\@nil{\def\POE@temp{##2}}%
  \expandafter\POE@next\POE@conntable,#1-#1,\@nil
  \@ifundefined{POE@conn@in@\POE@temp}%
    {\@pstfalse\def\POE@connIn{}}%
    {\edef\POE@connIn{POE@conn@in@\POE@temp}}%
  \@ifundefined{POE@conn@out@#2}%
    {\@pstfalse\def\POE@connOut{}}%
    {\def\POE@connOut{POE@conn@out@#2}}%
}%
\def\POE@connIn{}%
\def\POE@connOut{}%
\def\POE@conntable{,o-o,i-i,f-f}%
\def\POE@conn@out@{\ifPOE@insideobj\else\POE@conn@out@a\fi}%
\def\POE@conn@in@{\ifPOE@insideobj\else\POE@conn@in@a\fi}%
\def\POE@conn@in@o{%
  \psline[style=Beam](\oenodeRefA{})(\optexp@nodeA)%
}%
\def\POE@conn@out@o{%
  \psline[style=Beam](\optexp@nodeB)(\oenodeRefB{})%
}%
\def\POE@conn@in@f{%
  \pccurve[%
    angleA=!\POE@dict{/N@\oenodeRefB{} /N@\oenodeRefA{} FiberAngleA},
    angleB=!\POE@dict{/N@\oenodeRefB{} /N@\oenodeRefA{} FiberAngleB},
    style=FiberIn](\oenodeRefA{})(\optexp@nodeA)%
}%
\def\POE@conn@out@f{%
  \pccurve[%
    angleA=!\POE@dict{/N@\oenodeRefB{} /N@\oenodeRefA{} FiberAngleA},
    angleB=!\POE@dict{/N@\oenodeRefB{} /N@\oenodeRefA{} FiberAngleB},
    style=FiberOut](\optexp@nodeB)(\oenodeRefB{})%
}%
\def\POE@conn@in@i{%
  \def\pst@par{style=Beam}
  \begin@OpenObj
    \addto@pscode{%
      [%]
      \pst@optexpdict
        (\oenode{}{}) true GetInternalBeamNodesCompat
        /N@\oenodeRefA{} @GetCenter 
      end
    }%
  \psline@ii
}%
\def\POE@conn@out@i{%
  \def\pst@par{style=Beam}
  \begin@OpenObj
    \addto@pscode{%
      [%]
      \pst@optexpdict
        /N@\oenodeRefB{} @GetCenter
        (\oenode{}{}) true GetInternalBeamNodesCompat
      end
    }%
  \psline@ii
}%
\def\POE@conn@in@a{%
  dup xcheck not {
    \POE@dict{1 GetInternalBeamNodeCompat}
  } if
  exec
}%
\def\POE@conn@in@A{%
  dup xcheck not {
    false \POE@dict{GetInternalBeamNodesCompat} %
  } if
  exec
}%
\def\POE@conn@in@b{%
  dup xcheck not {
    \POE@dict{(N) GetInternalBeamNodeCompat}
  } if
  exec
}%
\def\POE@conn@in@B{%
  dup xcheck not {
    true \POE@dict{GetInternalBeamNodesCompat} %
  } if
  exec
}%
\let\POE@conn@out@a\POE@conn@in@a
\let\POE@conn@out@A\POE@conn@in@B
\let\POE@conn@out@b\POE@conn@in@b
\let\POE@conn@out@B\POE@conn@in@A
\def\drawbeam@compat{%
  \ifPOE@connjoin
    \setkeys+[psset]{optexp}{linejoin=\POE@key@connjoin}%
  \fi
  \addto@pscode{[% ]
    \POE@tempd\space
    \@nameuse{\POE@connOut}
    \POE@tempc\space
    \@nameuse{\POE@connIn}}%
  \psline@ii
\ignorespaces}%
%
%    \end{macrocode}
% \begin{macro}{\defShiftedNode}
%   This is provided only for backward compatibility, and should be replaced by
%   \cs{nodexn}.
%    \begin{macrocode}
\def\defShiftedNode(#1)(#2)#3{%
  \PackageWarning{pst-optexp}{%
    \string\defShiftedNode\space is deprecated,\MessageBreak
    use \string\nodexn\space(pst-node) instead.}%
  \pst@getcoor{#1}\pst@tempa%
  \pst@getcoor{#2}\pst@tempb%
  \pnode(! \pst@tempb \pst@tempa \POE@dict{VecAdd} \tx@UserCoor){#3}%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@checkcompname}
%    \begin{macrocode}
\def\POE@checkcompname#1{%
  \@expandtwoargs\in@{,#1,}{,\POE@complist,}%
  \ifin@\else
    \PackageError{pst-optexp}{^^Jcompname '#1' undefined!^^J}
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@getlastcompname}
%    \begin{macrocode}
\def\POE@getlastcompname{%
  \expandafter\POE@getlastcompname@i \POE@complist,\relax,\@nil
}%
\def\POE@getlastcompname@i#1,#2,#3\@nil{#1}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\oenode}
%    \begin{macrocode}
\def\oenode#1#2{%
  \POE@str@basicname@prefix%
  \ifx\\#2\\%
    \ifnum9<1\POE@getlastcompname%
      \POE@str@basicname@default%
      \POE@getlastcompname%
    \else%
      \POE@getlastcompname%
      \POE@str@basicname@sep%
    \fi%
  \else%
    \ifnum9<1#2%
      \POE@str@basicname@default%
      #2%
    \else%
      #2\POE@str@basicname@sep%
    \fi%
  \fi%
  #1%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\oenodeExt}
% The external node which is set with \opt{extnode}.
%    \begin{macrocode}
\def\oenodeExt#1{\oenode{\POE@str@extnode@postfix}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeIn}
% The first (input) node of the component.
%    \begin{macrocode}
\def\oenodeIn#1{\oenode{1}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeOut}
%    \begin{macrocode}
\def\oenodeOut#1{\oenode{N}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeCenter}
%    \begin{macrocode}
\def\oenodeCenter#1{\oenode{Center}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeLabel}
%    \begin{macrocode}
\def\oenodeLabel#1{\oenode{Label}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeRefA}
%    \begin{macrocode}
\def\oenodeRefA#1{\oenode{A}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeRefB}
%    \begin{macrocode}
\def\oenodeRefB#1{\oenode{B}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeRotref}
%    \begin{macrocode}
\def\oenodeRotref#1{\oenode{Rotref}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeTrefA}
%    \begin{macrocode}
\def\oenodeTrefA#1{\oenode{TrefA}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeTrefB}
%    \begin{macrocode}
\def\oenodeTrefB#1{\oenode{TrefB}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenode@RefA}
%    \begin{macrocode}
\def\oenode@RefA#1{\oenode{@A}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenode@RefB}
%    \begin{macrocode}
\def\oenode@RefB#1{\oenode{@B}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenode@TrefA}
%    \begin{macrocode}
\def\oenode@TrefA#1{\oenode{@TrefA}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenode@TrefB}
%    \begin{macrocode}
\def\oenode@TrefB#1{\oenode{@TrefB}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeIfc}
%    \begin{macrocode}
\def\oenodeIfc#1#2{%
  \ifnum9<1#1 %
    \oenode{#1}{#2}%
  \else\ifx#1N %
    \oenode{#1}{#2}%
  \else\ifx#1C %
    \oenode{#1}{#2}%
  \else
    \PackageWarning{pst-optexp}{%
      \string\oenodeIfc\space node argument must be\MessageBreak
      integer, 'N', or 'C'}
  \fi\fi\fi
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeBeam}
%    \begin{macrocode}
\def\oenodeBeam{%
  \POE@str@basicname@prefix\POE@str@basicname@default Beam}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeBeamUp}
%    \begin{macrocode}
\def\oenodeBeamUp{%
  \POE@str@basicname@prefix\POE@str@basicname@default BeamUp}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oenodeBeamLow}
%    \begin{macrocode}
\def\oenodeBeamLow{%
  \POE@str@basicname@prefix\POE@str@basicname@default BeamLow}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\newOptexpComp}
%    \begin{macrocode}
\def\newOptexpComp#1{%
  \POE@Verb{%
    \tx@NodeScale
    [ #1 (\oenode{}{}) {\tx@ScreenCoor} false NewOptexpComp
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\newOptexpCompAmb}
%    \begin{macrocode}
\def\newOptexpCompAmb#1{%
  \POE@Verb{%
    \tx@NodeScale
    [ #1 (\oenode{}{}) {\tx@ScreenCoor} true NewOptexpComp
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\POE@compalias}
%    \begin{macrocode}
\def\POE@compalias#1#2{%
  \POE@Verb{%
    /\oenode{}{#1} dup currentdict exch known { 
      load /#2 ED 
    } { 
      pop 
    } ifelse
    (#2) (\oenode{}{#1})
    tx@NodeDict begin
      1 {
        3 copy inttostr dup 
        3 1 roll 2 copy NodeName
        currentdict exch known {
          NodeName load 3 1 roll NodeName ED
          1 add
        } {
          pop (N) NodeName load 3 1 roll 
          pop (N) NodeName ED
          pop exit
        } ifelse
      } loop
      [ (A) (B) (@A) (@B) (Center) (Label) (Rotref) 
        (TrefA) (TrefB) (@TrefA) (@TrefB) (Ext)
      counttomark {
        counttomark 3 add -2 roll 2 copy counttomark 1 add 2 roll
        3 -1 roll dup 4 1 roll NodeName dup 
        currentdict exch known { 
          load 3 1 roll exch NodeName ED 
        } { 
          pop pop pop 
        } ifelse
      } repeat pop pop pop
    end
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optplane}
%    \begin{macrocode}
\def\optplane(#1)(#2)#3{%
  \pst@getcoor{#1}\POE@tempa% origin
  \pst@getcoor{#2}\POE@tempb% difference vector
  \POE@Verb{%
    \tx@NodeScale
    [ {\POE@tempa} gsave STV CP T exec grestore ToVec 
    {\POE@tempb} trans {PlaneIfc} 1
    (\POE@str@basicname@prefix#3) {} false NewOptexpComp
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\begin@OptexpObj}
%    \begin{macrocode}
\def\begin@OptexpObj{%
  \global\advance\POE@cnt by 1
  \addbefore@par{compname={}}%
  \pst@killglue
  \begingroup
    \POE@insideobjtrue
    \POE@Verb{InitOptexpComp }%
    \use@par
%    \end{macrocode}
% Usually the shift refers to the y-direction, shifting in x-direction
% is done by 'abspos' or 'position'
%    \begin{macrocode}
    \let\POE@key@comp@Yshift\POE@key@compshift%
    \def\POE@key@comp@Xshift{0}%
    \edef\POE@refnodeA{\oenodeRefA{}}%
    \edef\POE@refnodeB{\oenodeRefB{}}%
    \edef\POE@trefnodeA{\oenodeTrefA{}}%
    \edef\POE@trefnodeB{\oenodeTrefB{}}%
    \def\POE@transformnodes{%
      \POE@transformnode{\oenodeRefA{}}{\oenodeTrefA{}}%
      \POE@transformnode{\oenodeRefB{}}{\oenodeTrefB{}}%
    }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\begin@OptexpFiberObj}
%    \begin{macrocode}
\def\begin@OptexpFiberObj{%
  \begin@OptexpObj
    \ifPOE@nofiber@\else
      \setkeys+[psset]{optexp}{fiber@}%
    \fi
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\begin@OptexpTripole}
%    \begin{macrocode}
\let\POE@disablepos\relax
\def\begin@OptexpTripole{%
  \begin@OptexpObj
%    \end{macrocode}
% for multipoles the default shifting is in $x$-direction
%    \begin{macrocode}
  \def\POE@key@comp@Xshift{\POE@key@compshift\space neg }%
  \def\POE@key@comp@Yshift{0}%
%    \end{macrocode}
% The positioning parameters are disabled, because \opt{compshift} does the job for tripoles.
%    \begin{macrocode}
  \def\POE@disablepos{%
    \let\POE@key@abspos\@empty
    \let\POE@key@position\@empty
  }%
  \edef\POE@refnodeA{\oenode@RefA{}}%
  \edef\POE@refnodeB{\oenode@RefB{}}%
  \edef\POE@trefnodeA{\oenode@TrefA{}}%
  \edef\POE@trefnodeB{\oenode@TrefB{}}%
  \def\POE@transformnodes{
    \POE@transformnode{\oenodeRefA{}}{\oenodeTrefA{}}%
    \POE@transformnode{\oenodeRefB{}}{\oenodeTrefB{}}%
    \POE@transformnode{\oenode@RefA{}}{\oenode@TrefA{}}%
    \POE@transformnode{\oenode@RefB{}}{\oenode@TrefB{}}%
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\end@OptexpObj}
%    \begin{macrocode}
\def\end@OptexpObj{%
  \ifnum9<1\POE@key@compname\else
    \POE@compalias{\POE@key@compname}{\oenode{}{\the\POE@cnt}}%
  \fi
  \endgroup
  \ignorespaces%
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\end@OptexpDipole}
%    \begin{macrocode}
\let\end@OptexpDipole\end@OptexpObj
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\end@OptexpTripole}
%    \begin{macrocode}
\let\end@OptexpTripole\end@OptexpObj
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\addafter@par}
% Command analog to \cs{addbefore@par} which is defined in pstricks.tex
% \cs{addafter@par} inserts new options at the end of the current token register.
% This can be useful to preset options that are not allowed to be changed by the
% user.
%    \begin{macrocode}
\def\addafter@par#1{%
  \ifx\pst@par\@empty
    \def\pst@par{#1}%
  \else
    \toks@{#1}%
    \pst@toks\expandafter{\pst@par}%
    \edef\pst@par{\the\pst@toks,\the\toks@}%
  \fi%
}%
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\def\getCLWH{CLW \pst@number\psxunit 2 mul div }%
\def\getCLW{CLW \pst@number\psxunit div }%
\let\POE@restorerefnodes\relax
%    \end{macrocode}
% 
% New high-level macros 
% 1) Allow a compressed notation of all provided elements, as most of the organizing code 
%    is mostly equal.
%
% 2) Provide a rather easy-to-use interface for the user to allow new user-defined elements
%
% \begin{macro}{\newOptexpDipole}
%    \begin{macrocode}
\def\newOptexpDipole{%
  \@ifnextchar[%]
    {\POE@newdipole}{\POE@newdipole[]}%
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\newOptexpTripole}
%    \begin{macrocode}
\def\newOptexpTripole{%
  \@ifnextchar[%]
    {\POE@newtripole}{\POE@newtripole[]}%
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\newOptexpFiberDipole}
%    \begin{macrocode}
\def\newOptexpFiberDipole{%
  \@ifnextchar[%]
    {\POE@newfiberdipole}{\POE@newfiberdipole[]}%
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\newOptexpFiberQuadrupole}
%    \begin{macrocode}
\def\newOptexpFiberQuadrupole{%
  \@ifnextchar[%]
    {\POE@newfiberquadrupole}{\POE@newfiberquadrupole[]}%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@newdipole}
%    \begin{macrocode}
\def\POE@newdipole[#1]#2#3{%
  \@ifundefined{#2@i}{%
    \@namedef{#2}{\pst@object{#2}}%
    \expandafter\def\csname #2@i\endcsname(##1)(##2){%
      \@ifnextchar\bgroup%
        {\@nameuse{#2@i@}(##1)(##2)}%
        {\@nameuse{#2@i@}(##1)(##2){}}%
    }%
    \expandafter\def\csname #2@i@\endcsname(##1)(##2)##3{%
      \addbefore@par{#3}%
      \addafter@par{#1}%
      \begin@OptexpObj
        \ifPOE@backlayer
          \POE@regNodes{##1}{##2}
          \POE@globalnoderef
        \fi
        \POE@drawcomponent[#2]{##3}{\@nameuse{#2@ii}}
        \ifPOE@backlayer
          \POE@Verb{(1) (N) (\oenode{}{}) CorrectDipoleNodes }%
          \POE@drawInternalConnections
        \fi
      \end@OptexpDipole
    }%
    \dipole@iimacro{#2}%
  }{%
    \PackageError{pst-optexp}{%
      dipole component `#2' already defined
    }%
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@newfiberdipole}
%    \begin{macrocode}
\def\POE@newfiberdipole[#1]#2#3{%
  \@ifundefined{#2@i}{%
    \@namedef{#2}{\pst@object{#2}}%
    \expandafter\def\csname #2@i\endcsname(##1)(##2){%
      \@ifnextchar\bgroup%
        {\@nameuse{#2@i@}(##1)(##2)}%
        {\@nameuse{#2@i@}(##1)(##2){}}%
    }%
    \expandafter\def\csname #2@i@\endcsname(##1)(##2)##3{%
      \addbefore@par{#3}%
      \addafter@par{#1}%
      \begin@OptexpFiberObj
        \ifPOE@backlayer
          \POE@regNodes{##1}{##2}
          \POE@globalnoderef
        \fi
        \POE@drawcomponent[#2]{##3}{\@nameuse{#2@ii}}
        \ifPOE@backlayer
          \POE@Verb{(1) (N) (\oenode{}{}) CorrectDipoleNodes }%
          \ifPOE@fiber@
            \POE@drawInternalFibers
          \fi
        \fi
        \end@OptexpDipole
      }%
      \fiberdipole@iimacro{#2}%
   }{%
     \PackageError{pst-optexp}{%
       fiber dipole object `#2' already defined
     }%
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@newtripole}
% Equivalent to \cs{POE@newdipole} for tripole objects.
%    \begin{macrocode}
\def\POE@newtripole[#1]#2#3{%
  \@ifundefined{#2@i}{%
    \@namedef{#2}{\pst@object{#2}}%
    \expandafter\def\csname #2@i\endcsname(##1)(##2)(##3){%
      \@ifnextchar\bgroup{\@nameuse{#2@i@}(##1)(##2)(##3)}%
                         {\@nameuse{#2@i@}(##1)(##2)(##3){}}%
    }%
    \expandafter\def\csname #2@i@\endcsname(##1)(##2)(##3)##4{%
      \addbefore@par{#3}%
      \addafter@par{ref@angle=180,#1}%
      \begin@OptexpTripole
        \ifPOE@backlayer
          \POE@calcNodes{##1}{##2}{##3}%
          \POE@regNodes{##1}{##3}%
        \fi
        \POE@drawcomponent[#2]{##4}{\@nameuse{#2@ii}}
        \ifPOE@backlayer
          \POE@drawInternalConnections
        \fi
      \end@OptexpTripole
    }%
    \tripole@iimacro{#2}%
  }{%
    \PackageError{pst-optexp}{%
      tripole object `#2' already defined
    }%
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@newfiberquadrupole}
%    \begin{macrocode}
\def\POE@newfiberquadrupole[#1]#2#3{%
  \@ifundefined{#2@i}{%
    \@namedef{#2}{\pst@object{#2}}%
    \expandafter\def\csname #2@i\endcsname(##1)(##2)(##3)(##4){%
      \@ifnextchar\bgroup%
        {\@nameuse{#2@i@}(##1)(##2)(##3)(##4)}%
        {\@nameuse{#2@i@}(##1)(##2)(##3)(##4){}}%
    }%
    \expandafter\def\csname #2@i@\endcsname(##1)(##2)(##3)(##4)##5{%
      \addbefore@par{#3}%
      \addafter@par{#1}%
      \begin@OptexpFiberObj
        \ifPOE@backlayer
          \ifx\POE@key@align\POE@str@top
            \pnode(##1){\oenodeRefA{}}
            \pnode(##3){\oenodeRefB{}}
          \else\ifx\POE@key@align\POE@str@bottom
            \pnode(##2){\oenodeRefA{}}
            \pnode(##4){\oenodeRefB{}}
          \else
            \pst@getcoor{##1}\POE@tempa%
            \pst@getcoor{##2}\POE@tempb%
            \pnode(!\POE@tempa \POE@tempb 
                    \POE@dict{VecAdd 0.5 VecMul}
                    \tx@UserCoor){\oenodeRefA{}}
            \pst@getcoor{##3}\POE@tempa%
            \pst@getcoor{##4}\POE@tempb%
            \pnode(!\POE@tempa \POE@tempb 
                    \POE@dict{VecAdd 0.5 VecMul}
                    \tx@UserCoor){\oenodeRefB{}}
         \fi\fi
       \fi
       \POE@drawcomponent[#2]{##5}{\@nameuse{#2@ii}}
       \ifPOE@backlayer
         \POE@Verb{%
           (1) (3) (\oenode{}{}) CorrectDipoleNodes 
           (2) (N) (\oenode{}{}) CorrectDipoleNodes 
         }%
         \ifPOE@fiber@
           \ifPOE@fiberin@top
             \drawfiber@{FiberIn1}[stopnode=1]{(##1)}%
                                              {\POE@key@compname}
           \fi
           \ifPOE@fiberin@bottom
             \drawfiber@{FiberIn2}[stopnode=2]{(##2)}%
                                              {\POE@key@compname}
           \fi
           \ifPOE@fiberout@top
             \drawfiber@{FiberOut}[startnode=3]{\POE@key@compname}%
                                               {(##3)}
           \fi
           \ifPOE@fiberout@bottom
             \drawfiber@{FiberOut2}[startnode=N]{\POE@key@compname}%
                                                {(##4)}
           \fi
         \fi
       \fi
     \end@OptexpObj
    }%
    \fiberdipole@iimacro{#2}%
  }{%
    \PackageError{pst-optexp}{%
      fiber quadrupole object `#2' already defined
    }%
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\dipole@iimacro}
%    \begin{macrocode}
\def\dipole@iimacro#1{%
  \POE@iimacro{#1}{\dipole@nodes}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fiberdipole@iimacro}
%    \begin{macrocode}
\def\fiberdipole@iimacro#1{%
  \POE@iimacro{#1}{\fiberdipole@nodes}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tripole@iimacro}
%    \begin{macrocode}
\def\tripole@iimacro#1{%
  \POE@iimacro{#1}{\tripole@nodes}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\POE@iimacro}
%    \begin{macrocode}
\def\POE@iimacro#1#2{%
  \@namedef{#1@ii}{%
    \ifPOE@backlayer
      \pnode(0,0){\oenodeCenter{}}%
    \fi
    \@ifundefined{#1@iii}{%
      \ifPOE@backlayer
        \@ifundefined{#1@nodes}{#2}{\@nameuse{#1@nodes}}%
      \fi
      \ifPOE@frontlayer
        \@nameuse{#1@comp}%
      \fi
    }{%
      \PackageWarning{pst-optexp}{%
        Using #1@iii, please switch to the new\MessageBreak
        interface system}%
      \ifPOE@backlayer
        \@nameuse{#1@iii}%
      \fi
    }%
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmsplitter}
%    \begin{macrocode}
\def\wdmsplitter{\pst@object{wdmsplitter}}%
\def\wdmsplitter@i(#1)(#2)(#3){%
  \@ifnextchar\bgroup%
    {\wdmsplitter@i@(#1)(#2)(#3)}%
    {\wdmsplitter@i@(#1)(#2)(#3){}}%
}%
\def\wdmsplitter@i@(#1)(#2)(#3)#4{%
  \begin@OptexpFiberObj
    \ifPOE@backlayer
      \pnode(#1){\oenodeRefA{}}
      \ifx\POE@key@align\POE@str@top
         \pnode(#2){\oenodeRefB{}}
      \else\ifx\POE@key@align\POE@str@bottom
         \pnode(#3){\oenodeRefB{}}
      \else
         \pst@getcoor{#2}\POE@tempa%
         \pst@getcoor{#3}\POE@tempb%
         \pnode(!\POE@tempa \POE@tempb 
                 \POE@dict{VecAdd 0.5 VecMul}
                 \tx@UserCoor){\oenodeRefB{}}
      \fi\fi
    \fi
    \POE@drawcomponent[wdmsplitter]{#4}\wdmsplitter@ii
    \ifPOE@backlayer
      \POE@Verb{(1) (N) (\oenode{}{}) CorrectDipoleNodes }%
      \ifPOE@fiber@
        \ifPOE@fiberin@
          \drawfiber@{FiberIn}[stopnode=1]{(#1)}{\POE@key@compname}
        \fi
        \ifPOE@fiberout@top
          \drawfiber@{FiberOut1}[startnode=2]{\POE@key@compname}{(#2)}
        \fi
        \ifPOE@fiberout@bottom
          \drawfiber@{FiberOut2}[startnode=N]{\POE@key@compname}{(#3)}
        \fi
      \fi
    \fi
  \end@OptexpObj
}%
\fiberdipole@iimacro{wdmsplitter}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmcoupler}
%    \begin{macrocode}
\def\wdmcoupler{\pst@object{wdmcoupler}}%
\def\wdmcoupler@i(#1)(#2)(#3){%
  \@ifnextchar\bgroup%
    {\wdmcoupler@i@(#1)(#2)(#3)}%
    {\wdmcoupler@i@(#1)(#2)(#3){}}%
}%
\def\wdmcoupler@i@(#1)(#2)(#3)#4{%
  \begin@OptexpFiberObj
    \ifPOE@backlayer
      \pnode(#3){\oenodeRefB{}}
      \ifx\POE@key@align\POE@str@top
         \pnode(#1){\oenodeRefA{}}
      \else\ifx\POE@key@align\POE@str@bottom
         \pnode(#2){\oenodeRefA{}}
      \else
         \pst@getcoor{#1}\POE@tempa%
         \pst@getcoor{#2}\POE@tempb%
         \pnode(!\POE@tempa \POE@tempb 
                 \POE@dict{VecAdd 0.5 VecMul}
                 \tx@UserCoor){\oenodeRefA{}}
      \fi\fi
    \fi
    \POE@drawcomponent[wdmcoupler]{#4}\wdmcoupler@ii
    \ifPOE@backlayer 
      \POE@Verb{(1) (N) (\oenode{}{}) CorrectDipoleNodes }%
      \ifPOE@fiber@
        \ifPOE@fiberout@
          \drawfiber@{FiberOut}[startnode=N]{\POE@key@compname}{(#3)}
        \fi
        \ifPOE@fiberin@top
          \drawfiber@{FiberIn1}[stopnode=1]{(#1)}{\POE@key@compname}
        \fi 
        \ifPOE@fiberin@bottom
          \drawfiber@{FiberIn2}[stopnode=2]{(#2)}{\POE@key@compname}
        \fi
      \fi
    \fi
  \end@OptexpObj
}%
\fiberdipole@iimacro{wdmcoupler}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@calcNodes}
%   Some of the components need three points to be positioned. 
%   These are:
%
% \begin{enumerate}
% \item starting point of the beam (in the PS-Code: (XA,YA)) 
% \item reflection point on the surface (XG, YG) 
% \item end point (XB,YB)
%  \end{enumerate}     
%
%  With these three points \cs{poe@calcNodes} calculates two new points 'tempNode@A' 
%  and 'tempNode@B', between which the component is placed by the macro 
%  \cs{poe@drawcomponent} in the way, that 'angle of incidence' == 'angle of deflection'
%  regarding the reflection surface (mirror, diagonal of the beamsplitter, 
%  grid etc.)
%    \begin{macrocode}
\def\POE@calcNodes#1#2#3{{%
  \pst@getcoor{#1}\POE@tempa%
  \pst@getcoor{#2}\POE@tempb%
  \pst@getcoor{#3}\POE@tempc%
  \pnode(! \POE@dict{%
    \POE@tempa \tx@UserCoor
    \POE@tempc \tx@UserCoor
    \POE@tempb \tx@UserCoor
    calcNodes
    X@A Y@A}){\oenode@RefA{}}%
  \pnode(! \POE@dict{X@B Y@B}){\oenode@RefB{}}%
}\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@regNodes}
% If a macro needs only two points, they are equivalent to 
% 'tempNode@A' and 'tempNode@B'. But for easier implementation of other 
% macros the given points are assigned to the temporary nodes.
%    \begin{macrocode}
\def\POE@regNodes#1#2{%
  \pnode(#1){\oenodeRefA{}}
  \pnode(#2){\oenodeRefB{}}
  \POE@Verb{%
    /@xref \POE@key@extnode@xref\space def 
    /@yref \POE@key@extnode@yref\space def
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@globalnoderef}
%    \begin{macrocode}
\def\POE@globalnoderef{%
  \ifPOE@globalnoderef
    \POE@Verb{%
      /N@\oenodeRefA{} @GetCenter /N@\oenodeRefB{} @GetCenter
      @ABVect exch
      dup 0 gt 3 1 roll 0 eq exch 0 lt and or
      { /RefFac -1 def } if
    }%
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@pnode@shiftedrot}
% Define a new node \#3 shifted by (\#1) relative to existing node \#2.
% Aditionally rotate the new node by \#4 degree around existing node as origin.
%    \begin{macrocode}
\def\POE@pnode@shiftedrot(#1)#2#3#4{%
  \pst@getcoor{#1}\POE@temp%
  \pnode(!%
    \POE@temp /YDiff ED /XDiff ED %
    /N@#2 load GetCenter /YShifted ED /XShifted ED
    /rot@angle #4 \POE@key@labelrefangle\space add def
    /XDiff@Rot rot@angle cos XDiff mul rot@angle sin YDiff mul add def
    /YDiff@Rot rot@angle cos YDiff mul rot@angle sin XDiff mul sub def
    XShifted XDiff@Rot add YShifted YDiff@Rot add neg \tx@UserCoor
  ){#3}%
  \psset[optexp]{ref@angle=0}
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@putlabelrelative}
% Used to put the label for labelref=relative
%    \begin{macrocode}
\def\POE@putlabelrelative#1{%
  \nput[labelsep=0]{\POE@key@labelangle}%
       {\oenodeLabel{}}%
       {\rput[\POE@key@labelalign](0,0){\POE@key@labelstyle #1}}%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@putcomp}
%   Place the component in argument \#1 and define a new node
%   \oenodeLabel{} for positioning of the label.
%    \begin{macrocode}
\def\POE@putcomp#1#2{%
  \@ifundefined{#1@ref}{}{\@nameuse{#1@ref}}%
   \rput(! \POE@key@comp@Xshift\space\POE@key@comp@Yshift){%
     \pnode(! \POE@dict{
       \POE@key@rotate@xref\space
       \POE@key@rotate@yref\space
       ExtNode}){\oenodeRotref{}}%
     \ifdim\POE@key@angle pt=0pt
        #2%
        \POE@pnode@shiftedrot(0,\POE@key@labeloffset)%
                             {\oenodeCenter{}}%
                             {\oenodeLabel{}}%
                             {\POE@key@labelangle}%
     \else
        \psrotate(\oenodeRotref{}){\POE@key@angle}{%
          #2%
          \POE@pnode@shiftedrot(0,\POE@key@labeloffset)%
                               {\oenodeCenter{}}%
                               {\oenodeLabel{}}%
                               {\POE@key@labelangle}%
        }%
     \fi%
   }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\POE@putlabel}
% Positioning of the label depending on the reference coordinates.
% Needs possibly a previously defined node \cs{poe@nodeLabelShifted} which
% marks exactly the position of the label relative to the component.
% This is defined by calling \cs{poe@putcomp}.
% 
% Parameter 'labelref' which sets the reference coordinates can have 
% the values 
% \begin{description}
% \item[global] labelangle rotates the label origin in global coordinate system, text is not rotated
% \item[relgrav] labelangle rotates the label origin relativ to the local coordinate system of the component, text is not rotated
% \item[relative] as relgrav but text is rotated together with object.
% \end{description}
%    \begin{macrocode}  
\def\POE@putlabel#1{%
  \def\POE@temp{#1}%
  \ifx\POE@temp\@empty\else
  \ifx\POE@key@labelref\POE@str@labelref@global
    \nput[labelsep=\POE@key@labeloffset]%
      {\POE@key@labelangle}%
      {\oenodeCenter{}}%
      {\rput[\POE@key@labelalign](0,0){\POE@key@labelstyle #1}}%
  \else\ifx\POE@key@labelref\POE@str@labelref@relgrav
    \rput[\POE@key@labelalign](\oenodeLabel{}){%
      \POE@key@labelstyle #1}%
  \else\ifx\POE@key@labelref\POE@str@labelref@relative
    \begingroup
%    \end{macrocode}
% Redefine InitNC only for positioning of the label with labelref=relative
%    \begin{macrocode}
    \pst@def{InitNC}< % kindly contributed by Herbert Voss
      /b ED /a ED % second and first node
      /NodeSepTypeB ED /NodeSepTypeA ED
      /NodeSepB ED /NodeSepA ED
      /OffsetB ED /OffsetA ED
      tx@NodeDict a known tx@NodeDict b known and dup {
        /NodeA a load def /NodeB b load def
        NodeA GetCenter NodeB GetCenter % xA yA xB yB
        4 copy exch 4 -1 roll 2 copy gt % yA yB xB xA
          { pop pop pop pop /yB ED /xB ED /yA ED /xA ED }
          { eq 3 1 roll lt and 
              { /yB ED /xB ED /yA ED /xA ED} 
              { /yA ED /xA ED /yB ED /xB ED} ifelse
          } ifelse
      } if >%
      \ncline[linestyle=none,fillstyle=none, npos=]{\POE@trefnodeA}{\POE@trefnodeB}%
      \ifx\POE@key@position\@empty
        \ifx\POE@key@abspos\@empty
          \ncput[nrot=:U,npos=]{\POE@putlabelrelative{#1}}%
        \else
          \nlput[nrot=:U](\POE@refnodeA)(\POE@refnodeB){\POE@key@abspos}{\POE@putlabelrelative{#1}}%
        \fi
      \else
        \ncput[nrot=:U, npos=\POE@key@position]{\POE@putlabelrelative{#1}}%
      \fi
    \endgroup
  \fi\fi\fi
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Free-ray components}
%
% Define all free-ray dipoles
%    \begin{macrocode}
\newOptexpDipole{lens}{}%
\newOptexpDipole{pinhole}{}%
\newOptexpDipole{crystal}{}%
\newOptexpDipole{polarization}{}%
\newOptexpDipole{optbox}{}%
\newOptexpDipole{optplate}{}%
\newOptexpDipole{optretplate}{}%
\newOptexpDipole[endbox]{optdetector}{}%
\newOptexpDipole{optdiode}{}%
\newOptexpDipole{doveprism}{}%
%    \end{macrocode}
% 
% Define all free-ray tripoles
%    \begin{macrocode}
\newOptexpTripole{mirror}{}%
\newOptexpTripole[ref@angle=-135]{beamsplitter}{}%
\newOptexpTripole{optgrating}{}%
\def\optgrid{%
  \PackageWarning{pst-optexp}{%
    \string\optgrid\space is deprecated,\MessageBreak
    use \string\optgrating\space instead.}%
  \optgrating%
}%
\newOptexpTripole[ref@angle=-135]{pentaprism}{}%
\newOptexpTripole[ref@angle=-135]{rightangleprism}{}%
\newOptexpTripole[ref@angle=-135]{optprism}{}%
%    \end{macrocode}
%
% \begin{macro}{\optdipole}
%    \begin{macrocode}
\def\optdipole{\pst@object{optdipole}}
\def\optdipole@i(#1)(#2)#3#4{%
   \begin@OptexpObj
      \ifPOE@backlayer
        \POE@regNodes{#1}{#2}
        \POE@globalnoderef
      \fi
      \POE@drawcomponent{#4}{%
        \ifPOE@backlayer
          \pnode(0,0){\oenodeCenter{}}%
          \newOptexpComp{{ 0 0 } { 0 1 } trans {PlaneIfc} 1 }%
        \fi
        \ifPOE@frontlayer
          #3
        \fi
      }%
      \ifPOE@backlayer
        \POE@drawInternalConnections
      \fi
   \end@OptexpObj
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\opttripole}
%    \begin{macrocode}
\def\opttripole{\pst@object{opttripole}}
\def\opttripole@i(#1)(#2)(#3)#4#5{%
  \begin@OptexpTripole
    \ifPOE@backlayer   
      \POE@regNodes{#1}{#3}%
      \POE@calcNodes{#1}{#2}{#3}%
    \fi
    \POE@drawcomponent{#5}{%
      \pnode(0,0){\oenodeCenter{}}% 
      \newOptexpComp{{ 0 0 } { 1 0 } refl {PlaneIfc} 1 }%
      #4
    }%
    \POE@drawInternalConnections
  \end@OptexpTripole
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\fibercollimator}
%    \begin{macrocode}
\def\fibercollimator{\pst@object{fibercollimator}}
\def\fibercollimator@i(#1)(#2){%
   \def\POE@tempa{#1}%
   \def\POE@tempb{#2}%
   \def\POE@tempc{}%
   \def\POE@tempd{}%
   \@ifnextchar(%)
     {\fibercollimator@ii}{\fibercollimator@iv}%
}%
\def\fibercollimator@ii(#1){%
   \def\POE@tempc{#1}%
   \@ifnextchar(%)
     {\fibercollimator@iii}{\fibercollimator@iv}%
}%
\def\fibercollimator@iii(#1){%
   \def\POE@tempd{#1}%
   \fibercollimator@iv
}%
\def\fibercollimator@iv{%
  \@ifnextchar\bgroup{\fibercollimator@v}{\fibercollimator@v{}}%
}%
\def\fibercollimator@v#1{%
  \begin@OptexpObj
    \ifPOE@backlayer
      \POE@regNodes{\POE@tempa}{\POE@tempb}%
      \POE@globalnoderef
    \fi
    \POE@drawcomponent[fibercollimator]{#1}{%
       \pnode(0,0){\oenodeCenter{}}%
       \ifPOE@backlayer
         \fibercollimator@nodes
       \fi
       \ifPOE@frontlayer
         \fibercollimator@comp
       \fi
    }%
    \ifPOE@backlayer
      \ifPOE@beam
        \drawbeam{(\oenodeRefA{})}{\POE@key@compname}
      \fi
      \ifPOE@fiber@
        \ifPOE@fiberout@
          \ifx\@empty\POE@tempc
            \drawfiber{\POE@key@compname}{(\oenodeRefB{})}
          \else\ifx\@empty\POE@tempd
            \psbezier[style=FiberOut](\oenodeOut{})(\POE@tempb)%
                                     (\POE@tempb)(\POE@tempc)%
          \else
            \psbezier[style=FiberOut](\oenodeOut{})(\POE@tempb)%
                                     (\POE@tempc)(\POE@tempd)%
          \fi\fi
        \fi
      \fi
    \fi
  \end@OptexpObj
}%
%    \end{macrocode}
% \end{macro}
% 
% Define all fiber dipoles
%    \begin{macrocode}
\newOptexpFiberDipole{optfiber}{newOptComp={}}
\newOptexpFiberDipole{optamp}{}
\newOptexpFiberDipole{optmzm}{}
\newOptexpFiberDipole{optfilter}{}
\newOptexpFiberDipole{polcontrol}{}
\newOptexpFiberDipole{optisolator}{}
\newOptexpFiberDipole{optfiberpolarizer}{}
\newOptexpFiberDipole{optswitch}{}
\newOptexpFiberDipole{fiberdelayline}{}
%    \end{macrocode}
% Define all fiber quadrupoles
%    \begin{macrocode}
\newOptexpFiberQuadrupole{optcoupler}{}
%    \end{macrocode}
%
% \begin{macro}{\POE@drawcomponent}
% This macro is called by every unit
% The first parameter contains the label, the second one the drawing code
%    \begin{macrocode}
\def\POE@drawcomponent{%
  \@ifnextchar[%]
    {\POE@drawcomponent@i}{\POE@drawcomponent@i[]}%
}%
\def\POE@drawcomponent@i[#1]#2#3{%
  \def\@@comp{%
    #3%
    \ifx\POE@key@extnode\@empty\else
      \ifPOE@backlayer
        \pnode(! \POE@dict{
          \POE@key@extnode@xref\space
          \POE@key@extnode@yref\space
          ExtNode}){\oenodeExt{}}%
        \ifnum9<1\POE@key@compname\relax
          \POE@Verb{ tx@NodeDict begin /N@\oenodeExt{} load /N@ExtNode ED end }%
        \else
          \POE@Verb{ tx@NodeDict begin /N@\oenodeExt{} load /N@\POE@key@compname ExtNode ED end }%
        \fi
      \fi
    \fi
  }%
  \ifPOE@endbox%
    \ifx\POE@key@labeloffset\@empty
      \psset[optexp]{labeloffset=0}%
    \fi
    \psset[optexp]{position=1}%
  \fi%
  \POE@disablepos
  \ncline[linestyle=none,fillstyle=none,npos=]{\POE@refnodeA}{\POE@refnodeB}%
%    \end{macrocode}
% Positioning of the component
%    \begin{macrocode}
  \begingroup
    \psset{style=OptComp}%
%    \end{macrocode}
% linestyle to use, if component should be marked as optional
%    \begin{macrocode}
    \ifPOE@component@optional
      \psset{style=OptionalStyle}%
    \fi
%    \end{macrocode}
% if parameter 'position' is given, use it for 'npos'
%    \begin{macrocode}
    \ifx\POE@key@position\@empty
%    \end{macrocode}
% then check if absolute positioning is wanted
%    \begin{macrocode}
      \ifx\POE@key@abspos\@empty
        \ncput[nrot=:U,npos=]{\POE@putcomp{#1}{\@@comp}}%
      \else
        \nlput[nrot=:U](\POE@refnodeA)(\POE@refnodeB){\POE@key@abspos}{\POE@putcomp{#1}{\@@comp}}%
      \fi
    \else
      \ncput[nrot=:U,npos=\POE@key@position]{\POE@putcomp{#1}{\@@comp}}%
    \fi
  \endgroup
  \ifPOE@backlayer
    \POE@transformnodes
  \fi
  \ifPOE@frontlayer
    \POE@putlabel{#2}%
  \fi
%    \end{macrocode}
% Show some special dots for debugging
%    \begin{macrocode}
  \ifPOE@debug@showoptdots
    \ifPOE@backlayer
      \psdot[linecolor=red](\oenodeCenter{})
      \psdot[linecolor=red, dotstyle=x, dotscale=1.5](\oenodeLabel{})
      \psdot[linecolor=black](\oenodeRefA{})
      \psdot[linecolor=black](\oenodeRefB{})
      \psdot[linecolor=black, dotstyle=x, 
             dotscale=1.5](\oenodeTrefA{})
      \psdot[linecolor=black, dotstyle=x, 
             dotscale=1.5](\oenodeTrefB{})
    \fi
  \fi
  \ifPOE@debug@showifcnodes
    \ifPOE@backlayer
      \POE@ifcnodes[style=IfcNodeStyle]
    \fi
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{POE@transformnode}
%    \begin{macrocode}
\def\POE@transformnode#1#2{%
  \pnode(!
    \POE@dict{%
      /N@\oenodeRotref{} @GetCenter 2 copy
      /N@#1 @GetCenter 
      \POE@key@comp@Xshift\space\POE@key@comp@Yshift\space
      \tx@ScreenCoor VecAdd 4 2 roll @ABVect 
      \POE@key@angle\space matrix rotate dtransform VecAdd
      \tx@UserCoor
    }){#2}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\POE@ifcnodes}
%    \begin{macrocode}
\def\POE@ifcnodes{\pst@object{POE@ifcnodes}}
\def\POE@ifcnodes@i{%
  \begin@SpecialObj%
  \solid@star%
  \addto@pscode{
    \psk@dotsize
    \@nameuse{psds@\psk@dotstyle}
    \POE@dict{[ (\oenode{}{}) false GetInternalBeamNodes %]
      counttomark 2 idiv { Dot } repeat
      pop}
    }%
  \end@SpecialObj
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\tripole@nodes}
%    \begin{macrocode}
\def\tripole@nodes{%
  \newOptexpComp{ {0 0} {1 0} refl {PlaneIfc} 1}%
  \pnode(! \POE@dict{@@y0 @@x0}){\oenodeCenter{}}
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\dipole@nodes}
%    \begin{macrocode}
\def\dipole@nodes{%
  \newOptexpComp{%
    {@@x0 @@x sub 0} {0 1} trans {PlaneIfc} 
    @@x 0 eq not {
      {@@x0 @@x add 0} {0 1} trans {PlaneIfc}
    } if \POE@key@n }%
  \pnode(! \POE@dict{@@x0 @@y0}){\oenodeCenter{}}
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{fiberdipole@nodes}
%    \begin{macrocode}
\def\fiberdipole@nodes{%
  \pnode(! \POE@dict{@@x0 @@x sub 0}){\oenodeIn{}}
  \pnode(! \POE@dict{@@x0 @@x add 0}){\oenodeOut{}}
  \pnode(! \POE@dict{@@x0 @@y0}){\oenodeCenter{}}
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\mirror@ref}
%    \begin{macrocode}
\def\mirror@ref{%
  \ifx\POE@key@mirrortype\POE@str@mirrortype@piezo
    \POE@Verb{/@@y0 \pst@number\psyunit def}%
    \bgroup
      \psset{style=PiezoMirror}
      \POE@Verb{%
        \pst@number\psyunit @@y0 div 
        \POE@key@mirrorwidth\space 0.5 mul mul 2.5 div /@@y0 ED
      }%
    \egroup
  \else\ifdim\POE@key@mirrorradius pt=0pt
    \POE@Verb{/@@x \POE@key@mirrorwidth\space 0.5 mul def}%
  \fi\fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\mirror@nodes}
%    \begin{macrocode}
\def\mirror@nodes{%
   \newOptexpComp{%
     { 0 0 } 
     \ifdim\POE@key@mirrorradius pt=0pt
       { 1 0 } refl {PlaneIfc}
     \else
       { 0 \POE@key@mirrorradius\space neg} refl {CurvedIfc}
     \fi
     1 %
   }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\mirror@comp}
%    \begin{macrocode}
\def\mirror@comp{%
  \edef\@ht{%
    \POE@key@mirrorwidth\space\pst@number\psyunit mul 0.5 mul %
  }%
  \edef\@dp{\POE@key@mirrordepth\space\pst@number\psxunit mul }%
  \edef\@r{\POE@key@mirrorradius\space\pst@number\psxunit mul }%
  \edef\@postcode{%
    neg 5 -1 roll exch 5 2 roll 90 add exch 90 add exch ArcR %
  }%
  \edef\@extpostcode{%
    neg \@dp add 5 -1 roll exch 5 2 roll 90 add exch 90 add %
  }%
%    \end{macrocode}
% concave mirrors
%    \begin{macrocode}
  \ifdim\POE@key@mirrorradius pt<0pt
    \ifx\POE@key@mirrortype\POE@str@mirrortype@extended
%    \end{macrocode}
% extended concave mirror
%    \begin{macrocode}
      \bgroup
        \psset{style=ExtendedMirror}
        \begin@ClosedObj
          \addto@pscode{%
            \pst@optexpdict \@ht \@r rightCurvedIfc \@postcode  
            \@ht \@r rightCurvedIfc \@extpostcode arc
            closepath end}%
        \end@ClosedObj
      \egroup
    \fi
    \begin@OpenObj
      \addto@pscode{\POE@dict{ \@ht \@r rightCurvedIfc \@postcode }}%
    \end@OpenObj
%    \end{macrocode}
% convex mirrors
%    \begin{macrocode}
  \else\ifdim\POE@key@mirrorradius pt>0pt
    \ifx\POE@key@mirrortype\POE@str@mirrortype@extended
%    \end{macrocode}
% extended convex mirror
%    \begin{macrocode}
      \bgroup
        \psset{style=ExtendedMirror}
        \begin@ClosedObj
          \addto@pscode{%
            \pst@optexpdict \@ht \@r rightCurvedIfc \@postcode
            \@ht \@r rightCurvedIfc \@extpostcode arcn
            closepath end}%
        \end@ClosedObj
      \egroup
    \fi
   \begin@OpenObj
     \addto@pscode{\POE@dict{ \@ht \@r rightCurvedIfc \@postcode }}%
   \end@OpenObj
  \else
%    \end{macrocode}
% plain mirror 
%    \begin{macrocode}
    \edef\@ht{\POE@key@mirrorwidth\space 0.5 mul }%
    \ifPOE@variable
      \psarc[style=VariableMirror](! \@ht 0.4 sub 0){0.6}{-20}{20}
      \psarc[style=VariableMirror](! 0.4 \@ht sub 0){0.6}{160}{200}
     \fi%
     \ifx\POE@key@mirrortype\POE@str@mirrortype@piezo%
       \psframe[style=PiezoMirror,
                dimen=outer](! \@ht 4 div 0)%
                            (! \@ht -4 div \@ht 2.5 div)
       \ifx\POE@key@extnode\@empty
         \psbezier(! 0 \@ht 2.5 div)%
                  (! 0 \@ht 1.5 div)%
                  (! \@ht 2 div \@ht 2 div)%
                  (! \@ht 4 div \@ht)%
       \fi
    \else\ifx\POE@key@mirrortype\POE@str@mirrortype@extended%
      \psframe[style=ExtendedMirror]%
         (! \@ht neg \POE@key@mirrordepth\space )%
         (! \@ht 0)%
    \fi\fi
    \psline[linewidth=\POE@key@mirrorlinewidth]%
      (! \@ht neg \getCLWH)%
      (! \@ht \getCLWH)
  \fi\fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\lens@ref}
%    \begin{macrocode}
\def\lens@ref{%
  \POE@Verb{/@@y \POE@key@lensheight\space 0.5 mul def}%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\lens@nodes}
%    \begin{macrocode}
\def\lens@nodes{%
  \edef\@th{0}% 
  \ifdim\POE@key@lensradiusleft pt=0pt\else
    \edef\@th{%
      \ifPOE@thicklens 
        \POE@key@lenswidth\space 2 div 
      \else 
        \POE@key@lensradiusleft\space
        \POE@key@lensheight\space 2 div capHeight 
      \fi
    }%     
  \fi
  \ifdim\POE@key@lensradiusright pt=0pt\else
    \edef\@th{%
      \@th\space
      \ifPOE@thicklens 
        \POE@key@lenswidth\space 2 div
      \else 
        \POE@key@lensradiusright\space
        \POE@key@lensheight\space 2 div capHeight 
      \fi
      \space add
    }%
  \fi
  \newOptexpComp{%
    {\@th\space -2 div 0} 
    \ifdim\POE@key@lensradiusleft pt=0pt 
      {0 1} trans {PlaneIfc}
    \else 
      {\POE@key@lensradiusleft\space 0} trans {CurvedIfc}
    \fi
    {\@th\space 2 div 0} 
    \ifdim\POE@key@lensradiusright pt=0pt
      {0 1} trans {PlaneIfc}
    \else
      {\POE@key@lensradiusright\space neg 0} trans {CurvedIfc} 
    \fi
    \POE@key@n
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\lens@comp}
%    \begin{macrocode}
\def\lens@comp{%
  \addbefore@par{linejoin=1}%
  \begin@ClosedObj
  \addto@pscode{\pst@optexpdict /@th 0 def }%
  \def\@th{0}%
  \def\@wd{\POE@key@lenswidth\space\pst@number\psxunit mul 2 div }%
  \def\@ht{\POE@key@lensheight\space\pst@number\psyunit mul 2 div }%
  \def\@rL{\POE@key@lensradiusleft\space\pst@number\psxunit mul }%
  \def\@rR{\POE@key@lensradiusright\space\pst@number\psxunit mul }%
  \ifdim\POE@key@lensradiusleft pt=0pt\else
    \edef\@th{%
      \ifPOE@thicklens
        \POE@key@lenswidth\space 2 div 
      \else
        \POE@key@lensradiusleft\space
        \POE@key@lensheight\space 2 div capHeight
      \fi
    }%
    \addto@pscode{%
      /@th \ifPOE@thicklens \@wd \else \@rL \@ht capHeight \fi def
      \@ht \@rL leftCurvedIfc
    }%
  \fi
  \ifdim\POE@key@lensradiusright pt=0pt\else
    \edef\@th{%
      \@th\space
      \ifPOE@thicklens 
        \POE@key@lenswidth\space 2 div
      \else
        \POE@key@lensradiusright\space
        \POE@key@lensheight\space 2 div capHeight 
      \fi\space add
    }%
    \addto@pscode{%
      /@th @th \ifPOE@thicklens \@wd \else \@rR \@ht capHeight \fi 
      add def
      \@ht \@rR rightCurvedIfc
    }%
  \fi
%    \end{macrocode}
% Check some special cases:
%
% 1) Left is plain - right concave / convex
%    \begin{macrocode}
  \ifdim\POE@key@lensradiusleft pt=0pt
    \ifdim\POE@key@lensradiusright pt=0pt\else
      \addto@pscode{%
        @th 2 div sub neg 5 1 roll
        @th 2 div neg \@ht neg moveto ArcR
        @th 2 div neg \@ht lineto
      }%
    \fi
  \fi
%    \end{macrocode}
% 2) Right is plain - left concave / convex
%    \begin{macrocode}
  \ifdim\POE@key@lensradiusright pt=0pt
    \ifdim\POE@key@lensradiusleft pt=0pt\else
      \addto@pscode{%
        @th 2 div sub 5 1 roll
        @th 2 div \@ht moveto ArcL
        @th 2 div \@ht neg lineto
      }%
    \fi
  \fi
%    \end{macrocode}
% 3) right and left are both curved
%    \begin{macrocode}
  \ifdim\POE@key@lensradiusright pt=0pt\else
    \ifdim\POE@key@lensradiusleft pt=0pt\else
      \addto@pscode{%
        @th 2 div dup
        7 1 roll sub neg 5 1 roll
        ArcR sub 5 1 roll ArcL
      }%
    \fi
  \fi
  \addto@pscode{closepath 1 setlinejoin end }%
  \end@ClosedObj
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\pinhole@ref}
%    \begin{macrocode}
\def\pinhole@ref{%
  \POE@Verb{/@@y \POE@key@outerheight\space 0.5 mul def}%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\pinhole@comp}
%    \begin{macrocode}
\def\pinhole@comp{%
  \ifdim\POE@key@phwidth pt=0pt
    \psline[linewidth=\POE@key@phlinewidth]%
      (! 0 \POE@key@outerheight\space 2 div)%
      (! 0 \POE@key@innerheight\space 2 div)%
    \psline[linewidth=\POE@key@phlinewidth]%
      (! 0 \POE@key@outerheight\space -2 div)%
      (! 0 \POE@key@innerheight\space -2 div)%
  \else
    \pspolygon*[linestyle=none]%
      (! 0 \POE@key@innerheight\space 2 div)%
      (! 0 \POE@key@outerheight\space 2 div)%
      (! \POE@key@phwidth\space\POE@key@outerheight\space 2 div)%
      (! \POE@key@phwidth\space\POE@key@innerheight\space dup neg
         \POE@key@outerheight\space add 2 div add 2 div)%
    \pspolygon*[linestyle=none]%
      (! 0 \POE@key@innerheight\space -2 div)%
      (! 0 \POE@key@outerheight\space -2 div)%
      (! \POE@key@phwidth\space\POE@key@outerheight\space -2 div)%
      (! \POE@key@phwidth\space\POE@key@innerheight\space dup neg 
         \POE@key@outerheight\space add 2 div add -2 div)%
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\beamsplitter@nodes}
%    \begin{macrocode}
\def\beamsplitter@nodes{%
  \edef\@bs@wd{\POE@key@bssize\space 2.0 div }%
  \ifx\POE@key@bsstyle\POE@str@bsstyle@cube
    \newOptexpCompAmb{%
      {\@bs@wd 2 sqrt div neg dup} {-1 1} trans {PlaneIfc}
      {\@bs@wd 2 sqrt div dup neg} {1 1} trans {PlaneIfc}
      {\@bs@wd 2 sqrt div dup} {-1 1} trans {PlaneIfc}
      {\@bs@wd 2 sqrt div neg dup neg} {1 1} trans {PlaneIfc} 
      {0 0} {1 0} trans {PlaneIfc} \POE@key@n
    }%
  \else\ifx\POE@key@bsstyle\POE@str@bsstyle@plate
    \newOptexpCompAmb{ {0 0} {1 0} trans {PlaneIfc} 1 }%
  \fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\beamsplitter@comp}
%    \begin{macrocode}
\def\beamsplitter@comp{%
  \edef\@bs@wd{\POE@key@bssize\space 2.0 div }%
  \ifx\POE@key@bsstyle\POE@str@bsstyle@cube
    \psline[arrows=cc-cc](! \@bs@wd neg 2 sqrt mul 0)
                  (! \@bs@wd 2 sqrt mul 0)
    \rput[c]{45}(0,0){%
      \psframe(! \@bs@wd neg \@bs@wd neg)(! \@bs@wd \@bs@wd)
    }
  \else\ifx\POE@key@bsstyle\POE@str@bsstyle@plate
    \psline(! \@bs@wd neg 2 sqrt mul 0)(! \@bs@wd 2 sqrt mul 0)
  \fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\crystal@ref}
%    \begin{macrocode}
\def\crystal@ref{%
  \let\POE@key@optboxwidth\POE@key@crystalwidth
  \let\POE@key@optboxheight\POE@key@crystalheight
  \optbox@ref
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\crystal@comp}
%    \begin{macrocode}
\def\crystal@comp{%
  \edef\@wd{\POE@key@crystalwidth\space 0.5 mul }
  \edef\@ht{\POE@key@crystalheight\space 0.5 mul }
  \psframe(! \@wd neg \@ht neg)(! \@wd \@ht)
  \ifPOE@voltage%
    \psline(!\@wd 4 div 3 mul neg \@ht)%
           (! \@wd 4 div 3 mul neg \@ht 0.2 add)
    \pscircle[fillstyle=solid, fillcolor=white]%
      (! \@wd 4 div 3 mul neg \@ht 0.2 add){0.04}
    \psline(! \@wd 4 div 3 mul neg \@ht neg)%
           (! \@wd 4 div 3 mul neg \@ht neg 0.2 sub)%
    \psline(! \@wd 4 div 3 mul neg 0.15 sub \@ht neg 0.2 sub)%
           (! \@wd 4 div 3 mul neg 0.15 add \@ht neg 0.2 sub)%
  \fi
  \ifPOE@lamp
    \rput{180}(! \@wd \@ht 1.4 \POE@key@lampscale\space mul add){%
      \crystal@lamp
    }%
  \fi
  \ifdim\POE@key@caxislength pt>0pt
    \edef\@c@caxisL{\POE@key@caxislength\space 2 div }%
    \ifPOE@caxisinv
      \psline[style=CrystalCaxis](! 0 \@ht neg)%
                                 (! 0 \@ht \@c@caxisL add)%
    \else
      \psline[style=CrystalCaxis](! 0 \@ht)%
                                 (! 0 \@ht neg \@c@caxisL sub)%
    \fi
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\crystal@lamp}
%    \begin{macrocode}
\def\crystal@lamp{%
  \psset{linewidth=0.6\pslinewidth}
  \edef\@sz{\POE@key@lampscale\space}%
  \pscurve[fillstyle=none](! -0.05 \@sz mul 0)%
          (! -0.1 \@sz mul 0.15 \@sz mul)%
          (! -0.2 \@sz mul 0.25 \@sz mul)%
          (! -0.25 \@sz mul 0.5 \@sz mul)%
          (! 0 0.7 \@sz mul)%
          (! 0.25 \@sz mul 0.5 \@sz mul)%
          (! 0.2 \@sz mul 0.25 \@sz mul)%
          (! 0.1 \@sz mul 0.15 \@sz mul)%
          (! 0.05 \@sz mul 0)
  \multido{\i=-210+40}{7}{%
    \rput{\i}(! 0 0.45 \@sz mul){%
      \psline(! -0.35 \@sz mul 0)(! -0.6 \@sz mul 0)
    }
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\polarization@comp}
%    \begin{macrocode}
\def\polarization@comp{%
  \edef\@sz{\POE@key@polsize\space 0.5 mul }%
  \psset{style=Polarization}%
  \ifx\POE@key@poltype\POE@str@pol@polparallel
    \psline[arrows=<->](! 0 \@sz neg)(! 0 \@sz)
  \fi
  \ifx\POE@key@poltype\POE@str@pol@polperp
    \psdot(0,0)
    \pscircle[fillstyle=none](0,0){0.12}
  \fi
  \ifx\POE@key@poltype\POE@str@pol@polmisc
    \psline[arrows=<->](! 0 \@sz neg)(! 0 \@sz)
    \psdot(0,0)
    \pscircle[fillstyle=none](0,0){0.12}
  \fi
  \ifx\POE@key@poltype\POE@str@pol@polrcirc
    \psellipticarc[arrows=->]%
      (0,0)(! \@sz 2 div \@sz){20}{-20}
  \fi
  \ifx\POE@key@poltype\POE@str@pol@pollcirc
    \psellipticarc[arrows=<-]%
      (0,0)(! \@sz 2 div \@sz){20}{-20}
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optgrating@ref}
%    \begin{macrocode}
\def\optgrating@ref{%
  \POE@Verb{/@@x \POE@key@gratingwidth\space 0.5 mul def}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optgrating@comp}
%    \begin{macrocode}
\def\optgrating@comp{%
  \edef\@cnt{\POE@key@gratingcount\space}%
  \edef\@wd{\POE@key@gratingwidth\space 2 div }%
  \edef\@ht{\POE@key@gratingheight\space}%
  \edef\@dp{\POE@key@gratingdepth\space}%
  \edef\@step{\POE@key@gratingwidth\space\@cnt div }%
  \ifx\POE@key@gratingtype\POE@str@gratingtype@blazed
    \pscustom[linewidth=\POE@key@gratinglinewidth, linejoin=1]{%
      \psline[liftpen=1](! \@wd \@dp)(! \@wd \@ht)%
                        (! \@wd neg \@ht)(! \@wd neg \@dp)%
      \multido{\i=0+1}{\POE@key@gratingcount}{%
        \psline[liftpen=1]%
          (! \@wd neg \i\space \@step mul add \@dp)%
          (! \@wd neg \i\space 
             \ifPOE@reverse\else 1 add \fi \@step mul add 0)%
          (! \@wd neg \i\space 1 add \@step mul add \@dp)%
      }%
      \closepath
    }%
  \else\ifx\POE@key@gratingtype\POE@str@gratingtype@binary
    \pscustom[linewidth=\POE@key@gratinglinewidth]{%
      \psline[liftpen=1](! \@wd \@dp)(! \@wd \@ht)%
                        (! \@wd neg \@ht)(! \@wd neg \@dp)%
      \multido{\i=0+1}{\POE@key@gratingcount}{%
        \psline[liftpen=1]%
          (! \@wd neg \i\space \@step mul add \@dp)%
          (! \@wd neg \i\space \@step mul add 0)%
          (! \@wd neg \i\space 0.5 add \@step mul add 0)%
          (! \@wd neg \i\space 0.5 add \@step mul add \@dp)%
          (! \@wd neg \i\space 1 add \@step mul add \@dp)%
      }%
    }%
  \fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optbox@ref}
%    \begin{macrocode}
\def\optbox@ref{%
  \POE@Verb{%
    /@@x \POE@key@optboxwidth\space 0.5 mul def
    /@@y \POE@key@optboxheight\space 0.5 mul def
  }%
  \ifPOE@endbox
    \POE@Verb{/@@x0 @@x def}%
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optbox@comp}
%    \begin{macrocode}
\def\optbox@comp{%
  \edef\@wd{\POE@key@optboxwidth\space 0.5 mul }
  \edef\@ht{\POE@key@optboxheight\space 0.5 mul }
  \ifPOE@endbox
    \psframe[dimen=outer](! 0 \@ht neg)(! \@wd 2 mul \@ht)
  \else
    \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
  \fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optplate@ref}
%    \begin{macrocode}
\def\optplate@ref{%
  \POE@Verb{/@@y \POE@key@plateheight\space 0.5 mul def }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optplate@comp}
%    \begin{macrocode}
\def\optplate@comp{%
   \psline[linewidth=\POE@key@platelinewidth]%
     (! \POE@dict{0 @@y neg})(! \POE@dict{0 @@y})
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optdetector@ref}
%    \begin{macrocode}
\def\optdetector@ref{%
  \POE@Verb{/@@x0 \POE@key@detsize\space 0.5 mul def}%
  \ifx\POE@key@dettype\POE@str@dettype@diode
    \POE@Verb{ @@x0 dup /@@x ED /@@y ED}%
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optdetector@nodes}
%    \begin{macrocode}
\def\optdetector@nodes{%
  \newOptexpComp{{ 0 0} { 0 1 } refl {PlaneIfc} 1 }%
  \ifx\POE@key@dettype\POE@str@dettype@round
    \pnode(! \POE@key@detsize\space 0.2 mul 0){\oenodeCenter{}}%
  \else\ifx\POE@key@dettype\POE@str@dettype@diode
    \pnode(! \POE@key@detsize\space 0.5 mul 0){\oenodeCenter{}}
  \fi\fi
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optdetector@comp}
%    \begin{macrocode}
\def\optdetector@comp{%
   \pnode(\oenodeRefB{}){\oenodeIn{}}
   \ifx\POE@key@dettype\POE@str@dettype@round
      \begin@ClosedObj
%    \end{macrocode}
% I could have use pswedge but then a correction of the component size
% depending on the current linewidth is not possible
%    \begin{macrocode}
         \addto@pscode{%
           CLW 0.5 mul 0 
           \POE@key@detsize\space\pst@number\psrunit mul 0.5 mul 
           CLW sub -90 90 arc closepath }%
      \end@ClosedObj
   \else\ifx\POE@key@dettype\POE@str@dettype@diode
      \edef\@sz{\POE@key@detsize\space 0.5 mul }%
      \psframe[dimen=outer](! 0 \@sz neg)(!\@sz 2 mul \@sz)
      \pspolygon(! \@sz 0.8 mul \@sz -0.4 mul)%
             (! \@sz 1.6 mul \@sz -0.4 mul)%
             (! \@sz 1.2 mul \@sz 0.4 mul)%
      \psline(! \@sz 0.8 mul \@sz 0.4 mul \getCLWH add)%
             (! \@sz 1.6 mul \@sz 0.4 mul \getCLWH add)
      \psset{arrows=->, arrowinset=0, arrowscale=0.8}
      \psline(! \@sz 0.2 mul \@sz 0.3 mul)%
             (! \@sz 0.7 mul \@sz 0.15 mul)
      \psline(! \@sz 0.2 mul 0)(! \@sz 0.7 mul \@sz -0.15 mul)
   \fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optretplate@ref}
%    \begin{macrocode}
\def\optretplate@ref{%
   \POE@Verb{%
     /@@y \POE@key@plateheight\space 0.5 mul def
     /@@x \POE@key@platewidth\space 0.5 mul def
   }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optretplate@comp}
%    \begin{macrocode}
\def\optretplate@comp{%
   \edef\@ht{\POE@key@plateheight\space 0.5 mul }%
   \edef\@wd{\POE@key@platewidth\space 0.5 mul }%
   \psframe(! \@wd neg \@ht neg)(! \@wd \@ht)
   \psline{cc-cc}(! \@wd neg \@ht)(! \@wd \@ht neg)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optdiode@ref}
%    \begin{macrocode}
\def\optdiode@ref{%
  \POE@Verb{%
    \POE@key@optdiodesize\space 0.5 mul dup /@@y ED /@@x ED 
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optdiode@comp}
%    \begin{macrocode}
\def\optdiode@comp{%
   \edef\@sz{\POE@key@optdiodesize\space}%
   \psframe[dimen=outer](! \@sz -0.5 mul dup)(!\@sz 0.5 mul dup)
   \pspolygon(! \@sz -0.2 mul \@sz -0.2 mul)
             (! \@sz -0.2 mul \@sz 0.2 mul)
             (! \@sz 0.2 mul 0)
   \psline(! \@sz 0.2 mul \getCLWH add \@sz 0.2 mul)%
          (! \@sz 0.2 mul \getCLWH add \@sz -0.2 mul)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\doveprism@nodes}
%    \begin{macrocode}
\def\doveprism@nodes{%
  \newOptexpComp{%
    {\POE@key@doveprismsize\space neg 0} {1 1} trans {PlaneIfc}
    {0 \POE@key@doveprismsize\space -0.5 mul} {1 0} refl {PlaneIfc}
    {\POE@key@doveprismsize\space 0} {-1 1} trans {PlaneIfc} 
    \POE@key@n true 
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\doveprism@comp}
%    \begin{macrocode}
\def\doveprism@comp{%
   \edef\@ht{\POE@key@doveprismsize\space 0.5 mul }%
   \edef\@wd{\POE@key@doveprismsize\space 1.5 mul }%
   \pspolygon(! \@wd neg \@ht neg)%
             (! \@wd \@ht neg)%
             (! \@ht dup)%
             (! \@ht neg \@ht)%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\pentaprism@nodes}
%    \begin{macrocode}
\def\pentaprism@nodes{%
  \edef\@sz{\POE@key@pentaprismsize\space}%
  \newOptexpComp{%
    {\@sz 2 sqrt -2 mul div dup } {-1 1} trans {PlaneIfc}
    {\@sz 2 sqrt div 67.5 cos \@sz mul 
      67.5 sin 2 mul div sub \@sz 2 div}
    { 67.5 cos \@sz mul 67.5 sin div neg \@sz} 
      refl {PlaneIfc}
    {\@sz 2 sqrt div neg 67.5 cos \@sz mul 
      67.5 sin 2 mul div add \@sz 2 div}
    { 67.5 cos \@sz mul 67.5 sin div \@sz} refl {PlaneIfc}
    {\@sz 2 sqrt 2 mul div dup neg} {1 1} trans {PlaneIfc} 
    \POE@key@n
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\pentaprism@comp}
%    \begin{macrocode}
\def\pentaprism@comp{%
  \edef\@sz{\POE@key@pentaprismsize\space}%
  \pscustom{%
    \psline(! \@sz 2 sqrt div 0)%
           (! \@sz 2 sqrt div 67.5 cos \@sz mul 
              67.5 sin div sub \@sz)%
           (! 67.5 cos \@sz mul 67.5 sin div \@sz 
              2 sqrt div sub \@sz)%
           (! \@sz 2 sqrt div neg 0)%
           (! 0 \@sz 2 sqrt div neg)%
    \closepath
  }%
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optprism@nodes}
%    \begin{macrocode}
\def\optprism@nodes{%
  \edef\@sz{\POE@key@prismsize\space}%
  \edef\@altan{\POE@key@prismangle\space 0.5 mul tan }%
  \edef\@hshift{%
    \@sz 0.6 mul \@altan mul \POE@dict{OEangle} 0.5 mul tan div 
  }%
  \newOptexpComp{%
    {\@sz -0.6 mul \@altan mul \@hshift neg} 
    {90 \POE@key@prismangle\space 0.5 mul sub dup cos exch sin} 
    trans {PlaneIfc}
    {\@sz 0.6 mul \@altan mul \@hshift neg} 
    {90 \POE@key@prismangle\space 0.5 mul add dup cos exch sin} 
    trans {PlaneIfc} \POE@key@n true }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optprism@comp}
%    \begin{macrocode}
\def\optprism@comp{%
  \edef\@sz{\POE@key@prismsize\space}%
  \edef\@altan{\POE@key@prismangle\space 0.5 mul tan }%
  \edef\@hshift{%
    \@sz 0.6 mul \@altan mul \POE@dict{OEangle} 0.5 mul tan div %
  }%
  \pspolygon(! \@sz neg \@altan mul \@sz -0.4 mul \@hshift sub)
            (! \@sz \@altan mul \@sz -0.4 mul \@hshift sub)
            (! 0 \@sz 0.6 mul \@hshift sub)
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\rightangleprism@nodes}
%    \begin{macrocode}
\def\rightangleprism@nodes{%
  \edef\@sz{\POE@key@raprismsize\space 0.5 mul }%
  \edef\@ht{\POE@dict{OEangle 0.5 mul sin modA mul} }%
  \newOptexpComp{%
    {\@ht neg \@ht \@sz sub} {1 0} trans {PlaneIfc}
    {\@ht neg 0} {1 1} refl {PlaneIfc}
    {\@ht 0} {1 -1} refl {PlaneIfc}
    {\@ht dup \@sz sub } {1 0} trans {PlaneIfc} 
    \POE@key@n 
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rightangleprism@comp}
%    \begin{macrocode}
\def\rightangleprism@comp{%
  \edef\@sz{\POE@key@raprismsize\space 0.5 mul }%
  \edef\@ht{\POE@dict{OEangle 0.5 mul sin modA mul} }%
  \pspolygon(! \@sz neg \@ht \@sz sub)
            (! \@sz \@ht \@sz sub)
            (! 0 \@ht)%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Fiber optics}
%
% \begin{macro}{\optfiber@nodes}
%    \begin{macrocode}
\def\optfiber@nodes{%
  \pnode(! \POE@key@fiberloopsep\space
           \POE@key@fiberloops\space 
           1 sub mul -0.5 mul 0){\oenodeIn{}}
  \pnode(! \POE@key@fiberloopsep\space
           \POE@key@fiberloops\space 
           1 sub mul 0.5 mul 0){\oenodeOut{}}
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optfiber@comp}
%    \begin{macrocode}
\def\optfiber@comp{%
  \edef\@f@cnt{\POE@key@fiberloops\space}%
  \edef\@f@r{\POE@key@fiberloopradius\space}%
  \edef\@f@sep{\POE@key@fiberloopsep\space}%
  \parametricplot[plotpoints=200, style=Fiber]{0}{1}{%
    t 360 mul \@f@cnt mul sin \@f@r mul \@f@sep 
    \@f@cnt 1 sub mul t 0.5 sub mul add
     1 t 360 mul \@f@cnt mul cos sub \@f@r mul
  }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optmzm@ref}
%    \begin{macrocode}
\def\optmzm@ref{%
  \POE@Verb{%
    \POE@key@optmzmsize\space dup 0.8 mul /@@x ED 0.5 mul /@@y ED 
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optmzm@comp}
%    \begin{macrocode}
\def\optmzm@comp{%
  \def\@wd{\POE@key@optmzmsize\space 0.8 mul }%
  \def\@ht{\POE@key@optmzmsize\space 0.5 mul }%
  \bgroup
    \ifPOE@usefiberstyle
      \psset{style=Fiber}
    \fi
    \psline(! \@wd neg 0)(! \@wd -0.7 mul 0)%
           (! \@wd -0.4 mul \@ht 0.6 mul)%
           (! \@wd 0.4 mul \@ht 0.6 mul)(! \@wd 0.7 mul 0)%
           (! \@wd 0)(! \@wd 0.7 mul 0)%
           (! \@wd 0.4 mul \@ht -0.6 mul)%
           (! \@wd -0.4 mul \@ht -0.6 mul)(! \@wd -0.7 mul 0)%
  \egroup
  \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optfilter@ref}
%    \begin{macrocode}
\def\optfilter@ref{%
  \POE@Verb{\POE@key@filtersize\space 0.5 mul dup /@@y ED /@@x ED }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optfilter@comp}
%    \begin{macrocode}
\def\optfilter@comp{%
  \edef\@sz{\POE@key@filtersize\space 0.5 mul }%
  \def\filter@curve{%
    \parametricplot[plotstyle=curve,arrows=c-c]{-1}{1}{%
      t \@sz mul 0.7 mul t Pi mul RadtoDeg 
      90 add cos 0.2 \@sz mul mul}%
  }%
  \psframe[dimen=outer](! \@sz neg dup)(! \@sz dup)
  \ifx\POE@key@filtertype\POE@str@filtertype@bandpass
    \psline(! -0.3 \@sz mul -0.65 \@sz mul)%
           (! 0.3 \@sz mul -0.35 \@sz mul)%
    \psline(! -0.3 \@sz mul 0.35 \@sz mul)%
           (! 0.3 \@sz mul 0.65 \@sz mul)%
    \rput(! 0 -0.5 \@sz mul){\filter@curve}
    \rput(0, 0){%
      \ifPOE@usefiberstyle
        \psset{style=Fiber}
      \fi
      \filter@curve}
    \rput(! 0 0.5 \@sz mul){\filter@curve}
  \else\ifx\POE@key@filtertype\POE@str@filtertype@bandstop
    \psline(! -0.3 \@sz mul -0.15 \@sz mul)%
           (! 0.3 \@sz mul 0.15 \@sz mul)%
    \rput(! 0 -0.5 \@sz mul){%
      \ifPOE@usefiberstyle
        \psset{style=Fiber}
      \fi
      \filter@curve}
      \rput(0, 0){\filter@curve}
      \rput(! 0 0.5 \@sz mul){%
        \ifPOE@usefiberstyle
          \psset{style=Fiber}
        \fi
        \filter@curve}
  \else\ifx\POE@key@filtertype\POE@str@filtertype@lowpass
    \psline(! -0.3 \@sz mul -0.15 \@sz mul)%
           (! 0.3 \@sz mul 0.15 \@sz mul)%
    \psline(! -0.3 \@sz mul 0.35 \@sz mul)%
           (! 0.3 \@sz mul 0.65 \@sz mul)%
    \rput(! 0 -0.5 \@sz mul){%
      \ifPOE@usefiberstyle
        \psset{style=Fiber}
      \fi
      \filter@curve}
      \rput(0, 0){\filter@curve}
      \rput(! 0 0.5 \@sz mul){\filter@curve}
  \else\ifx\POE@key@filtertype\POE@str@filtertype@highpass
    \psline(! -0.3 \@sz mul -0.15 \@sz mul)%
           (! 0.3 \@sz mul 0.15 \@sz mul)%
    \psline(! -0.3 \@sz mul -0.65 \@sz mul)%
           (! 0.3 \@sz mul -0.35 \@sz mul)%
    \rput(! 0 0.5 \@sz mul){%
      \ifPOE@usefiberstyle
        \psset{style=Fiber}
      \fi
      \filter@curve}
      \rput(0, 0){\filter@curve}
      \rput(! 0 -0.5 \@sz mul){\filter@curve}
  \fi\fi\fi\fi
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optamp@nodes}
%    \begin{macrocode}
\def\optamp@nodes{%
  \edef\@sz{\POE@key@optampsize\space 0.5 mul }%
  \edef\@xl{0.75 sqrt \@sz mul }%
  \pnode(!\@xl neg 0){\oenodeIn{}}
  \pnode(!\@xl 0){\oenodeOut{}}  
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optamp@comp}
%    \begin{macrocode}
\def\optamp@comp{%
  \edef\@sz{\POE@key@optampsize\space 0.5 mul }%
  \edef\@xl{0.75 sqrt \@sz mul }%
  \pspolygon(! \@xl 0)(! \@xl neg \@sz)(! \@xl neg \@sz neg)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\polcontrol@comp}
%    \begin{macrocode}
\def\polcontrol@comp{%
   \edef\@sz{\POE@key@polcontrolsize\space}%
   \ifPOE@usefiberstyle
      \psset{style=Fiber}%
   \fi
   \multips(! -2 \@sz mul \@sz)(! 2 \@sz mul 0){3}{%
     \pscircle(0,0){\POE@key@polcontrolsize}%
   }%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optisolator@ref}
%    \begin{macrocode}
\def\optisolator@ref{%
  \POE@Verb{%
    \POE@key@isolatorsize\space dup 0.8 mul /@@x ED 0.5 mul /@@y ED 
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optisolator@comp}
%    \begin{macrocode}
\def\optisolator@comp{%
  \edef\@ht{\POE@key@isolatorsize\space 0.5 mul }%
  \edef\@wd{\POE@key@isolatorsize\space 0.8 mul }%
  \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
  \psline[style=IsolatorArrow,
          arrows=->](! \@wd neg 0.6 mul 0)(!\@wd 0.6 mul 0)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optfiberpolarizer@ref}
%    \begin{macrocode}
\def\optfiberpolarizer@ref{%
  \POE@Verb{%
    \POE@key@fiberpolsize\space dup 0.8 mul /@@x ED 0.5 mul /@@y ED 
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optfiberpolarizer@comp}
%    \begin{macrocode}
\def\optfiberpolarizer@comp{%
  \edef\@ht{\POE@key@fiberpolsize\space 0.5 mul }%
  \edef\@wd{\POE@key@fiberpolsize\space 0.8 mul }%
  \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
  \psline(! \@wd neg 0.2 mul \@ht neg)(!\@wd 0.2 mul \@ht)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optswitch@ref}
%    \begin{macrocode}
\def\optswitch@ref{%
  \POE@Verb{\POE@key@switchsize\space 0.5 mul dup /@@y ED /@@x ED }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optswitch@comp}
%    \begin{macrocode}
\def\optswitch@comp{%
  \edef\@sz{\POE@key@switchsize\space 0.5 mul }%
%    \end{macrocode}
% storing the linewidth of the object allows for some aesthetic fine tuning 
%    \begin{macrocode}
  \pstVerb{tx@Dict begin /@lw \getCLW def end}%
  \bgroup
    \ifPOE@usefiberstyle
      \psset{style=Fiber}
    \fi
    \psline[arrows=-](! \@sz neg 0)(! \@sz -0.6 mul @lw sub 0)%
    \psline[arrows=-](! \@sz 0.6 mul 0)(! \@sz 0)%
  \egroup
  \ifx\POE@key@switchstyle\POE@str@closed%
    \bgroup
      \ifPOE@usefiberstyle
        \psset{style=Fiber}
      \fi
      \psdot[dotsize=3\pslinewidth](! \@sz 0.6 mul 0)%
      \psdot[dotsize=3\pslinewidth](! \@sz -0.6 mul 0)%
      \psline[arrows=-, linewidth=1.5\pslinewidth]%
        (! \@sz -0.6 mul @lw)(! \@sz 0.6 mul @lw)%      
    \egroup
  \else
    \psline[arrows=-, linewidth=1.5\pslinewidth]%
      (! \@sz -0.6 mul @lw add @lw)(! \@sz 0.6 mul dup)%
    \pscircle(! \@sz -0.6 mul 0){\pslinewidth}%
    \psdot[dotsize=3\pslinewidth](! \@sz 0.6 mul 0)%
  \fi
  \psframe[dimen=outer](! \@sz neg dup)(! \@sz dup)%
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fiberdelayline@ref}
%    \begin{macrocode}
\def\fiberdelayline@ref{%
  \POE@Verb{%
    \POE@key@fdlsize\space dup 0.8 mul /@@x ED 0.5 mul /@@y ED 
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fiberdelayline@comp}
%    \begin{macrocode}
\def\fiberdelayline@comp{%
  \def\@wd{\POE@key@fdlsize\space 0.8 mul }%
  \def\@ht{\POE@key@fdlsize\space 0.5 mul }%
  \psframe[dimen=outer](! \@wd neg \@ht neg)(! \@wd \@ht)
  \psline[style=FdlArrow](! \@wd -0.3 mul \@ht -1.5 mul)%
                         (! \@wd 0.3 mul \@ht 1.2 mul CLW 
                            \pst@number\psyunit div 5 mul add)
\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\optcoupler@nodes}
%    \begin{macrocode}
\def\optcoupler@nodes{%
  \edef\@sz{\POE@key@couplersize\space}%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@align\POE@str@top
    \def\@yshift{\@sep neg }%
  \else\ifx\POE@key@align\POE@str@bottom
    \def\@yshift{\@sep\space}%
  \else
    \def\@yshift{0 }%
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \pnode(! \@sz -0.5 mul \@yshift \@sep add){\oenode{1}{}}
    \pnode(! \@sz -0.5 mul \@yshift \@sep sub){\oenode{2}{}}
    \pnode(! \@sz 0.5 mul \@yshift \@sep add){\oenode{3}{}}
    \pnode(! \@sz 0.5 mul \@yshift \@sep sub){\oenode{N}{}}
  \else
    \pnode(! \@sz neg \getCLW 0.3 mul add 
             \@yshift \@sep add){\oenode{1}{}}
    \pnode(! \@sz neg \getCLW 0.3 mul add 
             \@yshift \@sep sub){\oenode{2}{}}
    \pnode(! \@sz \getCLW 0.3 mul sub 
             \@yshift \@sep add){\oenode{3}{}}
    \pnode(! \@sz \getCLW 0.3 mul sub 
             \@yshift \@sep sub){\oenode{N}{}}
  \fi
  \pnode(! 0 \@yshift){\oenodeCenter{}}
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\optcoupler@comp}
%    \begin{macrocode}
\def\optcoupler@comp{%
  \edef\@sz{\POE@key@couplersize\space}%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@align\POE@str@top
    \def\@yshift{\@sep neg }%
  \else\ifx\POE@key@align\POE@str@bottom
    \def\@yshift{\@sep\space}%
  \else
    \def\@yshift{0 }%
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \psline[style=Fiber](\oenode{1}{})(\oenode{3}{})
    \psline[style=Fiber](\oenode{2}{})(\oenode{N}{})
  \else\ifx\POE@key@couplertype\POE@str@couplertype@elliptic
    \psellipse[dimen=outer](!0 \@yshift)(! \@sz \@sz 0.4 mul)
  \else\ifx\POE@key@couplertype\POE@str@couplertype@rectangular
    \psframe[dimen=outer](!\@sz neg \@yshift \@sz 0.4 mul sub )%
                         (!\@sz \@yshift \@sz 0.4 mul add)
  \else\ifx\POE@key@couplertype\POE@str@couplertype@crossswitch
    \psframe[dimen=outer](!\@sz neg \@yshift \@sz sub )%
                         (!\@sz \@yshift \@sz add)
    \edef\@sz{\POE@key@couplersize\space 0.5 mul }
    \psline(! \@sz neg dup)(! \@sz dup)
    \psline(! \@sz neg \@sz)(! \@sz dup neg)
  \fi\fi\fi\fi
  \ifPOE@variable
    \psline[style=VariableCoupler]%
      (!\@sz -0.5 mul \@sz neg \@yshift add)%
      (!\@sz 0.5 mul \@sz \@yshift add)
  \fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmcoupler@nodes}
%    \begin{macrocode}
\def\wdmcoupler@nodes{%
  \edef\@sz{\POE@key@couplersize\space}%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@align\POE@str@center
      \edef\@sep{0 }%
    \fi
  \fi
  \ifx\POE@key@align\POE@str@top
    \def\@yshift{\@sep neg }%
  \else\ifx\POE@key@align\POE@str@bottom
    \def\@yshift{\@sep }%
  \else
    \def\@yshift{0 }%
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \pnode(! \@sz -0.5 mul \@yshift \@sep add){\oenode{1}{}}
    \pnode(! \@sz -0.5 mul \@yshift \@sep sub){\oenode{2}{}}
    \pnode(! \@sz 0.5 mul 0){\oenode{N}{}}
  \else
    \pnode(! \@sz neg \getCLW 0.3 mul add 
             \@yshift \@sep add){\oenode{1}{}}
    \pnode(! \@sz neg \getCLW 0.3 mul add 
             \@yshift \@sep sub){\oenode{2}{}}
    \pnode(! \@sz \getCLW 0.3 mul sub 0){\oenode{N}{}}
  \fi
  \pnode(! 0 \@yshift){\oenodeCenter{}}
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmcoupler@comp}
%    \begin{macrocode}
\def\wdmcoupler@comp{%
  \edef\@sz{\POE@key@couplersize\space}%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@align\POE@str@center
      \edef\@sep{0 }%
    \fi
  \fi
  \ifx\POE@key@align\POE@str@top
    \def\@yshift{\@sep neg }%
  \else\ifx\POE@key@align\POE@str@bottom
    \def\@yshift{\@sep\space}%
  \else
    \def\@yshift{0 }%
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@elliptic
    \psellipse[dimen=outer](!0 \@yshift)(! \@sz \@sz 0.4 mul)
  \else\ifx\POE@key@couplertype\POE@str@couplertype@rectangular
    \psframe[dimen=outer](!\@sz neg \@yshift \@sz 0.4 mul sub )%
                         (!\@sz \@yshift \@sz 0.4 mul add)
  \else\ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@align\POE@str@top
      \psline[style=Fiber](\oenode{1}{})(\oenodeOut{})
      \psline[style=Fiber]%
        (!/N@\oenodeOut{} \POE@dict{@GetCenter} 
          \tx@UserCoor \POE@key@couplersep\space sub)(\oenode{2}{})
    \else
      \psline[style=Fiber](\oenode{2}{})(\oenodeOut{})
      \ifx\POE@key@align\POE@str@bottom
        \psline[style=Fiber]%
          (!/N@\oenodeIn{} \POE@dict{@GetCenter} 
            \tx@UserCoor \POE@key@couplersep\space sub)(\oenode{1}{})
      \fi
    \fi
  \fi\fi\fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmsplitter@nodes}
%    \begin{macrocode}
\def\wdmsplitter@nodes{%
  \edef\@sz{\POE@key@couplersize\space}%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@align\POE@str@center
      \edef\@sep{0 }%
    \fi
  \fi
  \ifx\POE@key@align\POE@str@top
    \def\@yshift{\@sep neg }%
  \else\ifx\POE@key@align\POE@str@bottom
    \def\@yshift{\@sep }%
  \else
    \def\@yshift{0 }%
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \pnode(! \@sz -0.5 mul 0){\oenode{1}{}}
    \pnode(! \@sz 0.5 mul \@yshift \@sep add){\oenode{2}{}}
    \pnode(! \@sz 0.5 mul \@yshift \@sep sub){\oenode{N}{}}
  \else
    \pnode(! \@sz neg \getCLW 0.3 mul add 0){\oenode{1}{}}
    \pnode(! \@sz \getCLW 0.3 mul sub 
             \@yshift \@sep add){\oenode{2}{}}
    \pnode(! \@sz \getCLW 0.3 mul sub 
             \@yshift \@sep sub){\oenode{N}{}}
  \fi
  \pnode(! 0 \@yshift){\oenodeCenter{}}
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\wdmsplitter@comp}
%    \begin{macrocode}
\def\wdmsplitter@comp{%
  \edef\@sz{\POE@key@couplersize\space}%
  \edef\@sep{\POE@key@couplersep\space 0.5 mul }%
  \ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@align\POE@str@center
      \edef\@sep{0 }%
    \fi
  \fi
  \ifx\POE@key@align\POE@str@top
    \def\@yshift{\@sep neg }%
  \else\ifx\POE@key@align\POE@str@bottom
    \def\@yshift{\@sep\space}%
  \else
    \def\@yshift{0 }%
  \fi\fi
  \ifx\POE@key@couplertype\POE@str@couplertype@elliptic
    \psellipse[dimen=outer](!0 \@yshift)(! \@sz \@sz 0.4 mul)
  \else\ifx\POE@key@couplertype\POE@str@couplertype@rectangular
    \psframe[dimen=outer](!\@sz neg \@yshift \@sz 0.4 mul sub )%
                         (!\@sz \@yshift \@sz 0.4 mul add)
  \else\ifx\POE@key@couplertype\POE@str@couplertype@none
    \ifx\POE@key@align\POE@str@top
      \psline[style=Fiber](\oenodeIn{})(\oenode{2}{})
      \psline[style=Fiber](! \POE@dict{/N@\oenodeIn{} @GetCenter}
        \tx@UserCoor \POE@key@couplersep\space sub)(\oenode{N}{})
    \else
      \psline[style=Fiber](\oenodeIn{})(\oenode{N}{})
      \ifx\POE@key@align\POE@str@bottom
        \psline[style=Fiber](! \POE@dict{/N@\oenodeIn{} @GetCenter}
          \tx@UserCoor \POE@key@couplersep\space sub)(\oenode{2}{})
      \fi
    \fi
  \fi\fi\fi
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\fibercollimator@nodes}
%    \begin{macrocode}
\def\fibercollimator@nodes{%
   \def\@sz{\POE@key@fibercolsize\space 0.5 mul }%
   \pnode(!\@sz neg 0){\oenodeIn{}}
   \newOptexpComp{ {\@sz neg 0} {0 1} trans {PlaneIfc} 1 }%
   \pnode(!\@sz 0){\oenodeOut{}}
}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\fibercollimator@comp}
%    \begin{macrocode}
\def\fibercollimator@comp{%
   \def\@sz{\POE@key@fibercolsize\space 0.5 mul }%
   \pspolygon(! \@sz neg \getCLWH add \@sz neg)%
             (!\@sz 0)(!\@sz neg \getCLWH add \@sz)
}%
%    \end{macrocode}
% \end{macro}
%
%</stylefile> 
%
% \section{The Postscript header file}
% \makeatletter
%% Copied this definition from doc.sty and changed it not to add a
%% backslash to the Postscript procedure name in the index.
% \def\SpecialIndex@#1#2{%
%    \@SpecialIndexHelper@#1\@nil
%    \def\@tempb{ }%
%    \ifcat \@tempb\@gtempa
%       \special@index{\quotechar\space\actualchar
%                      \string\verb\quotechar*\verbatimchar
%                      \quotechar\bslash\quotechar\space\verbatimchar#2}%
%    \else
%      \def\@tempb##1##2\relax{\ifx\relax##2\relax
%           \def\@tempc{\special@index{\quotechar##1\actualchar
%                       \string\verb\quotechar*\verbatimchar
%                       \quotechar\bslash\quotechar##1\verbatimchar#2}}%
%         \else
%           \def\@tempc{\special@index{##1##2\actualchar
%                        \string\verb\quotechar*\verbatimchar##1##2\verbatimchar#2}}%
%         \fi}%
%      \expandafter\@tempb\@gtempa\relax
%      \@tempc
%    \fi}
% \makeatother
%
%<*prolog>
%
% This is the dictionary where all components are stored in.
%    \begin{macrocode}
/tx@OptexpDict 200 dict def
tx@OptexpDict begin
%    \end{macrocode}
% \begin{macro}{strcat}
% Concatenate two strings and leave the result on the stack
% \begin{pssyntax}
%   \PSstring{str1} \PSstring{str2} \PSop{strcat} \PSstring{str1str2}
% \end{pssyntax}
%    \begin{macrocode}
/strcat {
    exch 2 copy
    length exch length add
    string dup dup 5 2 roll
    copy length exch
    putinterval
} bind def
%    \end{macrocode}
% \end{macro}
% \begin{macro}{nametostr}
%    Convert a literal name to string.
% \begin{pssyntax}
%   \PSname{name} \PSop{nametostr} \PSstring{name}
% \end{pssyntax}
%    \begin{macrocode}
/nametostr {
    dup length string cvs
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{nametostr}
%    Convert an integer to a string.
% \begin{pssyntax}
%   \PSvar{int} \PSop{inttostr} \PSstring{int}
% \end{pssyntax}
%    \begin{macrocode}
/inttostr {
  dup type /integertype eq {
    dup log 1 add floor cvi string cvs
  } if
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{calcNodes}
% \begin{pssyntax}
%   \PSvar{XB} \PSvar{YB} \PSvar{XA} \PSvar{YA} \PSvar{XG} \PSvar{YG} \PSop{calcNodes}
% \end{pssyntax}
%    \begin{macrocode}
/calcNodes {
    /YG exch def /XG exch def
    /ay YG 3 -1 roll sub def
    /ax XG 3 -1 roll sub def
    /by exch YG sub def
    /bx exch XG sub def
    /a ax ay Pyth def
%    \end{macrocode}
% This is stored for \nxLcs{rightangleprism}.
%    \begin{macrocode}
    /modA a def
    /b bx by Pyth def
    /cx ax a div bx b div add def
    /cy ay a div by b div add def
    /c@tmp cx cy Pyth def
    /c ax bx add ay by add Pyth def
    /OEangle c dup mul a dup mul sub b dup mul sub 
             -2 a b mul mul div Acos def
%    \end{macrocode}
% If $c=0$, then set the coordinates of the vector manually
% depending on the dotproduct (and thus, if 'a' and 'b'
% are parallel or antiparallel.
%    \begin{macrocode}
    c 0 eq {
      ax ay bx by SProd 0 gt {
%    \end{macrocode}
% If $\text{dotprod} > 0$ then $a$ and $b$ are parallel.
%    \begin{macrocode}
        /cx ax def
        /cy ay def
      }{
%    \end{macrocode}
% else $a$ and $b$ are antiparallel.
%    \begin{macrocode}
        /cx ay def
        /cy ax neg def
      } ifelse
      /c@tmp a def
    } if
    /X@A XG cx c@tmp div add def
    /Y@A YG cy c@tmp div add def
    /X@B XG cx c@tmp div sub def
    /Y@B YG cy c@tmp div sub def
%    \end{macrocode}
% chirality:
% test the order of the input points as a input angle $> 90$°
% doesn't really make sense.
% So if chir $<= 0$ exchange the calculated coordinates of 
% A and B and otherwise leave it as is
%    \begin{macrocode}
    /chirality ax by mul ay bx mul sub def
    chirality 0 le {
      Y@A X@A 
      /X@A X@B def
      /Y@A Y@B def
      /X@B exch def
      /Y@B exch def
    }if
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{capHeight}
% Calculate the height \PSvar{a} of a pole cap. 
% \begin{pssyntax}
%   \PSvar{R} \PSvar{h} \PSop{capHeight} \PSvar{a}
% \end{pssyntax}
% \PSvar{R} is the circle radius and \PSvar{h} the width of the pole cap.
%    \begin{macrocode}
/capHeight {
    dup mul neg exch abs dup 3 1 roll dup mul add sqrt sub
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{leftCurvedIfc}
%   Calculate some parameters for the left plane of a lens. Defines and
%   \PSname{ArcL} which is used later in the code to actually draw the interface
%   curve.
% \begin{pssyntax}
%   \PSvar{h R1} \PSop{leftCurvedIfc} \PSvar{y |R1| alpha\textunderscore bottom
%     alpha\textunderscore top R1}
% \end{pssyntax}
%    \begin{macrocode}
/leftCurvedIfc {
  /R1 exch def /h exch def
  0 R1 abs dup R1 h capHeight exch sub R1 sign mul dup
  h exch atan exch
  h neg exch atan
  R1 0 lt {
    /ArcL /arcn load def
  } {
    /ArcL /arc load def
  } ifelse
  R1
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{rightCurvedIfc}
%   Analogous to \PSname{leftCurvedIfc} for «right» interfaces, defines
%   \PSname{ArcR} for later use.
% \begin{pssyntax}
%   \PSvar{h R2} \PSop{leftCurvedIfc} \PSvar{y |R2| alpha\textunderscore bottom
%     alpha\textunderscore top R2}
% \end{pssyntax}
%    \begin{macrocode}
/rightCurvedIfc {
  /R2 exch def /h exch def
  0 R2 abs dup R2 h capHeight sub R2 sign mul dup
  h neg exch atan exch
  h exch atan
  R2 0 lt {
    /ArcR /arcn load def
  } {
    /ArcR /arc load def
  } ifelse
  R2
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{FiberAngleB}
%   Calculate angle of a line from \PSname{nodeA} to \PSname{nodeB}.
%   \begin{pssyntax}
%     \PSname{nodeB} \PSname{nodeA} \PSop{FiberAngleB} \PSvar{angle}
%   \end{pssyntax}
%    \begin{macrocode}
/FiberAngleB {
    @GetCenter 3 -1 roll @GetCenter @ABVect exch atan
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{FiberAngleA}
% Calculate angle of line from \PSvar{nodeB} to \PSvar{nodeA}.
%   \begin{pssyntax}
%     \PSvar{nodeA} \PSvar{nodeB} \PSop{FiberAngleA} \PSvar{angle}
%   \end{pssyntax}
%    \begin{macrocode}
/FiberAngleA {
    FiberAngleB 180 add
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{ExtNode}
%   Constructs the coordinates of an external node based on values that
%   have been set beforehand.
% \begin{pssyntax}
%   \PSvar{xref yref} \PSop{ExtNode} \PSvar{X Y}  
% \end{pssyntax}
%    \begin{macrocode}
/ExtNode {%
  @@y mul RefFac mul @@y0 add 
  exch @@x mul RefFac mul @@x0 add exch
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetInternalNodeNames}
%   Push all internal node names of \PSstring{basicnodename} on the
%   stack. If \PSvar{reverse} is \PSvar{true}, the names are pushed in
%   reverse order.
%   \begin{pssyntax}
%     \PSstring{basicnodename} \PSvar{reverse} \PSop{GetInternalNodeNames}
%     \PSname{N@basicnodenameN} \ldots{} \PSname{N@basicnodename1} (if
%     \PSvar{reverse = false})
%   \end{pssyntax}
%    \begin{macrocode}
/GetInternalNodeNames {
  /reverse ED
  dup cvn currentdict exch known {
%    \end{macrocode}
% This is the safe way to do it, but it works only for free-ray
% components which were defined by \PSvar{NewOptexpComp}.
%    \begin{macrocode}
    dup cvn load /N get dup
    reverse { -1 1 } { 1 1 3 -1 roll } ifelse
    { 2 copy eq { pop (N) } { inttostr } ifelse
      3 -1 roll dup 4 1 roll exch NodeName 3 1 roll
    } for
    pop pop
  } {
%    \end{macrocode}
% This is the old implementation which still must be used for fiber
% components. This implementation was only a problem in special cases
% for free-ray components, so this should not be an issue to keep it for
% the fiber components.
%    \begin{macrocode}
    1 {
      2 copy dup inttostr 3 -1 roll exch NodeName dup
      tx@NodeDict exch known {
        reverse {
          4 1 roll pop
        } {
          exch 2 add 1 roll
        } ifelse
      } {
        reverse {
          pop pop pop (N) NodeName
        } {
          pop pop exch (N) NodeName exch 1 roll
        } ifelse
        exit
      } ifelse
      1 add
    } loop
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetInternalBeamNodes}
%   This is like \PSvar{GetInternalNodeNames}, but leaves the node
%   coordinates on the stack
% \begin{pssyntax}
%   \PSstring{basicnodename} \PSvar{reverse} \PSop{GetInternalBeamNodes}
%   $x_N$ $y_N$ \ldots\ $x_1$ $y_1$ (if \PSvar{reverse = false})
% \end{pssyntax}
%    \begin{macrocode}
/GetInternalBeamNodes {
  [ 3 1 roll GetInternalNodeNames ]
  { @GetCenter } forall
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{GetInternalBeamNodesCompat}
%   Equivalent to \PSvar{GetInternalBeamNodes} only that it checks if the
%   component is ambiguous (i.e. it is a beamsplitter), in which case it returns
%   only the center node.
%    \begin{macrocode}
/GetInternalBeamNodesCompat {
  exch dup 3 1 roll (C) NodeName dup tx@NodeDict exch known {
    @GetCenter ToVec 
    3 1 roll pop pop
  } {
    pop GetInternalBeamNodes
  } ifelse
} bind def
/GetInternalBeamNodeCompat {
  exch dup 3 1 roll (C) NodeName dup tx@NodeDict exch known {
    @GetCenter ToVec
    3 1 roll pop pop
  } {
    pop NodeName @GetCenter ToVec
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{InitOptexpComp}
%   Initialize some global variables for positioning of external
%   nodes. This is called at the beginning of every component.
%    \begin{macrocode}
/InitOptexpComp {%
  /@@x 0 def
  /@@y 0 def
  /@@x0 0 def
  /@@y0 0 def
  /@xref 0 def
  /@yref 0 def
  /RefFac 1 def
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{NewTempNodeComp}
%   If \nxLcs{draw*beam} is invoked with a node as parameter, a
%   temporary \nxLcs{optplane} is defined. However, this temporary plane
%   does not have a fixed plane vector, but is adjusted such that it is
%   perpendicular to the connection between the node and the following
%   interface node. 
%
%   This is the only procedure which sets the \PSname{adjustRel} flag
%   which indicates adjustment of the plane vector rotation depending on
%   the incoming or outgoing connection direction.
% 
%   For an explanation of the other dictionary member, please see
%   \PSvar{NewOptexpComp}.
%   \begin{pssyntax}
%     \PSproc{x y} \PSproc{dx dy} (name) \PSproc{scaling}
%   \end{pssyntax}
%    \begin{macrocode}
/NewTempNodeComp {
  /sc ED
  dup cvn
  6 dict dup 3 1 roll def begin
    /ambiguous false def
    /name ED
    /correct false def
%    \end{macrocode}
% This definition does not work like for \PSvar{NewOptexpComp}, because
% a current point may not be available. Therefore, we translate to the
% $(X, Y)$ node and define $X = Y = 0$.
%    \begin{macrocode}
    {0 0} exch 3 -1 roll exec
    gsave
      translate
      /CompMtrx CM def
    grestore
    /N 1 def
    /n 1 def
    5 dict dup dup /P@1 ED /P@N ED
    begin
      /mode trans def
      {} PlaneIfc
    end
  /adjustRel true def
  end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{CurvedIfc}
% Defines a curved interface.
% \begin{pssyntax}
%   \PSop{CurvedIfc}
% \end{pssyntax}
%    \begin{macrocode}
/CurvedIfc {
    2 copy 5 3 roll exec 3 -1 roll exec VecAdd 
    5 -1 roll exec /Y ED /X ED
    exch exec 3 -1 roll exec 2 copy tx@Dict begin Pyth end 
    /R ED /RY ED /RX ED
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PlaneIfc}
%    \begin{macrocode}
/PlaneIfc {
    dup 3 -1 roll exec 3 -1 roll exec /DY ED /DX ED
    exch exec 3 -1 roll exec /Y ED /X ED
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NewCompIfc}
% Defines a new interface of a component, must be called within \PSvar{NewOptexpComp}.
% \begin{pssyntax}
%   \PSproc{x y} \PSproc{dx dy | rx ry} mode (CompName) (Name) \PSproc{New\ldots Ifc} \PSproc{scaling} \PSop{NewCompIfc}
% \end{pssyntax}
% \begin{psarglist}
% \psargitem{\PSproc{x y}} The coordinates of the interface node which lies on the optical axis.??
% \psargitem{\PSproc{dx dy | rx ry}} For a plane interface, this is the vector that describes the plane, for a curved interface this is the
% \psargitem{\PSvar{mode}} An integer which characterizes if an interface is
%   reflective or transmittive. You should use the predefined variable
%   \PSname{refl} and \PSname{trans} for this.
% \psargitem{\PSstring{CompName}} The name of the component we are in.
% \psargitem{\PSstring{Name}} The name of the new interface. It is prefixed by «P@».
% \psargitem{\PSproc{\ldots Ifc}} Contain the actual procedure to define the
%   concrete interface type, can be \PSproc{PlaneIfc} or
%   \PSproc{CurvedIfc}.
% \end{psarglist}
%    \begin{macrocode}
/NewCompIfc {
  /scl ED
  /next ED
  dup (P@) exch strcat cvn
  5 dict dup
  3 1 roll def
  begin
    3 -1 roll
    /mode ED
    4 -1 roll dup 5 -1 roll
    {scl} next
  end
%    \end{macrocode}
% store a new node \PSname{N@NameX}, with X=1..N this node always
% represents the intersection of an untilted and unshifted incoming beam
% on the optical axis with the respective interface
%    \begin{macrocode}
  exec scl ToVec 3 1 roll NodeName @NewNode
} bind def
%    \end{macrocode}
% \end{macro}
% 
% Define some constants.
%    \begin{macrocode}
/refl 0 def /trans 1 def
/desc 0 def /asc 1 def /amb 2 def
/missed 0 def /tir 1 def /ok 2 def
%    \end{macrocode}
% 
% About the design:
% NewOptexpComp creates a new dictionary that contains everything needed
% for an optical component. It contains the following variables:
% /n             -> refractive index (is usually 1)
% /CompMtrx      -> current matrix to store the planes correctly
% /name          -> name of the component
% /N             -> number of planes
% /P@1 ... /P@N  -> planes used for the 'ray tracing'
%
% \begin{macro}{NewOptexpComp}
% \PSvar{NewOptexpComp} creates a new dictionary that contains everything needed
% for an optical component. It contains the following variables:
% \begin{psarglist} 
%   \psargitem{\PSvar{n}} The basic refractive index which was set for
%   the component. This may be overwritten with the \opt{n} option or
%   changed by \opt{nmul} and \opt{nadd} options of the \nxLcs{drawbeam}
%   macros.  
%
%   \psargitem{\PSvar{CompMtrx}} The transformation matrix at time of
%   the component definition. The method is the same as for the
%   \nxLPack{pst-node} nodes.
%
%   \psargitem{\PSvar{name}} The name of the component. This is build of
%   several components which are put together in the \TeX\ code.
%
%   \psargitem{\PSvar{N}} The number of interfaces of the component.
%
%   \psargitem{\PSvar{P@1\ldots P@N}} The actual
%   interfaces. \PSvar{P@1} and \PSvar{P@N} are always defined, even if
%   \PSvar{N = 1}. In that case the two names link to the same
%   dictionary, so that changes in one of them are automatically present
%   also in the second one.
%
%   \psargitem{\PSproc{sc}} The scaling procedure for the coordinates to convert
%   from \TeX{} to Postscript scaling. In should always be defined as
%   \PSproc{\textbackslash psxunit, \textbackslash psyunit}.
%
%   \psargitem{\PSvar{ambiguous}} There is a class of components (at the
%   moment only \nxLcs{beamsplitter}), which have a central interface
%   \PSvar{P@C} which can be either transmittive or reflective,
%   depending on the previous and following component positions. The
%   mode of the \PSvar{P@C} is determined at the time of the beam
%   drawing and requires special attention.
%
%   \psargitem{\PSvar{correct}} If \opt{true}, the input vectors after
%   the transmittive interfaces are corrected when using
%   \opt{connectplanes}.
% \end{psarglist}
%
% \begin{pssyntax}
%   \PSvar{[} \PSproc{x y} \PSproc{dx dy | rx ry} \PSvar{type}
%   \PSproc{\ldots Ifc} \PSvar{\ldots{} n correct?} \PSstring{CompName}
%   \PSproc{scaling} \PSvar{amb?} \PSop{NewOptexpComp}
% \end{pssyntax}
%    \begin{macrocode}
/NewOptexpComp {
  3 1 roll /sc ED 
  dup cvn
  gsave
  11 dict dup 3 1 roll def begin
  /name ED
  /ambiguous ED
  dup type /booleantype eq not { false } if /correct ED
  tx@Dict begin
    STV {CP T} stopped pop
  end
  /CompMtrx CM def
  grestore
  counttomark dup 4 idiv dup /N ED 4 mul eq { 1 } if /n ED
  1 N eq {
%    \end{macrocode}
% only a single plane is specified, create the aliases.
%    \begin{macrocode}
      ambiguous { 
        name (C) 3 -1 roll {sc} NewCompIfc
        (C) (1) IfcAlias
        (C) (N) IfcAlias
      } {
        name (1) 3 -1 roll {sc} NewCompIfc 
        (1) (N) IfcAlias
      } ifelse
  }{
      ambiguous {
        name (C) 3 -1 roll {sc} NewCompIfc
        /N N 1 sub def
      } if
      N -1 1 { %
        dup N eq { pop (N) }{inttostr} ifelse
        exch name 3 1 roll {sc} NewCompIfc
      } for
  } ifelse
  end
  pop
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{IfcAlias}
%   Create an alias of an interface. This involves creating also an
%   alias for the associated node.  Must be called withing
%   \PSvar{NewOptexpComp}.
%
% \PSstring{OrigPN} \PSstring{AliasPN} \PSop{IfcAlias}
%    \begin{macrocode}
/IfcAlias {
  2 copy IfcName exch IfcName load def
  tx@NodeDict begin 
    name exch NodeName name 3 -1 roll NodeName load def
  end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetPlaneVec}
% PlaneNumber CompName -> PlaneVec
%    \begin{macrocode}
/GetPlaneVec {
    cvn load begin
        IfcName load begin
            currentdict /RX known {
              RX RY CompMtrx dtransform CM idtransform
              neg exch
            } {
              DX DY CompMtrx dtransform CM idtransform
            } ifelse
        end
    end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetPlaneCenter}
% PlaneNumber CompName -> NodeCenter
% or
% \PSproc{Plane} -> NodeCenter
%    \begin{macrocode}
/GetPlaneCenter {
    dup type /stringtype eq not {
      dup xcheck not {
%    \end{macrocode}
% ambiguous
%    \begin{macrocode}
        0 get (C) exch
      } {
        exec pop pop pop
      } ifelse
    } if
    cvn load begin
      IfcName load begin
        currentdict /RX known {
          X RX sub Y RY sub
        } {
          X Y
        } ifelse
        CompMtrx transform CM itransform
      end
    end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TransformInVec}
% InVec is relative to the connection between first and second components
% transform to absolute coordinates
% Plane2 Plane1 \PSproc{InVec} -> \PSproc{InVec'}
%    \begin{macrocode}
/TransformInVec {
    3 1 roll
    GetPlaneCenter 4 2 roll
    GetPlaneCenter 5 -2 roll
    @ABVect
    3 -1 roll exec 2 copy 6 2 roll
    0 eq exch 0 eq and not {
%    \end{macrocode}
% invec != (0,0)
%    \begin{macrocode}
      exch atan matrix rotate dtransform
    } {
      4 2 roll pop pop
    } ifelse
    ToVec
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TransformStartPos}
% Startpos is relative to the connection between first and second components
% transform to absolute coordinates and shift by first plane center
% Plane2 Plane1 \PSproc{StartPos} -> \PSproc{StartPos'+Plane1Center}
%    \begin{macrocode}
/TransformStartPos {
    exec 2 copy 6 2 roll 0 eq exch 0 eq and not
    3 1 roll GetPlaneCenter 4 2 roll
    GetPlaneCenter 5 2 roll {
      2 copy 8 2 roll
      @ABVect exch atan matrix rotate dtransform
      VecAdd
    } {
      6 2 roll pop pop pop pop
    } ifelse
    ToVec
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetNearestPlane}
% X Y CompName -> PlaneNumber
%    \begin{macrocode}
/GetNearestPlane {
  3 copy 1 exch GetPlaneCenter @ABDist /dist ED /nearestPlane 1 def
  dup cvn load /N get 2 1 3 -1 roll {
%    \end{macrocode}
% iterate through plane 2 to plane N of CompName 
%    \begin{macrocode}
    4 copy exch GetPlaneCenter @ABDist dup dist lt {
      /dist ED /nearestPlane ED
    } {
      pop pop
    } ifelse
  } for
  pop pop pop nearestPlane
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PushAmbCompPlanesOnStack}
% Components which do not have an unambiguous behaviour (beamslitter, can
% transmit and reflect) like lenses (transmission only) or mirrors (reflection
% only), must be evaluated to see which mode should be used.  Argument is
% [(name) draw], draw is a boolean which is true if the inner beams should be
% drawn.
%    \begin{macrocode}
/PushAmbCompPlanesOnStack {
  currentdict /outToPlane undef
  PN PlaneNum eq not {
%    \end{macrocode}
% not the last plane, there should be another one on the stack
%    \begin{macrocode}
    exch dup 3 1 roll % plane ambcomp plane
    dup xcheck not {
%    \end{macrocode}
% the next component is also an ambcomp, use its center point as reference.
%    \begin{macrocode}
      0 get (C) exch
    } {
%    \end{macrocode}
% otherwise use the plane node
%    \begin{macrocode}
      exec pop pop pop
    } ifelse
    [ 3 1 roll ] cvx /outToPlane ED
%    \end{macrocode}
% outToPlane is \{(PN) (compName)\}
%    \begin{macrocode}
  } if
%    \end{macrocode}
% the old plane number, without counting the additional planes of the current ambcomp
%    \begin{macrocode}
  /PlaneNumTmp PlaneNum def
  aload pop /draw ED /name ED
  name cvn load /N get /N ED
  currentdict /Curr known {
    /CurrTmp /Curr load def
    /CurrVecTmp /CurrVec load def
  } {
    /CurrTmp /CurrLow load def
    /CurrVecTmp /CurrVecLow load def
  } ifelse
%    \end{macrocode}
% CurrTmp is the current point of the beam on the previous plane, CurrVecTmp its outgoing vector.
%    \begin{macrocode}
  1 N eq {
%    \end{macrocode}
% only a single interface
%    \begin{macrocode}
    [ (C) name 1 
    PN 1 eq PN PlaneNum eq or {
%    \end{macrocode}
% its the first or last comp
%    \begin{macrocode}
      trans
    } {
%    \end{macrocode}
% somewhere in the middle, check the mode (trans or refl)
%    \begin{macrocode}
      CurrVecTmp (C) name GetPlaneVec NormalVec outToPlane 
      GetPlaneCenter (C) name GetPlaneCenter @ABVect SProd
      0 lt { trans } { refl } ifelse % mode
    } ifelse
    true ] cvx
  } {
%    \end{macrocode}
% three interfaces
%    \begin{macrocode}
    PN 1 eq {
%    \end{macrocode}
% first component
%    \begin{macrocode}
      [ (C) name
      nforce 0 eq { name cvn load /n get } { nforce } ifelse
      trans draw ] cvx
%    \end{macrocode}
% now check which is the outgoing plane
%    \begin{macrocode}
      name /outToPlane load GetNextPlane
      [ exch name 1 trans draw ] cvx exch
      /PlaneNumTmp PlaneNumTmp 1 add def
    } {
      CurrTmp name GetNearestPlane /nextPlane ED
%    \end{macrocode}
% check if mode is trans or refl
%    \begin{macrocode}
      CurrVecTmp nextPlane name GetPlaneVec NormalVec
      (C) name GetPlaneCenter nextPlane name GetPlaneCenter 
      @ABVect 2 copy 6 2 roll SProd 
      0 lt { trans }{ refl } ifelse
      3 1 roll ToVec /CurrVecTmp ED
      [ nextPlane name
      connectplanes {
        1
      }{
        nforce 0 eq { name cvn load /n get } { nforce } ifelse
      } ifelse
%    \end{macrocode}
% always draw to first interface
%    \begin{macrocode}
      5 -1 roll true ] cvx
      PN PlaneNum eq {
%    \end{macrocode}
% its the last comp, just put the center plane on the stack
%    \begin{macrocode}
        [ (C) name
        nforce 0 eq { name cvn load /n get } { nforce } ifelse
        trans draw ] cvx exch
        /PlaneNumTmp PlaneNumTmp 1 add def
      } {
%    \end{macrocode}
% check the mode
%    \begin{macrocode}
        [ (C) name
        nforce 0 eq { name cvn load /n get } { nforce } ifelse
        CurrVecTmp (C) name GetPlaneVec NormalVec outToPlane 
        GetPlaneCenter (C) name GetPlaneCenter @ABVect SProd
        0 lt { trans } { refl } ifelse % mode
        draw ] cvx exch
%    \end{macrocode}
% now check which is the outgoing plane
%    \begin{macrocode}
        name /outToPlane load GetNextPlane
        [ exch name 1 trans draw ] cvx 3 1 roll
        /PlaneNumTmp PlaneNumTmp 2 add def
      } ifelse
    } ifelse
  } ifelse
  /PlaneNum PlaneNumTmp def
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{GetNextPlane}
% \PSstring{comp} \PSproc{outToPlane} $\longmapsto$ \PSvar{PlaneNumber}
%    \begin{macrocode}
/GetNextPlane {
  2 copy (C) 3 -1 roll
  GetPlaneCenter 3 -1 roll exec GetPlaneCenter 
  4 2 roll 4 copy @ABVect /VecY ED /VecX ED 
  @ABDist /centerDist ED
  /sprod 1 def
  exch dup 3 1 roll cvn load /N get 1 1 3 -1 roll {
%    \end{macrocode}
% iterate through all planes of CompName
%    \begin{macrocode}
    3 copy 3 -1 roll 2 copy
    GetPlaneVec VecX VecY 4 2 roll NormalVec 
    VecX VecY SProd dup sprod lt 5 2 roll
    GetPlaneCenter 3 -1 roll exec GetPlaneCenter @ABDist 
    centerDist lt and
    { /sprod ED /nextPlane ED } { pop pop } ifelse
  } for
  pop pop nextPlane
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TraceBeam}
% [ CompN ... Comp1 \PSproc{options} \PSproc{start point} \PSvar{beamangle}
% -> Yn Xn drawToN? ... Y1 X1 drawTo1? Y0 X0
%    \begin{macrocode}
/TraceBeam {
  AngToVec /InVec ED /StartPoint ED
  /oldbeaminsidelast currentdict /beaminsidelast known { 
    beaminsidelast 
  } { 
    false 
  } ifelse def
%    \end{macrocode}
% preset options
%    \begin{macrocode}
  /nmul 1 def
  /nadd 0 def
  /nforce 0 def
%    \end{macrocode}
% execute options
%    \begin{macrocode}
  exec
  connectplanes {
    /nforce 1 def
  } if
  /startinside startinside beaminsidefirst or def
  /stopinside stopinside beaminsidelast or def
  /PrevCorrect false def
  counttomark /N ED
  PrearrangePlanes
  PushAllPlanesOnStack
  beamangleabs not {
    2 copy /InVec load TransformInVec
  } {
    /InVec load
  } ifelse
  /CurrVec ED
  currentdict /lastBeamPointTmp known {
    /lastBeamPointTmp load /Curr ED
  }{
    2 copy /StartPoint load  TransformStartPos /Curr ED
  } ifelse
  counttomark /PlaneNum ED 
%    \end{macrocode}
% Init the refractive index
%    \begin{macrocode}
  /n1 1 def
  /PN 1 def
  { 
%    \end{macrocode}
% iterate over all planes
%    \begin{macrocode}
    dup xcheck not {
%    \end{macrocode}
% array, not executable
%    \begin{macrocode}
      PushAmbCompPlanesOnStack
    } if
    %% {PlaneNumber CompName n mode draw}
    exec
    /draw ED
    /Mode ED
    3 1 roll % n PlaneNumber CompName
    cvn load begin % comp dict
      IfcName load begin % plane dict, n on stack
        X Y
        CompMtrx transform CM itransform % n1 X Y
        2 copy ToVec 4 1 roll % {X Y} n1 X Y
        currentdict /RX known { RX RY } { DX DY	} ifelse
        CompMtrx dtransform CM idtransform  % {X Y} n1 X Y DX DY
        Mode 6 -1 roll % {X Y} X Y DX DY mode n1
        Curr CurrVec % {X Y} X Y DX DY mode n1 X0 Y0 X_in Y_in
        currentdict /RX known 
        correct
      end
    end
%% {Xp Yp} Xp Yp dXp dYp trans/refl n2 X0 Y0 X_in Y_in curved? correct?
    /correct ED
    12 -1 roll /CurrCenter ED
    5 1 roll % curved? X0 Y0 X_in Y_in
    connectplanes PrevCorrect and PN 2 ge and {
      CurrVec CurrCenter CurrCenterTmp PrevMode 
      currentdict /relAngle known 
      { relAngle } { 0 } ifelse connectPlanes
      /relAngle ED
    } if
    5 -1 roll
    { CurvedInterface }{ PlainInterface } ifelse

    missed eq {
      counttomark PN 1 sub 3 mul sub {pop} repeat
      exit
    } if

    PN 1 eq {
      pop pop
      /draw beaminsidefirst oldbeaminsidelast xor def
    } {
      ToVec /CurrVec ED
    } ifelse
    2 copy
    ToVec /Curr ED 
    draw PN skipconn 1 add gt and
    counttomark 3 roll
    /CurrCenterTmp /CurrCenter load def
    /lastBeamPointTmp /Curr load def
    /lastVec /CurrVec load def
    /PrevMode Mode def
    /PrevCorrect correct def
    PN PlaneNum eq {
      exit
    } {
      CurrVec 0 eq exch 0 eq and {
%    \end{macrocode}
% last refraction was total internal reflection, exit!
%    \begin{macrocode}
        PlaneNum PN sub {pop} repeat
        exit
      } if
      /PN PN 1 add def
    } ifelse
  } loop
  currentdict /CurrVec undef
  currentdict /Curr undef
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{Drawbeam}
% [ CompN ... Comp1 \PSproc{options} \PSproc{start point} \PSproc{input vector}
%    \begin{macrocode}
/Drawbeam {
  counttomark 3 eq {
%    \end{macrocode}
% first ray misses the next interface
%    \begin{macrocode}
    pop pop pop pop
  }{
%    \end{macrocode}
% Go to start point
%    \begin{macrocode}
    pop 5 copy 3 -1 roll pop ArrowA pop pop pop pop
    counttomark 3 idiv -1 2 {
      pop {
        lineto
      }{
        moveto
      } ifelse
    } for
    {CP 4 2 roll ArrowB lineto pop pop } {moveto} ifelse
%    \end{macrocode}
% remove [
%    \begin{macrocode}
    pop
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{sign}
%    \begin{macrocode}
/sign {
    0 ge { 1 } { -1 } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TraceWideBeam}
%   Stroke a wide beam. Only rearranges the input parameters and calls
%   \PSvar{TraceBeam} twice, for the upper and lower beam.
% \begin{pssyntax}
%   \PSvar{[ CompN \ldots{} Comp1} \PSproc{options} \PSproc{start point
%     up} \PSproc{beamangle\_up} \PSproc{start point low}
%   \PSproc{beamangle\_low} \PSop{TraceWideBeam}
% \end{pssyntax}
%    \begin{macrocode}
/TraceWideBeam {
  5 -1 roll dup 6 1 roll 3 1 roll
  counttomark 6 sub /numComp ED
  numComp 7 add 6 roll numComp 1 add copy
  numComp 1 add 2 mul 6 add numComp 1 add roll
  numComp 1 add 3 add -3 roll
  currentdict /lastBeamPointTmp undef
  loadbeampoints currentdict /lastBeamPointLow known and {
    /lastBeamPointLow load /lastBeamPointTmp ED
  } if
  TraceBeam
  savebeampoints {
    /lastBeamPointTmp load /lastBeamPointLow ED
    /lastVec load /lastVecLow ED
  } if
  currentdict /lastBeamPointTmp undef
  loadbeampoints currentdict /lastBeamPointUp known and {
    /lastBeamPointUp load /lastBeamPointTmp ED
  } if
  counttomark 1 add dup numComp 4 add add exch roll
  TraceBeam
  savebeampoints {
    /lastBeamPointTmp load /lastBeamPointUp ED
    /lastVec load /lastVecUp ED
    lastBeamPointUp lastBeamPointLow @ABVect 
    lastVecUp lastVecLow 3 -1 roll add 3 1 roll add exch
    4 -1 roll mul 3 1 roll mul sub 0 gt {
%    \end{macrocode}
% swap upper and lower beam points for next beam
%    \begin{macrocode}
      /lastBeamPointUp load /lastBeamPointLow load
      /lastBeamPointUp ED /lastBeamPointLow ED
    } if
  } if
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{FillWideBeam}
% Fill a wide beam. This has an own procedure, because each segment
% of the beam must be filled separately.
% \begin{pssyntax}
%   \PSvar{[} \PSstring{CompN} \PSvar{\ldots{}} \PSstring{Comp1}
%   \PSproc{options} \PSproc{start point up} \PSvar{beamangle\_up}
%   \PSproc{start point low} \PSvar{beamangle\_low} \PSop{FillWideBeam}
% \end{pssyntax}
%    \begin{macrocode}
/FillWideBeam {
  AngToVec /InvecLow ED /StartLow ED 
  AngToVec /InvecUp ED /StartUp ED 
%    \end{macrocode}
% preset options
%    \begin{macrocode}
  /nmul 1 def
  /nadd 0 def
  /nforce 0 def
%    \end{macrocode}
% execute user options
%    \begin{macrocode}
  exec
  connectplanes {
    /nforce 1 def
  } if
  /startinside startinside beaminsidefirst or def
  /stopinside stopinside beaminsidelast or def
%    \end{macrocode}
% Number of segments already drawn
%    \begin{macrocode}
  /DrawnSegm 0 def
%    \end{macrocode}
% whether the previous plane required correction of the input vector (used only with \opt{connectplanes})
%    \begin{macrocode}
  /PrevCorrect false def
  PrearrangePlanes
  PushAllPlanesOnStack
%    \end{macrocode}
% If the \opt{beamangle} is not absolute, use the connection between the first
% two planes as reference and transform the input vectors accordingly.
%    \begin{macrocode}
  beamangleabs not {
    2 copy /InvecLow load TransformInVec /CurrVecLow ED
    2 copy /InvecUp load TransformInVec /CurrVecUp ED
  } {
    /InvecLow load /CurrVecLow ED
    /InvecUp load /CurrVecUp ED
  } ifelse
%    \end{macrocode}
% If \opt{loadbeampoints} is set, the nodes \PSname{TmpLastBeamPointLow} and
% \PSname{TmpLastBeamPointUp} are defined and used as starting points.
%    \begin{macrocode}
  currentdict /TmpLastBeamPointLow known 
  currentdict /TmpLastBeamPointUp known and {
    /TmpLastBeamPointLow load /CurrLow ED
    /TmpLastBeamPointUp load /CurrUp ED
  } {
    2 copy /StartLow load TransformStartPos /CurrLow ED
    2 copy /StartUp load TransformStartPos /CurrUp ED
  } ifelse
%    \end{macrocode}
% \PSvar{PlaneNum} is the number of interfaces pushed on the stack by
% \PSvar{PushAllPlanesOnStack}. This number may be corrected later if an
% ambiguous components is among them.
%    \begin{macrocode}
  counttomark /PlaneNum ED 
  /n1 1 def
  /CurrR false def
  /PN 1 def
  {
    dup xcheck not {
%    \end{macrocode}
% Found an array (not executable) instead of a procedure. This is an ambiguous
% component, resolve the interfaces depending on the input vector and
% surrounding interfaces. This can change \PSvar{PlaneNum}.
%    \begin{macrocode}
      PushAmbCompPlanesOnStack
    } if
%    \end{macrocode}
% push the interface on the stack
%    \begin{macrocode}
    exec
%    \end{macrocode}
% \PSvar{draw} indicates if the beam to the current interface should be drawn.
%    \begin{macrocode}
    PN skipconn 1 add gt and /draw ED
%    \end{macrocode}
% \PSvar{Mode} stores the mode (transmittive or reflective) of the current interface.
%    \begin{macrocode}
    /Mode ED
%    \end{macrocode}
% Enter the component dictionary
%    \begin{macrocode}
    3 1 roll cvn load begin
%    \end{macrocode}
% Enter the interface dictionary and push all required information on the stack
%    \begin{macrocode}
      IfcName load begin
        X Y CompMtrx transform CM itransform
        2 copy ToVec 4 1 roll
        currentdict /RX known {
          RX RY 
        } {
          DX DY
        } ifelse
        CompMtrx dtransform CM idtransform 4 copy
        Mode 10 -1 roll
        6 copy 
        currentdict /RX known
        correct
      end
    end
    /correct ED
    /curved ED
    /oldn1 n1 def 
    % {X Y} X Y DX DY X Y DX DY mode n1 X Y DX DY mode n1
%    \end{macrocode}
% \PSvar{CurrPCenter} holds the coordinates of the current interface center.
%    \begin{macrocode}
    17 -1 roll /CurrPCenter ED
%    \end{macrocode}
% Calculate new upper vector and intersection point
%    \begin{macrocode}
    CurrUp CurrVecUp
    connectplanes PrevCorrect PN 2 ge and and {
      CurrVecUp CurrPCenter CurrPCenterTmp PrevMode 
      currentdict /relAngleUp known { relAngleUp } { 0 } ifelse 
      connectPlanes /relAngleUp ED
    } if
    2 copy ToVec /OldVecUp ED
    curved { CurvedInterface } { PlainInterface } ifelse
    dup /ret ED
    missed eq {
      counttomark {pop} repeat exit
    } if
    /CurrUp load /OldUp ED
    ToVec /CurrVecUp ED
    ToVec /CurrUp ED
    /n1 oldn1 def
%    \end{macrocode}
% Calculate new lower vector and intersection point
%    \begin{macrocode}
    CurrLow CurrVecLow
    connectplanes PrevCorrect PN 2 ge and and {
      CurrVecLow CurrPCenter CurrPCenterTmp PrevMode 
      currentdict /relAngleLow known { relAngleLow } { 0 } ifelse 
      connectPlanes /relAngleLow ED
    } if
    2 copy ToVec /OldVecLow ED
    curved { CurvedInterface } { PlainInterface } ifelse
    dup missed eq {
      /ret ED
      counttomark {pop} repeat exit
    } if
    tir eq ret tir eq or {
      /ret tir def
    } {
      /ret ok def
    } ifelse
    /CurrLow load /OldLow ED
    ToVec /CurrVecLow ED
    ToVec /CurrLow ED
%    \end{macrocode}
% lower done
%    \begin{macrocode}
    /OldR CurrR def
    curved {
      tx@Dict begin Pyth end /CurrR ED
    } {
      pop pop /CurrR false def
    } ifelse
%    \end{macrocode}
% radius done, X Y still on stack
%    \begin{macrocode}
    OldR type /realtype eq {
      /CurrCenter load /OldCenter ED
    } if
    curved {
      ToVec /CurrCenter ED
    } {
      pop pop
      /CurrCenter false def
    } ifelse
%    \end{macrocode}
% center done
%    \begin{macrocode}
    PN 1 gt {
      draw {
        /DrawnSegm dup load 1 add def
        OldUp moveto CurrUp lineto
        curved {
          CurrCenter CurrUp CurrLow 
          4 copy 3 -1 roll eq 3 1 roll eq and {
            6 {pop} repeat
          } {
            TangentCrosspoint
            CurrLow CurrR arct
          } ifelse
        } {
          CurrLow lineto
        } ifelse
        OldLow lineto
        OldR type /booleantype eq not {
%    \end{macrocode}
% previous interface was also curved
%    \begin{macrocode}
          OldCenter OldLow OldUp
          4 copy 3 -1 roll eq 3 1 roll eq and {
            6 {pop} repeat
          } {
            TangentCrosspoint
            OldUp OldR arct
          } ifelse
        } {
          OldUp lineto
        } ifelse
      } if
      Mode refl eq draw and
      draw not DrawnSegm 0 gt and or {
        fillBeam newpath
        /DrawnSegm 0 def
      } if
    } {
%    \end{macrocode}
% PN == 1
%    \begin{macrocode}
      /CurrVecUp /OldVecUp load def
      /CurrVecLow /OldVecLow load def
    } ifelse
    PN PlaneNum eq {
      DrawnSegm 0 gt { fillBeam newpath } if
      exit
    } {
      ret tir eq {
%    \end{macrocode}
% at least one of the last two refractions was total internal reflection, exit!
%    \begin{macrocode}
        PlaneNum PN sub {pop} repeat
        DrawnSegm 0 gt { fillBeam newpath } if	
        exit
      } if
      /PN PN 1 add def
    } ifelse
    /CurrPCenterTmp /CurrPCenter load def
    /PrevMode Mode def
    /PrevCorrect correct def
  } loop
  ret missed eq not {
    CurrUp CurrLow @ABVect 
    CurrVecUp CurrVecLow 3 -1 roll add 3 1 roll add exch
    4 -1 roll mul 3 1 roll mul sub 0 gt {
%    \end{macrocode}
% swap upper and lower beam points for next beam
%    \begin{macrocode}
      /TmpLastBeamPointUp /CurrLow load def
      /TmpLastBeamPointLow /CurrUp load def
    } {
      /TmpLastBeamPointLow /CurrLow load def
      /TmpLastBeamPointUp /CurrUp load def
    } ifelse
  } if
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{isAmp}
% Check if 'compname' is ambiguous (i.e. a beamsplitter)
% (compname) -> bool
%    \begin{macrocode}
/isAmb { 
    cvn load /ambiguous get
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{PrearrangePlanes}
%   \begin{pssyntax}
%     \PSvar{[} \PSstring{CompN} \PSvar{\ldots} \PSvar{Comp1} \PSop{PrearrangePlanes}\\
%     \PSvar{[} \PSvar{desc|asc} \PSstring{CompN} \PSvar{\ldots} \PSvar{desc|asc} \PSstring{Comp1}
%   \end{pssyntax}
%    \begin{macrocode}
/PrearrangePlanes {
  counttomark /N ED
  /CompA ED dup /CompB ED
  CompA isAmb {
    amb dup CompA
  } {
    CompB isAmb {
      1 CompA GetPlaneCenter (C) CompB GetPlaneCenter @ABDist
      (N) CompA GetPlaneCenter (C) CompB GetPlaneCenter @ABDist
    } {
      1 CompA GetPlaneCenter 
      1 CompB GetPlaneCenter 
      (N) CompB GetPlaneCenter 
      true OrderNodes exch pop
      (N) CompA GetPlaneCenter 
      1 CompB GetPlaneCenter 
      (N) CompB GetPlaneCenter 
      true OrderNodes exch pop
    } ifelse
    le { desc } { asc } ifelse dup CompA
  } ifelse
  counttomark 2 roll
  2 1 N {
    /i ED exch /CompB ED %
    CompB isAmb not {
      dup desc eq { 1 } { dup amb eq { (C) }{ (N) } ifelse } ifelse 
      CompA GetPlaneCenter
      1 CompB GetPlaneCenter
      (N) CompB GetPlaneCenter false OrderNodes dup dup
%    \end{macrocode}
% check if we have a NodeIfc
%    \begin{macrocode}
      4 -1 roll CompA exch 5 -1 roll CompB exch
      i 2 eq {
%    \end{macrocode}
% check also the first plane
%    \begin{macrocode}
        4 copy 4 2 roll AdjustRelRot
      } if
      AdjustRelRot
    } {
      pop amb dup
    } ifelse
    CompB /CompA CompB def
    counttomark 2 roll
  } for pop
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{AdjustRelRot}
%   Adjusts the relative orientation of \PSstring{CompB} based on the
%   relative connection between \PSstring{CompA} and \PSstring{CompB}.
%   \begin{pssyntax}
%     \PSstring{CompA} \PSvar{desc|asc} \PSstring{CompB} \PSvar{desc|asc} \PSop{AdjustRelRot}
%   \end{pssyntax}
%    \begin{macrocode}
/AdjustRelRot {
  exch dup cvn load /adjustRel known {
    dup dup 4 2 roll isAmb { 
      exch pop (C)
    }{ 
      desc eq { (N) }{ 1 } ifelse 
    } ifelse 
    exch GetPlaneCenter 5 3 roll
    exch dup 3 1 roll isAmb { 
      pop (C)
    }{ 
      desc eq { 1 }{ (N) } ifelse 
    } ifelse 
    exch GetPlaneCenter
    @ABVect exch atan exch
    cvn load begin
      adjustRel {
        matrix rotate CompMtrx matrix concatmatrix /CompMtrx ED
        /adjustRel false def
      } {
        pop
      } ifelse
    end
  } {
    pop pop pop pop
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PushAllPlanesOnStack}
%   \begin{pssyntax}
%     \PSvar{[} \PSvar{desc|asc} \PSstring{CompN} \PSvar{\ldots} \PSvar{desc|asc} \PSstring{Comp1} \PSop{PushAllPlanesOnStack}
%     \PSvar{[} \PSproc{PN \PSstring{CompName} n mode draw?} \PSvar{\ldots{}}
%   \end{pssyntax}
%   \begin{psarglist}
%     \psargitem{PN} The number of the plane of the component \PSstring{CompNameN}, can be an integer or a string.
%     \psargitem{CompName} The name of the component which the interface \PSvar{PN} belongs to.
%     \psargitem{n} The refractive index after the respective interface.
%     \psargitem{mode} Specifies if the interface is transmittive (\PSvar{trans}) or reflective (\PSvar{refl}).
%     \psargitem{draw?} Specifies if the connection to this interface should be drawn or if the current point is only moved.
%   \end{psarglist}
%    \begin{macrocode}
/PushAllPlanesOnStack {
  counttomark 2 div cvi /numComp ED
  1 1 numComp {
%    \end{macrocode}
% iterate over all components
%    \begin{macrocode}
    /last false def
    /first false def
    dup 1 eq {
      /first true def pop beaminsidefirst
    } {
      numComp eq {
        beaminsidelast
        /last true def
      } {
        beaminside
      } ifelse
    } ifelse /drawinside ED
    load dup /ambiguous get {
      /name get drawinside [ 3 1 roll ]
      counttomark 1 roll pop
    } {
      begin
%    \end{macrocode}
% Start of the component dict.
%    \begin{macrocode}
        desc eq {
          N N -1 1 1
        } {
          1 1 1 N N
        } ifelse
        first startinside not and {
%    \end{macrocode}
% first comp and we do not start inside
%    \begin{macrocode}
          5 -2 roll
          pop pop
          2 copy 5 2 roll
        } if
        5 1 roll
        {
%    \end{macrocode}
% iterate over all planes
%    \begin{macrocode}
          3 1 roll 2 copy 5 -1 roll
          dup 3 1 roll
          eq first not and {
%    \end{macrocode}
% always draw the line to the first plane of a component
%    \begin{macrocode}
            true
          } {
%    \end{macrocode}
% the other beams depend on some options
%    \begin{macrocode}
            drawinside
          } ifelse
          exch dup 4 -1 roll eq {
%    \end{macrocode}
% after the last component plane we have always air
%    \begin{macrocode}
            1 
          }{
%    \end{macrocode}
% otherwise the respective refractive index of the component
%    \begin{macrocode}
            nforce 0 eq { n } {nforce} ifelse
          } ifelse
          exch dup N eq {
            pop (N)
          } {
            inttostr
          } ifelse exch
          3 1 roll name
          4 1 roll
          dup IfcName load /mode get
          3 1 roll 5 1 roll
          [ 6 1 roll ] cvx counttomark 1 roll
          last {
            savebeampoints stopinside not and
            savebeampoints not beaminsidelast not and or {
              exit
            } if
          } if
        } for pop pop
      end
    } ifelse
  } for
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{IfcName}
% Construct the interface name from \PSvar{num}. This must be called within a dict of a
% optexpcomp, because the last node ends with (N) instead of the number and we must
% know the number of component interfaces.
% \begin{pssyntax}
% \PSvar{num} \PSop{IfcName} \PSname{P@num}
% \end{pssyntax}
%    \begin{macrocode}
/IfcName {
  dup N eq {
    pop (N)
  } {
    inttostr
  } ifelse
  (P@) exch strcat cvn
} bind def
%    \end{macrocode}
% \end{macro}
% \begin{macro}{NodeName}
% Construct the plane name from PlaneNum. This must be called within a dict of a
% optexpcomp, because the last node ends with (N) instead of the number and we must
% know the plane count of the component.
% \begin{pssyntax}
% \PSstring{name} \PSvar{num} \PSop{NodeName} \PSname{N@namenum}
% \end{pssyntax}
%    \begin{macrocode}
/NodeName {
  dup /stringtype eq not { inttostr } if
  strcat (N@) exch strcat cvn
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{OrderNodes}
%   Check if node (\PSvar{XB1}, \PSvar{YB1}) or (\PSvar{XBN}, \PSvar{YBN}) is nearer to node (\PSvar{XA}, \PSvar{YA}). If it
%   \PSvar{B1} is nearer, push \PSvar{asc} on the stack, otherwise
%   \PSvar{desc}. If \PSvar{calcDist} is \opt{true} it leaves also the actual
%   smallest distance on the stack.
%   \begin{pssyntax}
%     \PSvar{XA YA XB1 YB1 XBN YBN calcDist} \PSop{OrderNodes} \PSvar{desc|asc} \PSvar{distance}
%   \end{pssyntax}
%    \begin{macrocode}
/OrderNodes {
   7 1 roll 6 -2 roll 2 copy 8 2 roll
   @ABDist 5 1 roll @ABDist 2 copy gt {
       pop asc exch
   } {
       exch pop desc exch
   } ifelse
   3 -1 roll not {
       pop
   } if
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{NormalVec}
%   Construct a normal vector $\vec{n}$ to the plane such that its
%   scalar product with the incomping wave vector $\vec{v}_\text{in}$ is
%   negative: $\vec{n}\cdot (-\vec{v}_\text{in}) > 0$.
%   \begin{pssyntax}
%     \PSvar{Xin Yin Xplane Yplane} \PSop{NormalVec} \PSvar{Xnorm Ynorm}
%   \end{pssyntax}
%    \begin{macrocode}
/NormalVec {
  neg exch 2 copy 6 2 roll SProd 0 gt {
    -1 mul exch -1 mul exch
  } if
  NormalizeVec
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{SProd}
% Scalar product between two vectors.
% \begin{pssyntax}
%   \PSvar{Xa Ya Xb Yb} \PSop{SProd} \PSvar{val}
% \end{pssyntax}
%    \begin{macrocode}
/SProd {
    3 -1 roll mul 3 1 roll mul add
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{VecAngle}
% Angle between two vectors $\cos(\alpha) = \frac{ab}{|a||b|}$
% \begin{pssyntax}
%   \PSvar{Xa Ya Xb Yb} \PSop{VecAngle} \PSvar{angle}
% \end{pssyntax}
%    \begin{macrocode}
/VecAngle {
  4 copy 4 copy SProd 5 1 roll 
  tx@Dict begin 
    Pyth 3 1 roll Pyth 
  end mul 
  div Acos
  5 2 roll mul 4 1 roll 3 -1 roll mul 3 -1 roll sub 
  0 le { -1 }{ 1 } ifelse mul
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{VecAdd}
% Addition of two vectors.
% \begin{pssyntax}
%   \PSvar{Xa Ya Xb Yb} \PSop{VecAdd} \PSvar{Xa+Xb Ya+Yb}
% \end{pssyntax}
%    \begin{macrocode}
/VecAdd {
    3 -1 roll add 3 1 roll add exch
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{VecMul}
% Scale a vector by a factor \PSvar{fac}.
% \begin{pssyntax}
%   \PSvar{Xa Ya fac} \PSop{VecMul} \PSvar{fac}$\cdot$\PSvar{Xa} \PSvar{fac}$\cdot$\PSvar{Ya}
% \end{pssyntax}
%    \begin{macrocode}
/VecMul {
  dup 4 -1 roll mul 3 1 roll mul
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ToVec}
%   Convert two numbers to a procedure holding the two values. This
%   representation is used to save coordinate values of nodes and vectors.
%   \begin{pssyntax}
%     \PSvar{X Y} \PSop{ToVec} \PSproc{X Y}
%   \end{pssyntax}
%    \begin{macrocode}
/ToVec {
    [ 3 1 roll ] cvx
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{AngToVec}
%   Convert an angle to the related vector representation (normalized). The
%   angle is with respect to the positive $x$-axis.
% \begin{pssyntax}
%   \PSvar{angle} \PSop{AngToVec} \PSproc{X Y}
%   \end{pssyntax}
%    \begin{macrocode}
/AngToVec {
    dup cos exch sin ToVec
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NormalizeVec}
% Normalize a vector ($X'^2 + Y'^2 = 1$)
% \begin{pssyntax}
%   \PSvar{X Y} \PSop{NormalizeVec} \PSvar{X' Y'}
% \end{pssyntax}
%    \begin{macrocode}
/NormalizeVec {
  2 copy
  tx@Dict begin
    Pyth
  end
  dup 3 1 roll div 3 1 roll div exch
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{@ABVect}
% Shorthand definition for \PSvar{ABVect} procedure of the \nxLPack{pst-eucl} package.
% \begin{pssyntax}
%   \PSvar{Xa Ya Xb Yb} \PSop{@ABVect} \PSvar{dX dY}
% \end{pssyntax}
%    \begin{macrocode}
/@ABVect { 
  tx@EcldDict begin ABVect end 
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{@ABDist}
% Shorthand definition for \PSvar{ABDist} procedure of the \nxLPack{pst-eucl} package.
% \begin{pssyntax}
%   \PSvar{Xa Ya Xb Yb} \PSop{@ABDist} \PSvar{dist}
% \end{pssyntax}
%    \begin{macrocode}
/@ABDist { 
  tx@EcldDict begin ABDist end 
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{@InterLines}
%   Shorthand definition for \PSvar{InterLines} procedure of the
%   \nxLPack{pst-eucl} package. Takes care of a bug in the
%   \nxLPack{pst-eucl} package, that too many items are popped off the
%   stack if no intersection point exists.
% \begin{pssyntax}
%   \PSvar{X1 Y1 X2 Y2 X3 Y3 X4 Y4} \PSop{@InterLines} \PSvar{X Y ret}
% \end{pssyntax}
%    \begin{macrocode}
/@InterLines {
  tx@EcldDict begin
    EqDr /D1c exch def /D1b exch def /D1a exch def
    EqDr /D2c exch def /D2b exch def /D2a exch def
    D1a D2b mul D1b D2a mul sub dup 
    ZeroEq { % parallel lines
      pop 0 0 missed 
    }{
      /Det exch def
      D1b D2c mul D1c D2b mul sub Det div
      D1a D2c mul D2a D1c mul sub Det div
      ok
    } ifelse  
  end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{@GetCenter}
%   Shorthand definition for the \PSvar{GetCenter} procedure of the
%   \nxLPack{pst-node} package. Takes either a string or a literal name
%   for the node name \PSvar{name}.
%   \begin{pssyntax}
%     \PSname{name} \PSop{@GetCenter} \PSvar{X Y}
%   \end{pssyntax}
%    \begin{macrocode}
/@GetCenter { 
  tx@NodeDict begin load GetCenter end 
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{@NewNode}
% Shorthand definition for creating a new pnode.
%    \begin{macrocode}
/@NewNode {
  tx@NodeDict begin 
    false exch 10 {InitPnode } NewNode 
  end
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{RefractVec}
%   Calculate the refracted vector, the normal plane vector must be
%   constructed with \PSvar{NormVec}, see
%   \url{http://en.wikipedia.org/wiki/Snell%27s_law#Vector_form} for the
%     formulas.
%     \begin{pssyntax}
%       \PSvar{Xin Yin Xnorm Ynorm n1 n2} \PSop{RefractVec} \PSvar{Xout Yout}
%     \end{pssyntax}
%  If it would be total internal reflection, the output vector is (0, 0).
%    \begin{macrocode}
/RefractVec {
  div /n ED /Ynorm ED /Xnorm ED
  NormalizeVec /Yin ED /Xin ED 
  n abs 1 eq {
    Xin Yin
  }{
    /costheta1 Xnorm Ynorm Xin neg Yin neg SProd def
    1 n dup mul 1 costheta1 dup mul sub mul sub
    dup 0 lt {
%    \end{macrocode}
% would be total internal reflection, stop
%    \begin{macrocode}
      pop 0 0
    } {
      sqrt /costheta2 ED
      n Xin mul n Yin mul 
      n costheta1 mul costheta2 sub dup 
      Xnorm mul exch Ynorm mul VecAdd
    } ifelse
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{ReflectVec}
%   Calculate the reflected vector, the normal plane vector must be
%   constructed with \PSvar{NormVec}.
%   \begin{pssyntax}
%     \PSvar{Xin Yin Xnorm Ynorm} \PSop{ReflectVec} \PSvar{Xout Yout}
%   \end{pssyntax}
%    \begin{macrocode}
/ReflectVec {
  /Ynorm ED /Xnorm ED NormalizeVec /Yin ED /Xin ED
  /costheta1 Xnorm Ynorm Xin neg Yin neg SProd def
  Xin Yin 2 costheta1 mul dup Xnorm mul exch Ynorm mul VecAdd
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{CurvedInterface}
%   \begin{pssyntax}
%     \PSvar{Xp Yp Xr Yr mode n2 X0 Y0 Xin Yin} \PSop{CurvedInterface} \PSvar{X0' Y0' Xout Yout}
%   \end{pssyntax}
%    \begin{macrocode}
/CurvedInterface {
  /Yin ED /Xin ED /Y0 ED /X0 ED /n2 ED /mode ED
  2 copy /Yr ED /Xr ED 
  tx@Dict begin Pyth end /radius ED /Yp ED /Xp ED
  /X0n X0 Xp sub def /Y0n Y0 Yp sub def
  n2 1 gt { /n2 n2 nmul mul nadd add def } if
  tx@EcldDict begin
    X0n Y0n 2 copy 2 copy Xin 3 -1 roll add Yin 3 -1 roll add
    2 copy 6 2 roll EqDr radius InterLineCircle
  end
  4 copy
  0 eq 3 {exch 0 eq and} repeat {
%    \end{macrocode}
% check if all coordinates are zero, missed circle, stop
%    \begin{macrocode}
%%    PlaneNum PN sub 4 add {pop} repeat
%%    exit
    missed
  } {
    4 copy
%    \end{macrocode}
% Chose which of the two intersection points to take.
%    \begin{macrocode}
    Xr neg Yr neg 2 copy
    8 -2 roll @ABDist
    5 1 roll @ABDist
    gt {
%    \end{macrocode}
% «dist from first point» $>$ «dist from second point», take second point.
%    \begin{macrocode}
      4 2 roll
    } if pop pop
    Xp Yp VecAdd
    2 copy Xp Yp 4 2 roll @ABVect exch neg Xin Yin 4 2 roll NormalVec 
    Xin Yin 4 2 roll
%    \end{macrocode}
% on stack: crossing point, in vector, and normal vector
%    \begin{macrocode}
    mode trans eq {
      n1 n2 RefractVec
      2 copy 0 eq exch 0 eq and { tir } { ok } ifelse
    } {
      ReflectVec ok
    } ifelse /n1 n2 def
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{PlainInterface}
%   \begin{pssyntax}
%     \PSvar{Xp Yp dXp dYp mode n2 X0 Y0 Xin Yin} \PSop{PlainInterface} \PSvar{X0' Y0' Xout Yout}
%   \end{pssyntax}
%    \begin{macrocode}
/PlainInterface {%
  /Yin ED /Xin ED /Y0 ED /X0 ED /n2 ED /mode ED 
  /dYp ED /dXp ED /Yp ED /Xp ED
  n2 1 gt { /n2 n2 nmul mul nadd add def } if
  Xp Yp Xp dXp add Yp dYp add X0 Y0 X0 Xin add Y0 Yin add 
  @InterLines missed eq {
    missed
  } {
    Xin Yin Xin Yin dXp dYp NormalVec
    mode trans eq {
      n1 n2 RefractVec
      2 copy 0 eq exch 0 eq and { tir } { ok } ifelse
    } {
      ReflectVec ok
    } ifelse /n1 n2 def
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{TangentCrosspoint}
% Xp Yp Xt1 Yt1 Xt2 Yt2
%    \begin{macrocode}
/TangentCrosspoint {
    4 copy 4 copy 14 -2 roll 2 copy
    6 2 roll @ABVect neg exch
    6 2 roll @ABVect neg exch
    8 -2 roll VecAdd 10 2 roll VecAdd
    @InterLines pop
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NearestNodeTmp}
% {NodeB} CompA -> shortest distance, planenum
%    \begin{macrocode}
/NearestNodeTmp {
  exch /NodeB ED
  /dist -1 def
  1 {% name and counter on stack
    2 copy % name cnt name cnt 
    NodeName dup
    tx@NodeDict exch known {%
      @GetCenter 2 copy
      NodeB @ABDist % name cnt X Y dist
      dist 0 lt {% init /dist
        /dist ED
        ToVec /node ED
      } {
        dup dist lt {
          /dist ED
          ToVec /node ED
        } {
          pop pop pop
        } ifelse
      } ifelse
      1 add % increment counter
    } {% the last node
      pop pop (N) NodeName
      @GetCenter 2 copy
      NodeB @ABDist
      dup dist lt {
        /dist ED
        ToVec /node ED
      } {
        pop pop pop
      } ifelse
      exit
    } ifelse
  } loop
  dist /node load
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{NearestNode}
% CompA/NodeA CombB/NodeB -> Coordinates of nodeA or the node of CompA which is nearest to nodeB
%    \begin{macrocode}
/NearestNode {
  dup xcheck not { nametostr } if /CompB ED
  dup xcheck not {
%    \end{macrocode}
% CompA is a component
%    \begin{macrocode}
    nametostr /CompA ED
    /CompB load dup xcheck not {
%    \end{macrocode}
% CompB is a component
%    \begin{macrocode}
      /mindist -1 def
      [ exch false GetInternalNodeNames ] 
      { @GetCenter ToVec
        CompA NearestNodeTmp 
        exch dup mindist gt mindist 0 ge and { 
          pop pop 
        }{ 
          /mindist ED /minnodeA ED 
        } ifelse
      } forall
      minnodeA
    } {
      CompA NearestNodeTmp exch pop exec
    } ifelse
  } {
%    \end{macrocode}
% else, it is a node and we already have the appropriate coordinates on the
% stack
%    \begin{macrocode}
    exec
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{RelFiberAngle}
% Calculate start angle of \cs{nccurve} from CompA to CompB
%
% $@@X_B$ $@@Y_B$ $@@X_A$ $@@Y_A$ A B $\quad\longmapsto\quad$ angleA
%    \begin{macrocode}
/RelFiberAngle {
  dup xcheck not { nametostr } if /CompB ED
  dup xcheck not { nametostr } if /CompA ED
  /CompA load xcheck {
    /CompB load xcheck {
%    \end{macrocode}
%  both parameters are nodes, so the angle is that of the direct connection line.
%    \begin{macrocode}
      @ABVect exch atan
    } {
%    \end{macrocode}
% B is a component, and A is a node: the angle at node A is calculated through the reference nodes of component B
%    \begin{macrocode}
      4 copy @ABVect 6 2 roll pop pop
      CompB dup dup (Center) NodeName @GetCenter 
      6 -2 roll 4 2 roll @ABVect 4 2 roll
      (A) NodeName exch (B) NodeName
      @GetCenter 3 -1 roll @GetCenter @ABVect 2 copy exch atan
      7 3 roll 2 copy 9 -2 roll
      SProd 0 gt 5 1 roll SProd 0 gt xor { 180 add } if
    } ifelse
  } {
%    \end{macrocode}
% A is a component, B is insignificant
%    \begin{macrocode}
    4 2 roll pop pop
    CompA dup dup (Center) NodeName @GetCenter 
    6 -2 roll @ABVect 4 2 roll
    (TrefA) NodeName exch (TrefB) NodeName
    @GetCenter 3 -1 roll @GetCenter @ABVect 2 copy exch atan
    5 1 roll SProd 0 gt { 180 add } if
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{getsubnode}
% subname node/name  -> coordinates
%    \begin{macrocode}
/getsubnode {
  dup xcheck {
    exch pop exec
  } {
    nametostr exch nametostr NodeName
    @GetCenter
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{connectPlanes}
%   \begin{pssyntax}
%     \PSproc{vec}
%   \end{pssyntax}
% Vec Vec Center CenterTemp mode relangle
%    \begin{macrocode}
/connectPlanes {
  /relAngleTmp ED
  PN 2 eq {
%    \end{macrocode}
% initialize relAngle, the angle between plane connection and input vector
%    \begin{macrocode}
    pop @ABVect NormalizeVec 4 2 roll VecAngle /relAngleTmp ED
  } if
  PN 3 ge {
    trans eq {
%    \end{macrocode}
% previous plane was transmittive, recalculate the input vector
%    \begin{macrocode}
      @ABVect NormalizeVec 4 2 roll pop pop % remove Vec from stack
      relAngleTmp matrix rotate dtransform
      4 2 roll pop pop
    } {
%    \end{macrocode}
% else, the previous plane was reflective, recalculate relAngle
%    \begin{macrocode}
      @ABVect NormalizeVec 4 2 roll VecAngle /relAngleTmp ED
    } ifelse
  } if
  relAngleTmp
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{GetCompRange}
% \PSstring{basename} \PSvar{start stop} 
% \PSop{GetCompRange} \PSstring{basenamestart} \ldots\ \PSstring{basenamestop}
%    \begin{macrocode}
/GetCompRange {
  2 copy gt { 1 }{ -1 } ifelse 3 -1 roll
  { exch dup 3 -1 roll inttostr strcat exch} for
  pop
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{CorrectDipoleNodes}
%   For a dipole which has two interface nodes (1) and (N) which are
%   very close together ($\text{dist} < 10^{-7}$) or which coincide, the
%   automatic angle estimation of the fiber connections does not work
%   properly. So these nodes are separated as less as possible so that
%   the NearestNode procedure estimates two different distances.
%   \begin{pssyntax}
%     \PSstring{node1} \PSstring{node2} \PSstring{basename} \PSop{CorrectDipoleNodes}
%   \end{pssyntax}
%    \begin{macrocode}
/CorrectDipoleNodes {
  dup dup dup
  6 -1 roll NodeName exch 5 -1 roll NodeName 2 copy 6 2 roll
  gsave
    tx@Dict begin 
      STV CP T
      exch @GetCenter 3 -1 roll @GetCenter
    end
  grestore
  4 copy @ABDist 1e-7 lt {
%    \end{macrocode}
% The two nodes are closer together than $10^{-7}$, correct that to avoid
% problems with the angle direction when drawing fibers.
%    \begin{macrocode}
    6 -1 roll
    gsave
      tx@Dict begin 
        STV CP T
        (TrefA) NodeName @GetCenter 7 -1 roll 
        (TrefB) NodeName @GetCenter 
      end
    grestore
    @ABVect NormalizeVec 2 copy
%    \end{macrocode}
% The floating-point precision of the Postscript interpreter is
% approximately 8 digits, so in order to have an effect, the nodes must
% be separated by $10^{-7}$ times the maximum coordinate value.
%    \begin{macrocode}
    8 -2 roll 2 copy abs exch abs max 2e-7 mul 3 1 roll 5 2 roll 
    VecMul VecAdd ToVec 7 -1 roll @NewNode
    4 2 roll 2 copy abs exch abs max -2e-7 mul 3 1 roll 5 2 roll 
    VecMul VecAdd ToVec exch @NewNode
  } {
    8 { pop } repeat
  } ifelse
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{debug}
%   Print out the last \opt{N} elements from the stack, checks for
%   stackunderflow. I \opt{N} is negative, the complete stack is
%   printed. Compared to the \PSvar{stack} operand, it prints the content of
%   procedures and array, which we use a lot.
%   \begin{pssyntax}
%     \PSvar{N} \PSop{debug}
%   \end{pssyntax}
%    \begin{macrocode}
/debug { 
  /@N ED count dup @N gt @N 0 ge and { pop @N } if 
  copy @N { == } repeat
} bind def
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{debugComp}
% Print out all parameters and planes of the component \opt{compname}.
%   \begin{pssyntax}
%     \PSstring{compname} \PSop{debugComp}
%   \end{pssyntax}
%    \begin{macrocode}
/debugComp { 
  dup (debug comp ") exch strcat ("-------------) strcat ==
  cvn load { 
    dup type /dicttype eq {
      (plane----------------) == 
      { == == } forall
      } { == } ifelse
      ==
  } forall
} bind def
%    \end{macrocode}
% \end{macro}

%
%    \begin{macrocode}
end % tx@OptexpDict
%    \end{macrocode}
%</prolog> 
% \Finale
% \endinput
%
%<*indexstyle>
headings_flag       1
heading_prefix   "\\textbf{"
heading_suffix   "}\n"
quote		'"'
level		'!'
actual          '='
preamble
  "\\begin{theindex}\n"
item_1
  "\\par\\leavevmode\\hangindent10pt\\makebox[15pt][l]{ -- }"
item_01
  "\\par\\leavevmode\\hangindent10pt\\makebox[15pt][l]{ -- }"
item_x1
  "\\par\\leavevmode\\hangindent10pt\\makebox[15pt][l]{ -- }"
item_2
  "\\par\\leavevmode\\hangindent20pt\\makebox[30pt][l]{ -- -- }"
item_12
  "\\par\\leavevmode\\hangindent20pt\\makebox[30pt][l]{ -- -- }"
item_x2
  "\\par\\leavevmode\\hangindent20pt\\makebox[30pt][l]{ -- -- }"
%</indexstyle>
